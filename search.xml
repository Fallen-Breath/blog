<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BuyVM VPS /48 IPv6 子网配置</title>
    <url>/zh-CN/2025/buyvm-ipv6-pool-init/</url>
    <content><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1>
<p><a href="https://my.frantech.ca/cart.php">BuyVM / frantech</a> 家 VPS 的一大特点就是送一个 /48 段的 IPv6 的子网。这个 /48 子网不是开箱即用的，需要一些配置才能用起来</p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/buyvm.png" alt="buyvm"></p>
<p>下文介绍在 Ubuntu 系统环境下，使用 netplan 配置 BuyVM IPv6 的方法。
最终效果是：应用程序可任意使用此 /48 子网里的 IP 来访问互联网，无需任何额外配置</p>
<p>注意：此方案可能只对 BuyVM 有效，不一定适用于其他家的 VPS</p>
<span id="more"></span>
<h1 id="环境"><a class="header-anchor" href="#环境"></a>环境</h1>
<ul>
<li>一台 Las Vegas 的 BuyVM 机子，配置无所谓，都有 /48 IPv6  子网</li>
<li>系统是 Ubuntu 24.04</li>
</ul>
<p>应该适用于 Ubuntu &gt;= 18 的，使用 <a href="https://netplan.io/">netplan</a> 来管理网络环境的 Ubuntu 发行版</p>
<p>要重装系统的话，可以去 <a href="https://manage.buyvm.net/">Stallion</a> 面板里重装</p>
<h1 id="初始状态"><a class="header-anchor" href="#初始状态"></a>初始状态</h1>
<p>VPS 刚开始是未分配 IPv6 地址，也没有配置 IPv6 子网的。因此 VPS 无法访问 IPv6 地址的服务，只能访问 IPv4 的服务</p>
<p>可通过下面命令来验证这点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~<span class="comment"># ifconfig eth0</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 1.2.3.4  netmask 255.255.255.0  broadcast 1.2.3.255</span><br><span class="line">        inet6 fe80::216:bff:fe73:2998  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:16:0b:73:29:98  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1418533  bytes 295931477 (295.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1408074  bytes 152883531 (152.8 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@localhost:~<span class="comment"># curl ipv6.ip.sb</span></span><br><span class="line">curl: (7) Failed to connect to ipv6.ip.sb port 80 after 1 ms: Couldn<span class="string">&#x27;t connect to server</span></span><br></pre></td></tr></table></figure>
<p>如果默认网卡不是 eth0 的话，可以直接输入 <code>ifconfig</code> 来列出全部网卡。默认网卡可能会是 <code>eth1</code>, <code>ens18</code> 等</p>
<p>如果显示 <code>ifconfig</code> 命令不存在，可以 apt 装一下：<code>sudo apt install -y net-tools</code></p>
<h1 id="Stallion-面板操作"><a class="header-anchor" href="#Stallion-面板操作"></a>Stallion 面板操作</h1>
<p>首先，需要去 BuyVM 的 <a href="https://manage.buyvm.net/">Stallion</a> 面板那，进行一些 VPS 的网络配置</p>
<h2 id="添加主-IPv6-地址"><a class="header-anchor" href="#添加主-IPv6-地址"></a>添加主 IPv6 地址</h2>
<p>去 Stallion 面板的 VPS 管理界面，Networking - IPv6 栏，添加一个主 IPv6 地址。</p>
<p>这个 IPv6 地址将会是 VPS 访问 IPv6 服务时，默认用的 IPv6 地址，并非是那个 /48 IPv6 子网</p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/assign_single_ipv6_pre.png" alt="IPv6"></p>
<p>点 “Assign IPv6 Address” 分配一个，后 4 段就写 0 0 0 1 就好，比较简单，用起来也方便</p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/assign_single_ipv6_configure.png" alt="配置"></p>
<p>然后启用，保存</p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/assign_single_ipv6_save.png" alt="保持"></p>
<p>不妨假设这个分配的 IPv6 地址是 <code>2605:6400:aaaa:bbbb::1</code>，后面要用到</p>
<p>理论上这个时候，去 VPS 上配置下 netplan，就能用这个主 IPv6 地址来访问 IPv6 服务了。
不过不急着现在就去配，可以在搞好了 /48 IPv6  子网后一步到位</p>
<h2 id="配置-IPv6-子网"><a class="header-anchor" href="#配置-IPv6-子网"></a>配置 IPv6 子网</h2>
<p>在 Stallion 面板里，前往往 Networking - Routed Subnets 栏，能看到有一个 /48 的子网。这个子网就是那个 /48 IPv6  子网了</p>
<p>不妨设此子网为 <code>2605:6400:cccc::/48</code>。下面配置开始配置此子网的路由</p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/configure_ipv6_pool_pre.png" alt="Routed Subnets"></p>
<p>Nexthop IP address 的下拉栏里应该能看到刚才新增的那个 <code>2605:6400:aaaa:bbbb::1</code></p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/configure_ipv6_pool_configure.png" alt="配置"></p>
<p>Delegated Nameserver #1、Delegated Nameserver #2 这俩都可以不填</p>
<p>然后点 Save、Save Changes 一路保存。这个 Subnet 状态变成 ENABLED 就代表 OK 了</p>
<p><img data-src="/zh-CN/2025/buyvm-ipv6-pool-init/configure_ipv6_pool_save.png" alt="保存"></p>
<p>至此，BuyVM 的 Stallion 后台的操作已完成</p>
<h1 id="VPS-配置"><a class="header-anchor" href="#VPS-配置"></a>VPS 配置</h1>
<p>下面操作需 SSH 连上 VPS 来进行</p>
<h2 id="netplan"><a class="header-anchor" href="#netplan"></a>netplan</h2>
<p>先改 netplan，配置好那个主 IPv6 地址，以及 IPv6 池</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用任意编辑器打开此文件</span></span><br><span class="line">sudo vim /etc/netplan/01-netcfg.yaml</span><br></pre></td></tr></table></figure>
<p>如果 <code>/etc/netplan/01-netcfg.yaml</code> 文件不存在的话，可以去 <code>/etc/netplan</code> 找找有没有其他的。至少 BuyVM 后台重装的 Ubuntu 24 是有这个配置的</p>
<p>这个配置文件的内容参考如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="comment"># &quot;eth0&quot; 是默认网卡名字，可以 ifconfig 看。一些可能的取值：eth0、ens3</span></span><br><span class="line">    <span class="attr">eth0:</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">        <span class="comment"># 配置 eth0 网卡绑定的地址</span></span><br><span class="line">        <span class="comment">#   `1.2.3.4`                是 VPS 的 IPv4 地址。BuyVM 的 IPv4 都在 /24 的子网里，因此有 /24 后缀</span></span><br><span class="line">        <span class="comment">#   `2605:6400:aaaa:bbbb::1` 是 VPS 的 IPv6 地址。BuyVM 的 IPv6 都在 /48 的子网里，因此有 /48 后缀</span></span><br><span class="line">        <span class="comment"># 注意这里的 IPv6 地址并非 VPS 独享的那个 /48 IPv6  子网，而是上面说的“主 IPv6”</span></span><br><span class="line">        <span class="comment"># 参考 BuyVM 官网 wiki：</span></span><br><span class="line">        <span class="comment">#   https://wiki.buyvm.net/doku.php/kvm#ipv4</span></span><br><span class="line">        <span class="comment">#   https://wiki.buyvm.net/doku.php/kvm#ipv6</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;1.2.3.4/24&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;2605:6400:aaaa:bbbb::1/48&#x27;</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span></span><br><span class="line">          <span class="comment"># 这里用 Google 和 Cloudflare 的 IPv4 / IPv6 DNS 服务器。你想用其他的当然也行</span></span><br><span class="line">          <span class="comment">#   https://developers.google.com/speed/public-dns/docs/using</span></span><br><span class="line">          <span class="comment">#   https://developers.cloudflare.com/1.1.1.1/ip-addresses/</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">2001</span><span class="string">:4860:4860::8888</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">2606</span><span class="string">:4700:4700::1111</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment"># 默认的 IPv4 出口。填写 IPv4 网关地址</span></span><br><span class="line">        <span class="comment"># IPv4 网关是把 VPS 的 IPv4 地址最后一节改成 1。比如 1.2.3.4 就把最后的 4 改成 1</span></span><br><span class="line">        <span class="comment"># 参考 BuyVM 官网 wiki：https://wiki.buyvm.net/doku.php/kvm#ipv4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span>  </span><br><span class="line">          <span class="attr">via:</span> <span class="string">&#x27;1.2.3.1&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认的 IPv6 出口。填写 IPv6 网关地址</span></span><br><span class="line">        <span class="comment"># BuyVM 每个地域的 IPv6 网关都是固定的，可以去 wiki 看：https://wiki.buyvm.net/doku.php/kvm#ipv6</span></span><br><span class="line">        <span class="comment"># 比如 Las Vegas 的 IPv6 网关地址是 2605:6400:20::1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">via:</span> <span class="string">&#x27;2605:6400:20::1&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># /48 IPv6 子网配置</span></span><br><span class="line">        <span class="comment"># 将这个 IPv6 子网分配给 eth0 网卡</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">&#x27;2605:6400:cccc::/48&#x27;</span></span><br><span class="line">          <span class="attr">scope:</span> <span class="string">link</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure>
<p>无注释版本</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">eth0:</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;1.2.3.4/24&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;2605:6400:aaaa:bbbb::1/48&#x27;</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">2001</span><span class="string">:4860:4860::8888</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">2606</span><span class="string">:4700:4700::1111</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span>  </span><br><span class="line">          <span class="attr">via:</span> <span class="string">&#x27;1.2.3.1&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">via:</span> <span class="string">&#x27;2605:6400:20::1&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">&#x27;2605:6400:cccc::/48&#x27;</span></span><br><span class="line">          <span class="attr">scope:</span> <span class="string">link</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure>
<p>配置完后，就准备应用这个配置了</p>
<p>（可选）先改一下 <code>/etc/netplan/01-netcfg.yaml</code> 的权限位，这样 netplan 不会有 warning</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 600 /etc/netplan/01-netcfg.yaml</span><br></pre></td></tr></table></figure>
<p>建议用 <code>netplan try</code> 来应用配置，这样如果配错了导致 VPS 断网，过一会也可恢复。
如果用 <code>netplan apply</code>（不推荐）来配置还配错了的话，可能就得去 BuyVM 后台 VNC 上去抢救了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netplan try</span><br></pre></td></tr></table></figure>
<p>如果上面命令执行完后，ssh 没卡死，就输入回车，让这个配置生效</p>
<p>这个时候，主 IPv6 地址就已生效了。可用下面命令检查一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig eth0</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 209.141.54.202  netmask 255.255.255.0  broadcast 209.141.54.255</span><br><span class="line">        inet6 fe80::216:bff:fe73:2998  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        inet6 2605:6400:20:6c4::1  prefixlen 48  scopeid 0x0&lt;global&gt;     <span class="comment"># &lt;--- 看这，主 IPv6 地址出现了</span></span><br><span class="line">        ether 00:16:0b:73:29:98  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 19727111  bytes 2939632909 (2.9 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1911160  bytes 225866689 (225.8 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">$ curl ipv6.ip.sb</span><br><span class="line">2605:6400:aaaa:bbbb::1</span><br></pre></td></tr></table></figure>
<h2 id="sysctl"><a class="header-anchor" href="#sysctl"></a>sysctl</h2>
<p>最后，在配置下 sysctl 的 <code>net.ipv6.ip_nonlocal_bind=1</code>，用于允许进程绑定到本地未配置的 IPv6 地址。
这样应用程序就可以直接用用 IPv6 池里任意的 IPv6 地址来访问互联网</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时配置，重启后失效</span></span><br><span class="line">sudo sysctl -w net.ipv6.ip_nonlocal_bind=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时配置 + 持久化</span></span><br><span class="line">sudo sysctl -w net.ipv6.ip_nonlocal_bind=1 | sudo <span class="built_in">tee</span> /etc/sysctl.d/ipv6_ip_nonlocal_bind.conf</span><br></pre></td></tr></table></figure>
<p>完工。可以用 curl 验证下下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl ipv6.ip.sb --interface 2605:6400:cccc::1</span><br><span class="line">2605:6400:cccc::1</span><br><span class="line"></span><br><span class="line">$ curl ipv6.ip.sb --interface 2605:6400:cccc::1234</span><br><span class="line">2605:6400:cccc::1234</span><br><span class="line"></span><br><span class="line">$ curl ipv6.ip.sb --interface 2605:6400:cccc:a:b:c:d:e</span><br><span class="line">2605:6400:cccc:a:b:c:d:e</span><br></pre></td></tr></table></figure>
<h2 id="完整流程的示例输出"><a class="header-anchor" href="#完整流程的示例输出"></a>完整流程的示例输出</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~<span class="comment"># sudo sysctl -w net.ipv6.ip_nonlocal_bind=1 | sudo tee /etc/sysctl.d/ipv6_ip_nonlocal_bind.conf</span></span><br><span class="line">net.ipv6.ip_nonlocal_bind = 1</span><br><span class="line">root@localhost:~<span class="comment"># sudo chmod 600 /etc/netplan/01-netcfg.yaml</span></span><br><span class="line">root@localhost:~<span class="comment"># sudo vim /etc/netplan/01-netcfg.yaml</span></span><br><span class="line">root@localhost:~<span class="comment"># sudo netplan try</span></span><br><span class="line">Do you want to keep these settings?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Press ENTER before the <span class="built_in">timeout</span> to accept the new configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Changes will revert <span class="keyword">in</span> 119 seconds</span><br><span class="line">Configuration accepted.</span><br><span class="line">root@localhost:~<span class="comment"># curl ipv6.ip.sb</span></span><br><span class="line">2605:6400:aaaa:bbbb::1</span><br><span class="line">root@localhost:~<span class="comment"># curl ipv6.ip.sb --interface 2605:6400:cccc::1234</span></span><br><span class="line">2605:6400:cccc::1234</span><br></pre></td></tr></table></figure>
<h1 id="Aeza"><a class="header-anchor" href="#Aeza"></a>Aeza</h1>
<p>Aeza 分配的 /48 IPv6 和其主 IPv6 是在同一个 /48 子网里的。不像 BuyVM 那样是单独分一个 Routed /48 IPv6 出来</p>
<p>不妨设分配了 <code>aaaa:bbbb:cccc::/48</code>，其中：</p>
<ul>
<li><code>aaaa:bbbb:cccc::1</code> 是网关</li>
<li><code>aaaa:bbbb:cccc::2</code> 是主 IPv6</li>
</ul>
<h2 id="通用"><a class="header-anchor" href="#通用"></a>通用</h2>
<p>记得配置 sysctl <code>net.ipv6.ip_nonlocal_bind</code></p>
<p>由于不是独立的 Routed /48 IPv6，需要配一下 ndppd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y ndppd</span><br><span class="line">apt install -y ndppd</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> --now ndppd</span><br></pre></td></tr></table></figure>
<p>编辑 <code>/etc/ndppd.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy ens3 &#123;</span><br><span class="line">  router yes</span><br><span class="line">  rule aaaa:bbbb:cccc::/48 &#123;</span><br><span class="line">    static</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完配置文件后重启 ndppd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart ndppd</span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu"><a class="header-anchor" href="#Ubuntu"></a>Ubuntu</h2>
<p>给 netplan 的配置 <code>/etc/netplan/50-cloud-init.yaml</code> 加一个 route。下面 yaml 为新增的部分</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens3:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">&quot;aaaa:bbbb:cccc::/48&quot;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure>
<h2 id="RHEL9"><a class="header-anchor" href="#RHEL9"></a>RHEL9</h2>
<p>临时方法（重启后失效）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip -6 route add <span class="built_in">local</span> aaaa:bbbb:cccc::/48 dev lo</span><br></pre></td></tr></table></figure>
<p>永久方法 1（重启 VPS 后可能因 lo 的 uuid 变动而失效）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection modify lo +ipv6.routes <span class="string">&quot;aaaa:bbbb:cccc::/48 :: type=local&quot;</span></span><br><span class="line">nmcli connection up lo</span><br></pre></td></tr></table></figure>
<p>永久方法 2（依赖 NetworkManager 版本 &gt;= 1.41.6。可用 <code>nmcli --version</code> 检查）</p>
<p>参考：<a href="https://access.redhat.com/solutions/2108251">https://access.redhat.com/solutions/2108251</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection add connection.id lo connection.type loopback connection.interface-name lo connection.autoconnect <span class="built_in">yes</span></span><br><span class="line">nmcli connection modify lo +ipv6.routes <span class="string">&quot;aaaa:bbbb:cccc::/48 :: type=local&quot;</span></span><br><span class="line">nmcli connection up lo</span><br></pre></td></tr></table></figure>
<p>执行第一条命令好像有个 warning <code>Warning: There is another connection with the name 'lo'. Reference the connection by its uuid</code>，似乎无伤大雅的样子</p>
<h1 id="netcup-HE-Tunnel-Broker"><a class="header-anchor" href="#netcup-HE-Tunnel-Broker"></a>netcup + HE Tunnel Broker</h1>
<p>netcup 自带一个 IPv6 /64 子网</p>
<p>目标：</p>
<ul>
<li>
<p>不影响默认 /64 子网</p>
<ul>
<li>默认 IPv6 出口仍为 netcup 的 IPv6</li>
</ul>
</li>
<li>
<p>配置好 HE Tunnel Broker 的 IPv6</p>
<ul>
<li>可绑定 HE Tunnel 分配的 Client IPv6 Address</li>
<li>可任意绑定 HE Tunnel 的 /64 IPv6 子网</li>
<li>可任意绑定 HE Tunnel 的 /48 IPv6 子网</li>
</ul>
<p>即下面这些命令均可成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ipv6.ip.sb --interface he-ipv6</span><br><span class="line">curl ipv6.ip.sb --interface 2001:470:aaa:bbb::2</span><br><span class="line">curl ipv6.ip.sb --interface 2001:470:aaa:bbb::abcd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>记得配置 sysctl <code>net.ipv6.ip_nonlocal_bind</code></p>
<h2 id="Ubuntu-2"><a class="header-anchor" href="#Ubuntu-2"></a>Ubuntu</h2>
<p>加一个 <code>/etc/netplan/99-he-tunnel.yaml</code>，配置 he tunnel，就行了</p>
<p>这里的 routes 都加了个 <code>metric: 200</code>，这样不会和主路由（如 <code>/etc/netplan/50-cloud-init.yaml</code> 里的配置）冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  tunnels:</span><br><span class="line">    he-ipv6:</span><br><span class="line">      mode: sit</span><br><span class="line">      remote: 5.6.7.8  <span class="comment"># HE Tunnel 的服务器 IPv4 (Server IPv4 Address)</span></span><br><span class="line">      <span class="built_in">local</span>: 1.2.3.4  <span class="comment"># VPS 的 IPv4 (Client IPv4 Address)</span></span><br><span class="line">      addresses:</span><br><span class="line">        - <span class="string">&quot;2001:470:aaa:bbb::2/64&quot;</span>  <span class="comment"># HE Tunnel 分配的主 IPv6 (Client IPv6 Address)</span></span><br><span class="line">      routes:</span><br><span class="line">        - to: default</span><br><span class="line">          via: <span class="string">&quot;2001:470:aaa:bbb::1&quot;</span>  <span class="comment"># HE Tunnel 分配的 IPv6 网关 (Server IPv6 Address)</span></span><br><span class="line">          metric: 200</span><br><span class="line">        - to: <span class="string">&quot;2001:470:ccc:ddd::/64&quot;</span>  <span class="comment"># HE Tunnel 分配的 /64 Pv6 子网 (Routed /64)</span></span><br><span class="line">          scope: <span class="built_in">link</span></span><br><span class="line">          <span class="built_in">type</span>: <span class="built_in">local</span></span><br><span class="line">          metric: 200</span><br><span class="line">        - to: <span class="string">&quot;2001:470:eee::/48&quot;</span>  <span class="comment"># HE Tunnel 分配的 /48 Pv6 子网 (Routed /48)</span></span><br><span class="line">          scope: <span class="built_in">link</span></span><br><span class="line">          <span class="built_in">type</span>: <span class="built_in">local</span></span><br><span class="line">          metric: 200</span><br></pre></td></tr></table></figure>
<h2 id="RHEL"><a class="header-anchor" href="#RHEL"></a>RHEL</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config tunnel</span></span><br><span class="line">ip tunnel add he-ipv6 mode sit remote 5.6.7.8 <span class="built_in">local</span> 1.2.3.4 ttl 255</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> he-ipv6 up</span><br><span class="line">ip addr add 2001:470:aaa:bbb::2/64 dev he-ipv6</span><br><span class="line"></span><br><span class="line"><span class="comment"># config table (basic)</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> /etc/iproute2/rt_tables might not exists</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;100 he-tunnel&quot;</span> &gt;&gt; /etc/iproute2/rt_tables</span><br><span class="line">ip -6 route add default via 2001:470:aaa:bbb::1 dev he-ipv6 table he-tunnel</span><br><span class="line">ip -6 rule add from 2001:470:aaa:bbb::/64 lookup he-tunnel</span><br><span class="line"></span><br><span class="line"><span class="comment"># config table (/64 subnet)</span></span><br><span class="line">ip -6 route add <span class="built_in">local</span> 2001:470:ccc:ddd::/64 dev lo table <span class="built_in">local</span></span><br><span class="line">ip -6 rule add from 2001:470:ccc:ddd::/64 lookup he-tunnel</span><br><span class="line"></span><br><span class="line"><span class="comment"># config table (/48 subnet)</span></span><br><span class="line">ip -6 route add <span class="built_in">local</span> 2001:470:eee::/48 dev lo table <span class="built_in">local</span></span><br><span class="line">ip -6 rule add from 2001:470:eee::/48 lookup he-tunnel</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">ip -6 route get 2001:db8::1 from 2001:470:aaa:bbb::2</span><br><span class="line">ip -6 route get 2001:db8::1 from 2001:470:ccc:ddd::abcd</span><br><span class="line"></span><br><span class="line">curl ipv6.ip.sb --interface 2001:470:aaa:bbb::2</span><br><span class="line">curl ipv6.ip.sb --interface 2001:470:ccc:ddd::abcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># fix --interface he-ipv6</span></span><br><span class="line"><span class="comment"># TODO</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>BuyVM</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析Minecraft #0 绪论</title>
    <url>/zh-CN/2019/deeply-dissecting-minecraft_0/</url>
    <content><![CDATA[<h1 id="0-绪论"><a class="header-anchor" href="#0-绪论"></a>0 绪论</h1>
<h2 id="0-1-owo"><a class="header-anchor" href="#0-1-owo"></a>0.1 owo</h2>
<p>嘛，填这个巨坑的目的，是想对啃了一段时间的源码做一些总结，并给出一些对现象的解释，如果可能的话还会给出一些易于分析的模型</p>
<p>前人的理论虽已挺完善，已经有了不少的分析文章，但他们或多或少的都存在一些无法解释的现象，或者说以为版本迭代而过时</p>
<p>强推 gp（Gamepiaynmo）的文章<a href="http://tieba.baidu.com/p/4078230299">《[理论分析]红石更新延迟理论》</a>，虽然这个是 1.8 的，但绝大部分内容在 1.13.2 仍适用</p>
<p>我的目标是，<s>造出不需要打补丁的大统一理论</s>在不打补丁的情况下解释出所有平常只会用一句“特性” / “毒性”带过的表现，以及所有“黑科技”的原理。因此可ken能ding会很咕</p>
<span id="more"></span>
<p><strong>请善用文档导航XD</strong></p>
<h2 id="0-2-前置技能"><a class="header-anchor" href="#0-2-前置技能"></a>0.2 前置技能</h2>
<ul>
<li>对于代码分析部分，你需要一定的 java 代码的阅读能力</li>
<li>对于理论模型部分，你可能需要掌握一些简单的算法与数据结构的知识</li>
<li>对于实用模型部分，只要你足够了解红石，都没问题</li>
</ul>
<h2 id="0-3-代码来源"><a class="header-anchor" href="#0-3-代码来源"></a>0.3 代码来源</h2>
<p>本文若无特殊说明，<strong>Minecraft 游戏版本为 Minecraft Java Edition 1.13.2</strong>，代码来源为 gnenbom 的 1.13.2 的 <a href="https://github.com/gnembon/carpetmod">carpet mod</a> 内的 <code>projects/clean/src/</code> 部分。如有能力可自行按照 readme 构建源码</p>
<h2 id="0-4-一些名词的定义"><a class="header-anchor" href="#0-4-一些名词的定义"></a>0.4 一些名词的定义</h2>
<blockquote>
<p>[元件] 的 [事件] 在 [阶段] 发生</p>
</blockquote>
<h3 id="Tile-Tick"><a class="header-anchor" href="#Tile-Tick"></a>Tile Tick</h3>
<p>TileTick 指的是各类具有延迟的红石元件，如中继器、红石火把运算的阶段，在代码层面指的是 <code>ServerTickList.tick()</code>  <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>中执行的内容</p>
<p>在 gp 的文章<a href="http://tieba.baidu.com/p/4078230299">《[理论分析]红石更新延迟理论》</a>里，gp 将此阶段命名为 NextTickEntry ，缩写为 NTE 。</p>
<p>为了与国外社区的游戏阶段名词接轨，在本文中此阶段一律用 TileTick 表示</p>
<h3 id="Tile-Entity"><a class="header-anchor" href="#Tile-Entity"></a>Tile Entity</h3>
<p>TileEntity，简称 TE ，指的是游戏内有特殊功能的方块上，附加的实体，这一类的方块有熔炉、漏斗、移动中的方块、末地折跃门等方块，而在正常游戏中这些方块均会带有一个 Tile Entity 来运算实现它们的特殊功能</p>
<p>在官方的反混淆中，TileEntity 被称为 BlockEntity ，这也恰好对应着它的中文翻译：方块实体。不过，为了与前人所述衔接，在本文中仍用 TileEntity 一称</p>
<h3 id="Block-36"><a class="header-anchor" href="#Block-36"></a>Block 36</h3>
<p>Block 36，简称 b36，指移动中的方块，也即 <code>BlockPistonMoving</code> 这一个类所描述的方块，亦或是游戏内称作 <code>moving_piston</code> 的方块。其中 36 指的是方块 id 扁平化前的该方块的 id，也算是沿用惯用用法。</p>
<p>在本文的分析中，b36 有时也可指 b36 TileEntity ，需根据文意进行具体分析</p>
<h3 id="阶段、元件、容器"><a class="header-anchor" href="#阶段、元件、容器"></a>阶段、元件、容器</h3>
<p>以方块实体（Tile Entity）为例。与方块实体相关，可指代的对象有：</p>
<ul>
<li>一个方块实体本身</li>
<li>方块实体运算阶段</li>
<li>存放方块实体容器</li>
</ul>
<p>如果在用简称 TE 来描述它们时，仅用 TE 一词明显会有歧义出现。因此，在使用简称描述时，如有需要，以上几个对象分别对应：</p>
<ul>
<li>TE 元件（TE 方块、TE 实体）</li>
<li>TE 阶段</li>
<li>TE 容器（TE 队列、TE 表）</li>
</ul>
<p><img data-src="/zh-CN/2019/deeply-dissecting-minecraft_0/banner.png" alt="banner"></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>net/minecraft/world/ServerTickList.java:46 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>深度剖析MC</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析Minecraft #1 游戏流程</title>
    <url>/zh-CN/2019/deeply-dissecting-minecraft_1/</url>
    <content><![CDATA[<h1 id="1-游戏流程"><a class="header-anchor" href="#1-游戏流程"></a>1 游戏流程</h1>
<h2 id="1-1-代码层面上的-GameTime-内游戏运算顺序"><a class="header-anchor" href="#1-1-代码层面上的-GameTime-内游戏运算顺序"></a>1.1 代码层面上的 GameTime 内游戏运算顺序</h2>
<p>下图这张树状剖析图，代表了代码层面上，Minecraft 每执行一次 <code>tick()</code> 时的游戏执行顺序：</p>
<span id="more"></span>
<p><img data-src="/zh-CN/2019/deeply-dissecting-minecraft_1/process_analysis.png" alt="游戏流程剖析"></p>
<p>如读者感兴趣，<a href="/2019/12/08/deeply-dissecting-minecraft_1/process_analysis_1.15.2.png">这里</a>是1.15.2版本的流程分析图</p>
<h2 id="1-2-GameTick"><a class="header-anchor" href="#1-2-GameTick"></a>1.2 GameTick</h2>
<p>GameTick（gt），也就是游戏刻，或者说游戏里的时间量，是用来衡量电路延迟、生物生存周期等的重要指标。要想明确 GameTick 是什么，就先得给出 GameTick 的定义</p>
<p>作为一个离散的时间量，在游戏的运算过程中一定存在某个时刻，GameTick 这个时间量发生改变，这就是 GameTick 的分界线。在 1.1 节，我们从代码执行顺序的角度列出了游戏的运算顺序。在这个长达 24 条的列表里，我将 GameTick 的分界线的划分在：<code>GameTime 与 DayTime 加一</code>，并给出GameTick的定义：</p>
<blockquote>
<p>GameTick 为 x 的定义是：所有执行 <code>World.worldInfo.getGameTime()</code> 得到的返回值为 x 的时刻的集合</p>
</blockquote>
<p>于是，我们可以得到事件P发生于GameTick x的定义：</p>
<blockquote>
<p>一个事件P发生于 GameTick x 的定义为：
发生事件P时若执行<code>World.worldInfo.getGameTime()</code>，得到的返回值为 x</p>
</blockquote>
<p>这样做定义 GameTick 的好处有：</p>
<ul>
<li>与 TileTick 元件的执行时间相对应。在 GameTick N 触发的 x gt 延迟 TileTick 元件会在 GameTick N + x 执行动作</li>
<li>可以直观地在代码中调用 <code>World.worldInfo.getGameTime()</code> 来确定当前的 GameTick</li>
</ul>
<p>定义完 GameTick 并确定好分界线后，我们就可以重新排列 1.1 节的树状图，并获得一个 GameTick 内各阶段发生的顺序了：</p>
<p><img data-src="/zh-CN/2019/deeply-dissecting-minecraft_1/process_analysis_wtu.png" alt="游戏流程剖析，从 WTU 开始"></p>
<p>对于与修改服务端世界相关的操作所在的阶段，即树状图中使用黄色标出的阶段，可归纳得到下<strong>常用阶段顺序表</strong>：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>阶段</th>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>设置世界时间</td>
<td>World Time Update</td>
<td>WTU</td>
</tr>
<tr>
<td>2</td>
<td>计划刻</td>
<td>Tile Tick (Next Tick Entry)</td>
<td>TT (NTE)</td>
</tr>
<tr>
<td>3</td>
<td>随机刻与气候</td>
<td>RandomTick&amp;Climate</td>
<td>RTC</td>
</tr>
<tr>
<td>4</td>
<td>村庄运算</td>
<td>Village</td>
<td>V</td>
</tr>
<tr>
<td>5</td>
<td>方块事件</td>
<td>Block Event</td>
<td>BE</td>
</tr>
<tr>
<td>6</td>
<td>实体</td>
<td>Entity Update</td>
<td>EU</td>
</tr>
<tr>
<td>7</td>
<td>方块实体</td>
<td>Tile Entity</td>
<td>TE</td>
</tr>
<tr>
<td>8</td>
<td>玩家操作</td>
<td>Network Update</td>
<td>NU</td>
</tr>
<tr>
<td>9</td>
<td>刷怪</td>
<td>Spawning</td>
<td>S</td>
</tr>
<tr>
<td>10</td>
<td>区块卸载</td>
<td>Chunk Unload</td>
<td>CU</td>
</tr>
</tbody>
</table>
<p>这个常用阶段顺序表是之后分析最为常用的列表，划重点记笔记！（其实只要记住缩写即可，因为下文会大量使用缩写）</p>
<p>对于之后对精确到一个游戏刻内阶段的分析，我称之为：微观时序分析</p>
<h2 id="1-3-游戏事件执行时刻"><a class="header-anchor" href="#1-3-游戏事件执行时刻"></a>1.3 游戏事件执行时刻</h2>
<blockquote>
<p>这一章节的目的是概述各大部分游戏事件运作的时刻，其中性质的详细描述见后文</p>
</blockquote>
<p>在 1.2 里，存在以下几个游戏阶段为抽象的阶段，并未明确声明在其中会发生什么事件。它们是：</p>
<ul>
<li>计划刻 TT</li>
<li>方块事件 BE</li>
<li>方块实体 TE</li>
<li>玩家操作 NU</li>
</ul>
<p>下面列一下大部分与之相关的游戏事件</p>
<ul>
<li>中继器、比较器、红石火把、侦测器的激活与熄灭：TT</li>
<li>按钮、压力板、红石灯、绊线、绊线钩的激活：瞬时；熄灭：TT</li>
<li>拉杆、红石线、铁轨、各类活版栅栏木铁门、漏斗、音符盒、投掷器发射器的激活与熄灭：瞬时</li>
<li>投掷器发射器的工作：TT</li>
<li>命令方块的运作：TT</li>
<li>树叶、流体、脚手架的更新：TT</li>
<li>重力方块判定并创建重力方块实体：TT</li>
<li>活塞推拉的开始：BE</li>
<li>移动中方块的运算：TE</li>
<li>移动中方块的到位：BE（粘性活塞受短脉冲）；TE（粘性活塞受长信号）</li>
<li>玩家移动、放置破坏方块、与方块交互：NU</li>
</ul>
<p>注：瞬时指的是可属于任意阶段，触发即运算，且触发与运算之间无法插入其他操作</p>
<h2 id="实例-自加载型区块加载器伪和平"><a class="header-anchor" href="#实例-自加载型区块加载器伪和平"></a>实例 自加载型区块加载器伪和平</h2>
<p>对于基于在卸载后能加载回自身的区块加载器的伪和平，在重加载时是否存在 1gt 的刷怪空档期是至关重要的，因为这直接与伪和平是否可用 100% 阻止生物刷新相关。完美的伪和平装置是不存在可刷怪空档期的</p>
<p>让我们分析一下基于活塞区块加载器的伪和平：</p>
<p>活塞区块加载器，利用了方块事件可以加载区块的原理，通过在每个gt利用活塞计划方块事件来确保自动保存后能加载回自身区块。</p>
<p><img data-src="/zh-CN/2019/deeply-dissecting-minecraft_1/BELoader1.png" alt="活塞加载器伪和平1">
备注：此活塞加载器并非完美设计，但足以应用于本实例分析</p>
<p>这个方案是可以 100% 阻止生物刷新的，也就是不存在 1gt 的刷怪间隔。微观时序分析很简单。先列一下相关的阶段：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>阶段</th>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>方块事件</td>
<td>Block Event</td>
<td>BE</td>
</tr>
<tr>
<td>9</td>
<td>刷怪</td>
<td>Spawning</td>
<td>S</td>
</tr>
<tr>
<td>10</td>
<td>区块卸载</td>
<td>Chunk Unload</td>
<td>CU</td>
</tr>
</tbody>
</table>
<p>可看到，在自动保存等引发的区块卸载之后，下一次进行刷怪前，游戏执行了方块事件相关的运算，并在此处加载回了存怪的区块，让怪物容量超过上限，阻止下一次进行刷怪时的生物刷新。因此，这是一个完美的伪和平</p>
<hr>
<p>如果出于某些原因，活塞区块加载器与存怪装置不在同一个区块，需要使用漏斗加载存怪区块，如下图所示。这样的话这种伪和平装置是否还是完美的？</p>
<p><img data-src="/zh-CN/2019/deeply-dissecting-minecraft_1/BELoader2.png" alt="活塞加载器伪和平2"></p>
<p>相关的阶段：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>阶段</th>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>方块事件</td>
<td>Block Event</td>
<td>BE</td>
</tr>
<tr>
<td>7</td>
<td>方块实体</td>
<td>Tile Entity</td>
<td>TE</td>
</tr>
<tr>
<td>9</td>
<td>刷怪</td>
<td>Spawning</td>
<td>S</td>
</tr>
<tr>
<td>10</td>
<td>区块卸载</td>
<td>Chunk Unload</td>
<td>CU</td>
</tr>
</tbody>
</table>
<p>让我们看一下这个设计的区块被卸载时的微观时序</p>
<table>
<thead>
<tr>
<th>GameTick</th>
<th>阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>S</td>
<td>伪和平开启，不刷怪</td>
</tr>
<tr>
<td>N</td>
<td>CU</td>
<td>伪和平装置的区块被卸载</td>
</tr>
<tr>
<td>N + 1</td>
<td>BE</td>
<td>活塞加载器区块加载，漏斗A被加载并立刻被添加至世界参与运算的TE列表</td>
</tr>
<tr>
<td>N + 1</td>
<td>TE</td>
<td>漏斗加载存怪装置区块</td>
</tr>
<tr>
<td>N + 1</td>
<td>S</td>
<td>刷怪阶段内怪物容量被占满，伪和平开启，不刷怪</td>
</tr>
</tbody>
</table>
<p>因此，这个伪和平设计也能保证 100% 时刻不刷怪，是个完美的伪和平</p>
<hr>
<p>假如有个小天才嫌一个漏斗太少，非得多串几个漏斗才接到存怪装置区块，那会怎么样？</p>
<p><img data-src="/zh-CN/2019/deeply-dissecting-minecraft_1/BELoader3.png" alt="活塞加载器伪和平3"></p>
<p>区块卸载在 GameTick N，活塞加载器自加载在 GameTick N+1 的  BE，三个漏斗依次加载区块使存怪区域在 GameTick N+1 的 TE 被加载？并不是这样的</p>
<p>TE 阶段有个性质：在 TE 阶段内新增的 TE 实体，并不会立即参与运算，而是会先加入一个临时的列表 <code>addedTileEntityList</code>，等到该 TE 阶段运算结束后再统一添加新 TE 实体至参与运算的 TE 列表 <code>loadedTileEntityList</code> 中，也就是说在 GameTick N 新增的 TE 实体要等到 GameTick N+1 的 TE 阶段才能进行运算</p>
<p>因此，这个小天才活塞区块加载器伪和平的微观时序是这样的：</p>
<table>
<thead>
<tr>
<th>GameTick</th>
<th>阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>S</td>
<td>伪和平开启，不刷怪</td>
</tr>
<tr>
<td>N</td>
<td>CU</td>
<td>伪和平装置的区块被卸载</td>
</tr>
<tr>
<td>N + 1</td>
<td>BE</td>
<td>活塞加载器区块加载，漏斗 A 被加载并立刻被添加至世界参与运算的TE列表</td>
</tr>
<tr>
<td>N + 1</td>
<td>TE</td>
<td>漏斗 A 加载漏斗 B 所在的区块。漏斗 B 被加载但在 TE 阶段结束时才被添加进参与运算的 TE 列表</td>
</tr>
<tr>
<td>N + 1</td>
<td>S</td>
<td>伪和平失效，<strong>刷怪</strong></td>
</tr>
<tr>
<td>N + 2</td>
<td>TE</td>
<td>漏斗 B 加载漏斗 C 所在的区块。漏斗 C 被加载但在 TE 阶段结束时才被添加进参与运算的 TE 列表</td>
</tr>
<tr>
<td>N + 2</td>
<td>S</td>
<td>伪和平失效，<strong>刷怪</strong></td>
</tr>
<tr>
<td>N + 3</td>
<td>TE</td>
<td>漏斗 C 加载存怪装置区块</td>
</tr>
<tr>
<td>N + 3</td>
<td>S</td>
<td>伪和平开启，不刷怪</td>
</tr>
</tbody>
</table>
<p>因此这个伪和平方案在每次被卸载时，足足有 2gt 的刷怪空档期，不是一个完美的伪和平方案</p>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>深度剖析MC</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析Minecraft #2 方块更新</title>
    <url>/zh-CN/2020/deeply-dissecting-minecraft_2/</url>
    <content><![CDATA[<h1 id="2-方块更新"><a class="header-anchor" href="#2-方块更新"></a>2 方块更新</h1>
<p>感谢 <a href="https://space.bilibili.com/112998430">迟昫123</a> 与 <a href="https://space.bilibili.com/397105271">qwrrdshfsghv</a> 的捉虫</p>
<h2 id="2-1-方块更新性质"><a class="header-anchor" href="#2-1-方块更新性质"></a>2.1 方块更新性质</h2>
<h3 id="2-1-1-方块更新的种类"><a class="header-anchor" href="#2-1-1-方块更新的种类"></a>2.1.1 方块更新的种类</h3>
<p>1.13 之后，方块更新分为了两种类型，分别是 <code>NeighborChanged</code> 与 <code>PostPlacement</code>，简称 NC 与 PP 更新。若要与 1.13 之前相比，可将 1.13 之前的所有方块更新都视为 NC 更新。下文将用<strong>方块更新</strong>一词指代 NC 更新，用<strong>状态更新</strong>一词指代 PP 更新</p>
<p>这两种方块更新的类型在官方的反混淆表（来自 1.14.4）中的名称分别为 neighborChanged 与 updateShape，其命名也能有助于理解上述对两类方块更新具体含义</p>
<span id="more"></span>
<h4 id="2-1-1-1-NeighborChanged"><a class="header-anchor" href="#2-1-1-1-NeighborChanged"></a>2.1.1.1 NeighborChanged</h4>
<p>NeighborChanged 更新，也即方块更新，指的是最基础的，最符合“方块更新”一次含义的更新。红石元件的状态变化、方块的放置与破坏、方块开始移动以及方块到位都可以产生方块更新。除此之外，各种杂七杂八地方块变化<strong>大多</strong>也都能产生方块更新</p>
<p>游戏里能产生方块更新的事件太多了，不便于一一列举。不过能响应方块更新的却不算多。<strong>所有</strong>能响应方块更新的事件有：</p>
<ul>
<li>活板门、栅栏门、木门、铁门更新开关状态</li>
<li>霜冰检测融化</li>
<li>活塞检测移动</li>
<li>活塞头给予活塞底座方块更新</li>
<li>红石粉、中继器、比较器、红石火把、各类铁轨、命令方块、投掷器、发射器、音符盒、红石灯、TNT更新状态</li>
<li>水、岩浆检测状态</li>
<li>灵魂沙、岩浆块添加生成气泡柱的 TT 事件</li>
<li>海绵尝试吸水</li>
</ul>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/NC%E6%9B%B4%E6%96%B0%E6%96%B9%E5%9D%97.png" alt="NC更新方块"></p>
<p>对，就这些。不过，根据日常经验来看，有不少需要方块更新的事件却不在这。不要着急，他们在 PostPlacement 更新中</p>
<p>有此可见，各类红石元件处于 bud 态时，如无信号源的伸出活塞，不点燃的 TNT 等，需要的是方块更新，才能让它们意识到状态改变而恢复到正常的状态</p>
<h4 id="2-1-1-2-PostPlacement"><a class="header-anchor" href="#2-1-1-2-PostPlacement"></a>2.1.1.2 PostPlacement</h4>
<p>PostPlacement，也即状态更新，指的是方块发生变化后导致的临近方块与之交互情况发生变化的更新。</p>
<p><strong>所有</strong>能响应状态更新的事件有：</p>
<ul>
<li>各类依附性方块（火把、雪片地毯蛋糕、各类花草作物、拉杆按钮、木门铁门、火焰等）判断依附的方块是否合法并决定是否掉落</li>
<li>连接型方块（栅栏石墙玻璃板、楼梯、箱子、红石粉绊线、地狱门、高草紫颂植物等）更新当前与相邻方块连接状态</li>
<li>中继器更新被锁状态</li>
<li>音符盒更新乐器类型</li>
<li>树叶更新离木距离</li>
<li>混凝土粉末判定是否凝固</li>
<li>水源与可含水的方块添加更新流体状态的 TT 事件</li>
<li><strong>侦测器添加发出信号的 TT 事件</strong></li>
<li>重力方块添加检测掉落的 TT 事件</li>
<li>草径、耕地添加检测是否被压的 TT 事件</li>
<li><strong>仙人掌添加状态是否合法的 TT 事件</strong></li>
<li>活珊瑚添加检测是否离水的 TT 事件</li>
</ul>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/PP%E6%9B%B4%E6%96%B0%E6%96%B9%E5%9D%97.png" alt="PP更新方块"></p>
<p>有一点值得注意，调用状态更新时是带有一个方向参数的，也就是状态更新是有着方向区别的，方向不对的状态更新在某些代码中存在特判情况下并不能影响方块的状态。比如，对于一个依附于西面方块上的浮空火把，从东南北上下放置破坏方块触发状态更新是无法让它掉落的。这一点也是 1.13+ 与 1.12- 的一个重要的区别。</p>
<h2 id="2-2-方块更新的实现"><a class="header-anchor" href="#2-2-方块更新的实现"></a>2.2 方块更新的实现</h2>
<p>先把会出现的名词列一遍：</p>
<ul>
<li>一个位置的方块（以下简称方块）受到了方块更新</li>
<li>一个方块发出了方块更新</li>
<li>一个方块发出了除 <code>&lt;方向&gt;</code> 外的方块更新</li>
<li>一个方块受到了状态更新</li>
<li>一个方块发出了状态更新</li>
</ul>
<p>注1：<code>&lt;方向&gt;</code> 为 <code>东</code> <code>南</code> <code>西</code> <code>北</code> <code>上</code> <code>下</code> 中的任意一者</p>
<p>注2：一个方块发出方块更新，也就是一个方块于其所在位置发出方块更新，或者说是一个位置发出了方块更新，由于指的都是一种事件并无歧义，都是可行的表述，可视上下文语境挑选合适者</p>
<h3 id="2-2-1-一个方块受到了方块更新"><a class="header-anchor" href="#2-2-1-一个方块受到了方块更新"></a>2.2.1 一个方块受到了方块更新</h3>
<p>一个方块受到了方块更新，将会调用位于这个方块的 <code>neighborChanged</code> 方法，并处理受到更新后的改变（见2.1.1.1 NeighborChanged）</p>
<p>具体代码见下 World 类中的 <code>neighborChanged</code> 方法</p>
<h3 id="2-2-2-一个方块发出了方块更新"><a class="header-anchor" href="#2-2-2-一个方块发出了方块更新"></a>2.2.2 一个方块发出了方块更新</h3>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E5%85%AD%E6%AF%97%E9%82%BB%E6%96%B9%E5%9D%97.png" alt="六毗邻方块"></p>
<p>当一个方块发出方块更新时，这个方块将会使其毗邻的六个方块依次受到方块更新。这里的“依次受到”的顺序为：</p>
<ol>
<li>西 -x</li>
<li>东 +x</li>
<li>下 -y</li>
<li>上 +y</li>
<li>北 -z</li>
<li>南 +z</li>
</ol>
<p>具体代码见下 World 类中的 <code>notifyNeighborsOfStateChange</code></p>
<h3 id="2-2-3-一个方块发出了除-方向-外的方块更新"><a class="header-anchor" href="#2-2-3-一个方块发出了除-方向-外的方块更新"></a>2.2.3 一个方块发出了除 &lt;方向&gt; 外的方块更新</h3>
<p>注：<code>&lt;方向&gt;</code> 为 <code>东</code> <code>南</code> <code>西</code> <code>北</code> <code>上</code> <code>下</code> 中的任意一者</p>
<p>一个方块发出了除 <code>&lt;方向&gt;</code> 外的方块更新的表现，与上 2.2.2 并无太大区别区别仅为这次发出的方块更新将会跳过指定的一个方向，也就是只更新 5 个毗邻的方块</p>
<p>这种特殊的方块更新<strong>仅</strong>于中继器/比较器/侦测器在其指向方块发出更新时使用</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E4%BA%94%E6%AF%97%E9%82%BB%E6%96%B9%E5%9D%97.png" alt="五毗邻方块"></p>
<p>具体代码见下 World 类中的 <code>notifyNeighborsOfStateExcept</code> 方法</p>
<h3 id="2-2-4-一个方块受到了状态更新"><a class="header-anchor" href="#2-2-4-一个方块受到了状态更新"></a>2.2.4 一个方块受到了状态更新</h3>
<p>一个方块受到了状态更新，将会调用位于这个方块的 <code>updatePostPlacement</code> 方法，并处理受到更新后的改变</p>
<p>具体代码见下 IBlockState 类中的 <code>updatePostPlacement</code> 方法（见 <a href="#2-1-1-2-PostPlacement">PostPlacement</a> 小节）</p>
<h3 id="2-2-5-一个方块发出了状态更新"><a class="header-anchor" href="#2-2-5-一个方块发出了状态更新"></a>2.2.5 一个方块发出了状态更新</h3>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E5%85%AD%E6%AF%97%E9%82%BB%E6%96%B9%E5%9D%97.png" alt="六毗邻方块"></p>
<p>当一个方块发出状态更新时，这个方块将会使其毗邻的六个方块依次受到状态更新。这里的“依次受到”的顺序为：</p>
<ol>
<li>西 -x</li>
<li>东 +x</li>
<li>北 -z</li>
<li>南 +z</li>
<li>下 -y</li>
<li>上 +y</li>
</ol>
<p>可以发现，PP 更新的更新顺序是 xzy 而非方块更新的 xyz。这一点是值得注意的</p>
<p>具体代码见下 Block 类中的 <code>updateNeighbors</code> 方法</p>
<h2 id="2-3-瞎扯"><a class="header-anchor" href="#2-3-瞎扯"></a>2.3 瞎扯</h2>
<p>方块与状态更新这两种更新概念非常类似容易混淆，我个人觉得可以这样理解：</p>
<ul>
<li>方块致一个方块状态改变的更新</li>
<li>PP 是因与周围方块交互，导致一个方块状态改变的更新</li>
</ul>
<p>因为方块更新的大部分是属于红石元件的相应，而状态更新更偏向于相邻方块状态变化造成的响应。不过得具体情况具体分析不能一概而论。</p>
<p>可以发现上述部分我描述方块更新的具体例子时都是列举响应方块更新的实例，没有列举产生方块更新的事件。这是因为 MC 里能产生方块更新的地方实在是太多了。</p>
<p>1.13 把方块更新拆成两类的做法有些魔幻，不知道麻将是想优化游戏还是只是想乱改改赌一赌能不能修掉 TNT 复制。不过至少对于绝大部分电路中利用到方块更新的部分是没有影响的</p>
<p>麻将代码中还有些很迷惑的地方，比如同样是气泡柱产生源，除了放下方块时均会添加尝试生成气泡的 TT 事件外，灵魂沙只在受到方块更新时添加 TT 事件，而岩浆块只在受到上方的来自水的状态更新时添加 TT 事件</p>
<h2 id="2-4-方块变化的实现"><a class="header-anchor" href="#2-4-方块变化的实现"></a>2.4 方块变化的实现</h2>
<p>MC 里绝大部分对世界中方块的修改是通过 <code>World</code> 类的 <code>setBlockState</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 来实现的。以将位置 Pos 的方块从 A 修改至 B 的流程如下：</p>
<ol>
<li>运算方块变化导致区段信息的改变</li>
<li>更新 Heightmap</li>
<li>调用 A 的 <code>onReplaced</code> 方法</li>
<li>更新天空光
5. 调用 B 的 <code>onBlockAdded</code> 方法</li>
<li>更新可能的新的方块实体</li>
<li>更新方块光</li>
<li>位于 Pos 的方块发出一次方块更新</li>
<li>若 B 能被比较器响应则更新附近的比较器</li>
<li>位于 Pos 的方块发出一次状态更新</li>
</ol>
<p>其中 8.、9.、10. 在不同类型中的方块变化里是可选跳过的，具体实现是游戏在调用 <code>setBlockState</code> 的时候会传递一个 <code>flags</code> 参数，通过设置 <code>flags</code> 不同二进制位中的 0/1 来实现对修改完方块后触发各种方式各种类型方块更新的控制，也就是说 <code>setBlockState</code> 会产生的方块更新的种类与方式有着非常多种可能，因此一一列举是不太现实的。不过，经验告诉我们：</p>
<ul>
<li>方块的人工放置与破坏、音符盒与活塞的动作会先后产生方块更新与状态更新</li>
<li>各种方块状态的改变如门的开关、栅栏的连接、中继器的激活会在其所在位置产生状态更新</li>
<li>可强充能的红石信号源元件能产生大范围的方块更新</li>
<li>等等</li>
</ul>
<h2 id="2-5-方块更新检测器-发生器"><a class="header-anchor" href="#2-5-方块更新检测器-发生器"></a>2.5 方块更新检测器 / 发生器</h2>
<p>一个被 QC 激活的 bud 态活塞，即为一个方块更新检测器，这也是最常用的方块更新检测器。当活塞底座受到方块更新时，活塞将在下一个 BE 阶段开始伸缩一次</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/bud%E6%B4%BB%E5%A1%9E.png" alt="bud活塞"></p>
<p>能响应状态更新并能多次使用的方块寥寥无几，做常用的就是侦测器了。当侦测器脸朝着的方块发出一个状态更新时，侦测器将会立即添加一个 TT 事件并在对应的 TT 阶段输出脉冲，因此侦测器是一个很棒的状态更新检测器。图里则是侦测器检测栅栏门开关的一个例子</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E4%BE%A6%E6%B5%8B%E5%99%A8.png" alt="侦测器"></p>
<p>上面就是两种十分常用的方块更新检测器，当然能检测方块更新或状态更新的方式还有很多，这里就不一一叙述了。</p>
<p>至于方块更新发生器，能同时发出方块更新+状态更新的事件有很多，如方块的放置、音符盒的点击。他们都能同时使方块更新检测器与状态更新检测器响应</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E6%94%BE%E7%BD%AE%E6%96%B9%E5%9D%97.png" alt="放置方块"></p>
<p>如果要只发出方块更新，可以使用红石元件，如中继器。中继器在调节档位时会在其指向的方块的位置发出一个方块更新</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E4%B8%AD%E7%BB%A7%E5%99%A8%E6%9B%B4%E6%96%B0.png" alt="中继器更新"></p>
<p>还有一种可行的方法是打开箱子。对于一个箱子，当玩家打开它时它会发出一个方块更新</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E6%89%93%E5%BC%80%E7%AE%B1%E5%AD%90.png" alt="打开箱子"></p>
<p>如果仅需发出状态更新，常用的方法则是开关栅栏门/活板门。当栅栏门/活板门开关时，它们仅会发出一个状态更新而无方块更新</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E6%89%93%E5%BC%80%E6%A0%85%E6%A0%8F%E9%97%A8.png" alt="打开栅栏门"></p>
<h2 id="2-6-即时更新元件"><a class="header-anchor" href="#2-6-即时更新元件"></a>2.6 即时更新元件</h2>
<p>即时更新元件，指的是那些收到方块更新后立即在当前阶段改变其状态，并发出指定类型的更新（可能没有）的元件。它们被广泛地用于信号传递以及方块更新的传导</p>
<h3 id="2-6-1-充能-激活铁轨"><a class="header-anchor" href="#2-6-1-充能-激活铁轨"></a>2.6.1 充能 / 激活铁轨</h3>
<p>当充能 / 激活铁轨（以下以充能铁轨为例）受到方块更新时，它会先检测当前位置是否合法。若不合法，则掉落，否则执行铁轨的更新</p>
<p>在铁轨的更新中，首先铁轨会通过计算临近铁轨状态来判断当前的状态是否需要改变，具体怎么判断的这里就不多解释了。如果需要更新，铁轨会依次执行位于 BlockRailPowered 类的 <code>updateState</code> 方法中的以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worldIn.setBlockState(pos, state.with(POWERED, Boolean.valueOf(flag1)), 3);</span><br><span class="line">worldIn.notifyNeighborsOfStateChange(pos.down(), this);</span><br><span class="line"></span><br><span class="line">if (state.get(SHAPE).isAscending())</span><br><span class="line">&#123;</span><br><span class="line">    worldIn.notifyNeighborsOfStateChange(pos.up(), this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是：</p>
<ol>
<li>改变方块状态，在铁轨处依次发出方块与状态更新</li>
<li>方块更新发出方块更新</li>
<li>若铁轨是倾斜放置的，则在铁轨上方一格发出方块更新</li>
</ol>
<p>不过，注意到，充能铁轨的 <code>onReplaced</code> 方法本身也有进行方块更新。对于充能铁轨而言，<code>onReplaced</code> 方法将依次执行：</p>
<ol>
<li>若铁轨是倾斜放置的，则在铁轨上方一格发出方块更新</li>
<li>在铁轨自身位置发出方块更新</li>
<li>在铁轨下方一格发出方块更新</li>
</ol>
<p>因此，合并起来，在充能铁轨状态改变时，将会依次执行这些方块更新：</p>
<ol>
<li>若铁轨是倾斜放置的，则在铁轨上方一格发出方块更新</li>
<li>在铁轨自身位置发出方块更新</li>
<li>在铁轨下方一格发出方块更新</li>
<li>在铁轨自身位置发出方块更新</li>
<li>在铁轨自身位置发出状态更新</li>
<li>在铁轨下方一格发出方块更新</li>
<li>若铁轨是倾斜放置的，则在铁轨上方一格发出方块更新</li>
</ol>
<p>别问我为什么要这么繁琐地更新，要问就问麻将</p>
<h3 id="2-6-2-红石粉"><a class="header-anchor" href="#2-6-2-红石粉"></a>2.6.2 红石粉</h3>
<p>红石粉方块几乎仅对方块更新进行响应，即使是判断自身位置是否合法也是通过方块更新进行的。对于状态更新，红石粉接受上方和四周的状态更新用来更新与相邻红石粉的被实体方块压线/连接状态</p>
<p>当红石粉受到方块更新时，它会计算不考虑自己时它能达到的信号强度，如果不同，则进行更新。红石粉将会在其位置发出方块更新，并在于其毗邻的 6 个方块的位置上发出方块更新，总共有 7 个位置将会发出方块更新。这七个位置的更新顺序并不是固定的，游戏会将这 7 个位置存入一个哈希表并导出成列表，随后逐个读取列表里的位置进行发出方块更新。至于为什么要用哈希表打乱，问麻将去¯_(ツ)_/¯</p>
<h3 id="2-6-3-活板-栅栏-木门、漏斗"><a class="header-anchor" href="#2-6-3-活板-栅栏-木门、漏斗"></a>2.6.3 活板/栅栏/木门、漏斗</h3>
<p>各类活板门、栅栏门、木门铁门，以及漏斗的机制，算是比较简单的。它们在由于玩家操作或者红石信号导致开关状态的改变时，会在所在位置<strong>立即</strong>触发一个状态更新，仅此而已。因此，它们并不能用来更新 bud 态的元件</p>
<h3 id="2-6-4-音符盒"><a class="header-anchor" href="#2-6-4-音符盒"></a>2.6.4 音符盒</h3>
<p>音符盒与各类门很相似，但却有不少不同。</p>
<ul>
<li>音符盒在被玩家右键调音时，或者在被红石信号激活/取消激活时，会<strong>立即</strong>在所在的位置先后触发方块更新与状态更新。这也是音符盒可以用于更新 bud 态的元件的原因</li>
<li>音符盒在被玩家左键发音时，不会触发方块更新</li>
</ul>
<p>音符盒进行上述三类操作（调音 / 发音 / 激活）后，会在可以发音时，即上方是空气方块时，计划一个 BlockEvent ，并在 BE 阶段发出对应的声音并生成音符粒子</p>
<h3 id="2-6-5-依附性方块"><a class="header-anchor" href="#2-6-5-依附性方块"></a>2.6.5 依附性方块</h3>
<p>绝大部分依附性方块，如火把、花草、红石粉、耕地上的作物，在受到来自其附着方块位置的 PP 或方块更新时，都会立即破坏并依据情况掉落。因此它们也可称为即时更新的元件</p>
<p>之所以说是绝大部分，是因为存在某些如紫颂花、仙人掌等的依附性方块是在 TileTick 阶段进行掉落的，这也给强制催熟的可能性打下了基础</p>
<h3 id="2-6-6-半即时更新元件"><a class="header-anchor" href="#2-6-6-半即时更新元件"></a>2.6.6 半即时更新元件</h3>
<p>这类元件仅在激活/触发时为即时更新，但在取消激活时是在 TileTick 阶段进行运算的。它们有：</p>
<ul>
<li>按钮</li>
<li>压力板</li>
<li>绊线</li>
<li>绊线钩</li>
<li>红石灯</li>
</ul>
<h2 id="2-7-更新抑制"><a class="header-anchor" href="#2-7-更新抑制"></a>2.7 更新抑制</h2>
<p>一个方块发出方块的更新可以导致了另一个方块的更新，如果此时另一个方块也发出了方块更新，那么说不定可以再更新一个新的方块。如果有无限的方块排一排等着更新，如果给一它们一个方块更新，它们能一口气全部更新完吗？虽然实际上应该是可以的，但是基于 MC 的实现机制，答案是：不行</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E5%A4%A7%E9%9D%A2%E7%A7%AF%E7%9A%84bud%E9%93%81%E8%BD%A8.png" alt="大面积的bud铁轨"></p>
<p>在处理方块更新时，游戏内是简单地通过递归处理的，而最大的递归次数，是由 java 虚拟机的栈空间所决定的。栈空间不像堆空间，在默认条件下容量不大，这导致了当出现递归更新过量方块时栈空间将会耗尽，导致 java 抛出了栈溢出的异常（实际上栈溢出后可能抛出的是其他类型的异常，这里为了方便表述称其为栈溢出异常）</p>
<p>异常可是个很危险的东西。出现异常时，程序将会一直忽略之后的操作，一直往外跳出，直到异常被捕获。在大部分 MC 流程中，异常将会在最底层的 MinecraftServer 类的 <code>run</code> 方法中被捕获，随后游戏将生成崩溃报告并强行关闭服务器，也就是崩服，服务器崩溃了</p>
<p>不过，如果一个异常是在玩家操作阶段被玩家的动作触发，则这个异常将会在 Util 类的 <code>runTask</code> 方法中被捕获并作为一个 Fatal 输出，而非被 MinecraftServer 捕获，也就是说玩家动作引发的异常是不会引起服务端崩溃的。作为异常之一的栈溢出，如果是由玩家操作引起的，比如玩家打掉了一个接连插了几千个旗子的方块，或者玩家在大面积的 bud 态充能铁轨旁边放置了方块，虽会导致栈溢出，但都<strong>不会</strong>导致游戏崩溃</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E6%89%8B%E6%94%BE%E6%96%B9%E5%9D%97.png" alt="手放方块"></p>
<p>由于栈溢出可以跳过在异常捕获前的所有运算，因此可以用此来跳过一些运算以实现普通游戏里不可能的操作，如跳过对特定方块的更新，从而制造各种悬空木门、贴在告示牌背面的告示牌、切片的地狱门；也可以跳过对玩家物品栏物品的操作，在不消耗工具耐久或者不消耗手中物品的情况下破坏/放置方块。这一类操作，我们统称为为<strong>更新抑制</strong></p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_2/%E6%9B%B4%E6%96%B0%E6%8A%91%E5%88%B6.png" alt="更新抑制"></p>
<p>关于更新抑制与可协助产生更新抑制的更新抑制器，Xcom6000 制作过一个非常详细的讲解视频，红石科技搬运组已在 bilibili 将其翻译成熟肉。推荐大家去观看学习。<a href="https://www.bilibili.com/video/av83979198">传送门</a></p>
<h3 id="2-7-1-方块更新与深度优先搜索"><a class="header-anchor" href="#2-7-1-方块更新与深度优先搜索"></a>2.7.1 方块更新与深度优先搜索</h3>
<p>方块受到更新，方块改变状态，方块发出更新，依次更新毗邻方块，新方块受到更新……这一层层递归的过程，本质上正是一个深度优先搜索，也就是 DFS（Depth First Search）。每当一个 bud 充能铁轨受到更新了，将会按照其发出方块更新的顺序，以及方块更新的更新顺序，往新的 bud 铁轨方块递归下去</p>
<p>关于深度优先搜索，或者 DFS，网络上相关的资料一搜一大把，这里就不再重复阐述了</p>
<p>使用更新抑制来阻断方块更新的一个难点，即是如何控制更新顺序，使<strong>方块更新在传递至需阻止更新的方块前就进入更新抑制器</strong>触发栈溢出。现在，方块更新传递的机制我们已探明（DFS），方块更新顺序我们也已清楚（方块/状态更新的更新顺序），只要了解清楚 DFS 的机制确定好更新顺序方向，就可以轻松的计算出来了</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>net/minecraft/world/World.java:226 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>深度剖析MC</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析Minecraft #3.4 计划刻元件</title>
    <url>/zh-CN/2020/deeply-dissecting-minecraft_3.4/</url>
    <content><![CDATA[<h1 id="3-4-计划刻元件"><a class="header-anchor" href="#3-4-计划刻元件"></a>3.4 计划刻元件</h1>
<p>阅前必读：</p>
<p>《<a href="/zh-CN/2020/deeply-dissecting-minecraft_2/" title="深度剖析Minecraft #2 方块更新">深度剖析Minecraft #2 方块更新</a>》</p>
<p>《<a href="/zh-CN/2020/deeply-dissecting-minecraft_3/" title="深度剖析Minecraft #3 计划刻">深度剖析Minecraft #3 计划刻</a>》</p>
<h2 id="3-4-1-红石二极管"><a class="header-anchor" href="#3-4-1-红石二极管"></a>3.4.1 红石二极管</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>net.minecraft.block.BlockRedstoneDiode</td>
</tr>
<tr>
<td>基类</td>
<td>net.minecraft.block.BlockHorizontal</td>
</tr>
<tr>
<td>延迟</td>
<td>非定值</td>
</tr>
<tr>
<td>优先级</td>
<td>非定值</td>
</tr>
<tr>
<td>位置需求</td>
<td>其下方依附着的方块上表面完整</td>
</tr>
<tr>
<td>受方块更新时</td>
<td>判断掉落，更新信号</td>
</tr>
<tr>
<td>受状态更新时</td>
<td>不响应</td>
</tr>
</tbody>
</table>
<p>这是一个抽象类，是红石中继器以及红石比较器的基类，也就是说中继器跟比较器的本质是一个二极管，有许多的机制是完全相同的</p>
<h3 id="3-4-1-1-方块状态"><a class="header-anchor" href="#3-4-1-1-方块状态"></a>3.4.1.1 方块状态</h3>
<p>作为一个可水平旋转的方块，二极管拥有一个 <code>facing</code> 标签表示其水平指向。除此之外二极管还具有以下标签：</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>取值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>powered</td>
<td>false, true</td>
<td>其当前的亮起状态。我们称该标签为假时二极管熄灭，该标签为真时二极管亮起</td>
</tr>
</tbody>
</table>
<h3 id="3-4-1-2-响应方块更新"><a class="header-anchor" href="#3-4-1-2-响应方块更新"></a>3.4.1.2 响应方块更新</h3>
<p>当二极管受到方块更新时，它会首先检测其所处位置是否满足位置需求，若不满足则掉落为物品，并先在所在位置发出方块更新，再在其毗邻 6 方块的位置发出方块更新（顺序：-y, +y, -z, +z, -x, +x <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>）；若合法，则开始检测信号变化 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。具体的检测信号变化的方法见 <a href="#3-4-1-%E7%BA%A2%E7%9F%B3%E4%BA%8C%E6%9E%81%E7%AE%A1">红石中继器</a> 以及 <a href="#3-4-2-%E7%BA%A2%E7%9F%B3%E4%B8%AD%E7%BB%A7%E5%99%A8">红石比较器</a></p>
<h3 id="3-4-1-3-发出更新"><a class="header-anchor" href="#3-4-1-3-发出更新"></a>3.4.1.3 发出更新</h3>
<p>当二极管的状态发生变化的时候，它会先给其指向方块一个方块更新（下图黄色玻璃），再于其指向方块的位置处（下图黄色玻璃）发出一个除其指向方向反方向的方块更新。图中所有的染色玻璃也即是所有的<strong>受到</strong>方块更新的方块的位置</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/diode_update_range.png" alt="二极管更新范围示意"></p>
<p>具体的方法为 <code>net.minecraft.block.BlockRedstoneDiode#notifyNeighbors</code></p>
<p>这一部分的调用之处是在 <code>onBlockAdded</code> 以及 <code>onReplaced</code> 中，因此只要涉及到二极管的方块状态的变化，均可以让这个二极管发出上述更新</p>
<h2 id="3-4-2-红石中继器"><a class="header-anchor" href="#3-4-2-红石中继器"></a>3.4.2 红石中继器</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>net.minecraft.block.BlockRedstoneRepeater</td>
</tr>
<tr>
<td>基类</td>
<td>net.minecraft.block.BlockRedstoneDiode</td>
</tr>
<tr>
<td>延迟</td>
<td>非定值</td>
</tr>
<tr>
<td>优先级</td>
<td>非定值</td>
</tr>
<tr>
<td>位置需求</td>
<td>同 <a href="#3-4-1-%E7%BA%A2%E7%9F%B3%E4%BA%8C%E6%9E%81%E7%AE%A1">红石二极管</a></td>
</tr>
<tr>
<td>受方块更新时</td>
<td>同 <a href="#3-4-1-%E7%BA%A2%E7%9F%B3%E4%BA%8C%E6%9E%81%E7%AE%A1">红石二极管</a></td>
</tr>
<tr>
<td>受状态更新时</td>
<td>更新自身被锁的状态</td>
</tr>
</tbody>
</table>
<h3 id="3-4-2-1-方块状态"><a class="header-anchor" href="#3-4-2-1-方块状态"></a>3.4.2.1 方块状态</h3>
<p>红石中继器（简称中继器）在红石二极管的基础上，新增了两个方块标签：</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>取值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>delay</td>
<td>1, 2, 3, 4</td>
<td>储存中继器的延迟。计划刻事件的延迟将为 <code>delay</code> * 2</td>
</tr>
<tr>
<td>locked</td>
<td>false, true</td>
<td>储存中继器是否被锁</td>
</tr>
</tbody>
</table>
<h3 id="3-4-2-2-检测信号变化"><a class="header-anchor" href="#3-4-2-2-检测信号变化"></a>3.4.2.2 检测信号变化</h3>
<p>中继器接受来自其输入端方块的弱充能信号，与其当前的 <code>powered</code> 标签进行对比，若发现其状态需要改变，则添加一个计划刻事件用于延迟更新状态。计划刻事件的延迟如上所述，优先级如下：</p>
<ul>
<li>若其指向方块为红石二极管，且红石二极管的朝向非反向，则优先级为 -3</li>
<li>若中继器的原 <code>powered</code> 标签为假，也即中继器准备熄灭，则优先级为 -2</li>
<li>否则优先级为 -1</li>
</ul>
<h3 id="3-4-2-3-计划刻事件执行"><a class="header-anchor" href="#3-4-2-3-计划刻事件执行"></a>3.4.2.3 计划刻事件执行</h3>
<p>如果中继器目前被锁住，则跳过该计划刻事件的执行。由于计划刻事件并不储存该事件的实际功能，中继器需要再次计算其输入端方块的弱充能信号，并与其当前的 <code>powered</code> 标签作比较：</p>
<ul>
<li>若当前状态为亮起且输入端无信号，则改为熄灭状态</li>
<li>若的前状态为熄灭，则改为亮起状态，再判断输入端是否有信号，若无信号则添加一个延迟为其自身的延迟，优先级为 -1 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 的计划刻事件用于熄灭。也就是说，即便在执行计划刻事件的时候输入信号已经消失，中继器也依然会亮起，这也是中继器可响应并输出任意短的正脉冲的原理</li>
</ul>
<p>上述过程中，改变其亮起状态时，在其所在位置发出的更新仅含状态更新。中继器在其前方发出的大范围方块更新见 <a href="#3-4-1-%E7%BA%A2%E7%9F%B3%E4%BA%8C%E6%9E%81%E7%AE%A1">红石二极管</a> 的发出更新小节</p>
<h3 id="3-4-2-4-受状态更新时"><a class="header-anchor" href="#3-4-2-4-受状态更新时"></a>3.4.2.4 受状态更新时</h3>
<p>当中继器受到状态更新时，若更新方向为水平方向，且方向为垂直于中继器的指向方向，则更新自身的被锁状态。中继器当且仅当被一个二极管指向侧面的时候会被锁住</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/repeater_lock.gif" alt="中继器响应状态更新"></p>
<h3 id="实例"><a class="header-anchor" href="#实例"></a>实例</h3>
<h4 id="与-4gt-时钟交互"><a class="header-anchor" href="#与-4gt-时钟交互"></a>与 4gt 时钟交互</h4>
<p>当将 4gt 时钟，如对脸侦测器，的输出接至中继器链时，常常会见到下图的现象：中继器链大部分都在 4gt 时钟下闪烁，可是最末端的中继器却处于常量状态</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/4gtrepeater1.gif" alt="与 4gt 时钟交互"></p>
<p>这是因为中继器添加事件的优先级所导致的。</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/4gtrepeater2.gif" alt="4gtrepeater2"></p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/4gtrepeater3.gif" alt="4gtrepeater3"></p>
<h2 id="3-4-3-红石比较器"><a class="header-anchor" href="#3-4-3-红石比较器"></a>3.4.3 红石比较器</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>net.minecraft.block.BlockRedstoneComparator</td>
</tr>
<tr>
<td>基类</td>
<td>net.minecraft.block.BlockRedstoneDiode</td>
</tr>
<tr>
<td>延迟</td>
<td>2</td>
</tr>
<tr>
<td>优先级</td>
<td>非定值</td>
</tr>
<tr>
<td>位置需求</td>
<td>同 <a href="#3-4-1-%E7%BA%A2%E7%9F%B3%E4%BA%8C%E6%9E%81%E7%AE%A1">红石二极管</a></td>
</tr>
<tr>
<td>受方块更新时</td>
<td>同 <a href="#3-4-1-%E7%BA%A2%E7%9F%B3%E4%BA%8C%E6%9E%81%E7%AE%A1">红石二极管</a></td>
</tr>
<tr>
<td>受状态更新时</td>
<td>不响应</td>
</tr>
</tbody>
</table>
<h3 id="3-4-3-1-方块状态"><a class="header-anchor" href="#3-4-3-1-方块状态"></a>3.4.3.1 方块状态</h3>
<p>红石比较器（简称比较器）在红石二极管的基础上，新增了一个方块标签：</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>取值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>mode</td>
<td>compare, subtract</td>
<td>储存着比较器当前的模式（比较模式、减法模式）</td>
</tr>
</tbody>
</table>
<p>对于当前比较器的输出信号的储存，可能是因为一些历史遗留问题（1.13 以前的方块附加值储存能力不足），是储存于比较器方块实体之中的。也就是说，比较器其实是一个含有方块实体的方块。不过由于该方块实体并不是常运算的方块实体 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，因此并不会带来额外的卡顿</p>
<h3 id="3-4-3-2-信号强度计算"><a class="header-anchor" href="#3-4-3-2-信号强度计算"></a>3.4.3.2 信号强度计算</h3>
<blockquote>
<p>net.minecraft.block.BlockRedstoneComparator#calculateInputStrength</p>
</blockquote>
<p>首先，需要计算输入端的信号强度</p>
<p>令输入端，即比较器后方一格处的方块为 A，比较器后方二格处的方块为 B</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/comparetor_input.png" alt="比较器输入信号"></p>
<ol>
<li>维护一个取值为 0 ~ 15 的整数 $n$ 作为比较器待确定的输入的信号强度</li>
<li>计算方块 A 的弱充能信号强度（与中继器相同），将 $n$ 设为该信号强度</li>
<li>判断方块 A 是否可输出比较器信号</li>
</ol>
<ul>
<li>如果是，则将 $n$ 设为 A 的比较器输出值。如比较器直接读取毗邻容器</li>
<li>如果不是，若 $n &lt; 15$ 且方块 A 为实体方块 <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，则进行尝试使用 B 处可能的容器输出来覆盖当前的输入强度：
<ol>
<li>如果方块 B 可输出比较器信号，则将 $n$ 设方块 B 的比较器输出值</li>
<li>如果方块 B 为空气，则查找位于方块 B 处的可能依附于方块 A 的一个物品展示框实体，若找到，则将 $n$ 设置为物品展示架的角度</li>
</ol>
</li>
</ul>
<ol start="4">
<li>$n$ 即为比较器的输入信号强度</li>
</ol>
<p>随后，比较器会计算其来自侧面的输入的最大值。比较器<strong>仅</strong>会接受以下三种形式的输入：</p>
<ul>
<li>毗邻的红石块</li>
<li>毗邻的红石粉</li>
<li>毗邻的指向比较器的强充能元件</li>
</ul>
<p>下图是一些常见的给予比较器侧面输入信号的方法</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/comparetor_side_input.png" alt="比较器侧面输入"></p>
<p>不过，强充能元件并非只有中继器、比较器。当比较器前方有二极管时，比较器可响应侦测器的侧方输入。如果使用指令等方式得到了浮空方块，你甚至可以使用拉杆、按钮等元件进行输入：</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/comparetor_side_input_sp.png" alt="comparetor_side_input_sp"></p>
<p>现在，我们已经知道比较器的后方输入以及侧面输入的信号强度了，现在只需要根据其所处模式（比较模式/减法模式）再次计算，即可得出比较器的输出信号了：</p>
<ul>
<li>比较模式：输出信号 = 后方输入（大小比较的相关逻辑并不在此处）</li>
<li>减法模式：输出信号 = max(0, 后方输入 - 侧面输入)</li>
</ul>
<p>之后，比较器就可以判断是否应该输出信号了。这部分的实现很简单，直接结合代码说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldBePowered</span><span class="params">(World worldIn, BlockPos pos, IBlockState state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.calculateInputStrength(worldIn, pos, state);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">15</span>)  <span class="comment">// 输入信号强度大于15</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)  <span class="comment">// 输入信号强度为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="built_in">this</span>.getPowerOnSides(worldIn, pos, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也是比较模式大小相关逻辑的实现之处</p>
<h3 id="3-4-3-3-检测信号变化"><a class="header-anchor" href="#3-4-3-3-检测信号变化"></a>3.4.3.3 检测信号变化</h3>
<p>与中继器类似，比较器会计算其当前应该输出的信号强度，并与当前自身储存着的信号强度作对比。如果输出的信号强度有改变，或者其亮起状态有变化，则添加一个计划刻事件，优先级如下：</p>
<ul>
<li>若其指向方块为红石二极管，且红石二极管的朝向非反向，则优先级为 -1</li>
<li>其他情况，优先级为 0</li>
</ul>
<h3 id="3-4-3-4-计划刻事件执行"><a class="header-anchor" href="#3-4-3-4-计划刻事件执行"></a>3.4.3.4 计划刻事件执行</h3>
<p>与中继器类似，由于计划刻事件并不储存该事件的实际功能，比较器需要再次计算其当前应该输出的信号强度，并与当前自身储存着的信号强度作对比。若两者不同，或者其亮起状态有变化，则更新当前的亮起状态，并<a href="#3-4-1-3-%E5%8F%91%E5%87%BA%E6%9B%B4%E6%96%B0">发出更新</a>。可以注意到，比较器并非同中继器一样，当原状态是熄灭的时候，无论如何都会点亮。<strong>如果比较器的计划刻执行时输入信号已消失，比较器是不会输出的</strong></p>
<p>注意到对于任意一个红石二极管，当其方块状态发生变化时也会发出一次更新，因此若比较器在上述步骤中改变了亮起状态时，它会发出更新两次 <s>&lt;3 mojang</s></p>
<h3 id="实例-2"><a class="header-anchor" href="#实例-2"></a>实例</h3>
<h4 id="响应计划刻元件的-2gt-脉冲"><a class="header-anchor" href="#响应计划刻元件的-2gt-脉冲"></a>响应计划刻元件的 2gt 脉冲</h4>
<p>下面以典型的侦测器为例。正常情况下，侦测器脉冲是无法激活比较器的，如下面这个例子</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/observer_comparator1.gif" alt="侦测器尝试激活比较器"></p>
<p>时序分析：</p>
<table>
<thead>
<tr>
<th>游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>TT.0.侦测器</td>
<td>侦测器点亮。侦测器添加位于 gt 2 的计划刻事件用于熄灭，优先级为 0（关于侦测器的执行计划刻事件时的逻辑，见 <a href="#3-4-5-%E4%BE%A6%E6%B5%8B%E5%99%A8">侦测器</a>）</td>
</tr>
<tr>
<td>0</td>
<td>TT.0.侦测器</td>
<td>侦测器发出方块更新。比较器受到方块更新，发现可输出信号，添加位于 gt 2 的计划刻事件，优先级为 0</td>
</tr>
<tr>
<td>2</td>
<td>TT.0.侦测器</td>
<td>侦测器熄灭</td>
</tr>
<tr>
<td>2</td>
<td>TT.0.比较器</td>
<td>比较器判断目前输出信号强度（0）与应当输出的信号强度（0），无变化，不执行任何操作</td>
</tr>
</tbody>
</table>
<p>可见，比较器的计划刻事件执行的时候输入端信号已经消失，这导致了比较器不响应侦测器的脉冲</p>
<hr>
<p>若想要使用侦测器来激活比较器，有两种方法</p>
<p><strong>1. 提升比较器的优先级</strong></p>
<p>观察时序分析表，容易发现如果让 gt 2 中比较器的事件先于侦测器执行，则可以让侦测器执行计划刻事件时侦测器仍处于激活状态。一种可行的方法就是提升比较器的优先级，更准确地说，提升比较器添加用于亮起的计划刻事件的优先级。我们可以通过在比较器前方添加中继器来实现</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/observer_comparator2.gif" alt="侦测器尝试激活比较器"></p>
<p>时序分析：</p>
<table>
<thead>
<tr>
<th>游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>TT.0.侦测器</td>
<td>侦测器 A 点亮，添加位于 gt 2 的计划刻事件。侦测器更新比较器，比较器发现自身可亮起，添加位于 gt 2 的计划事件</td>
</tr>
<tr>
<td>2</td>
<td>TT.<strong>-1</strong>.比较器</td>
<td>比较器判断目前输出信号强度（0）与应当输出的信号强度（15），不相等。<strong>比较器亮起</strong></td>
</tr>
<tr>
<td>2</td>
<td>TT.0.侦测器</td>
<td>侦测器熄灭</td>
</tr>
</tbody>
</table>
<p><strong>2. 延长等优先级的 2gt 脉冲</strong></p>
<p>为了让比较器在执行其计划刻事件的时候输入端仍有信号，除了提升比较器的计划刻事件的优先级外，是否还有方法？更新比较器，让比较器添加计划刻事件的那个侦测器肯定不能起到作用了，那么是否可以额外添加一个侦测器，让第二个侦测器在比较器事件执行完毕之后再熄灭？答案是可以，方案如下：</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/double_observer_comparator.gif" alt="双侦测器激活比较器"></p>
<p>时序分析如下：</p>
<table>
<thead>
<tr>
<th>游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>TT.0.侦测器 A</td>
<td>侦测器 A 点亮，添加位于 gt 2 的计划刻事件。侦测器更新比较器，比较器发现自身可亮起，添加位于 gt 2 的计划事件</td>
</tr>
<tr>
<td>0</td>
<td>TT.0.侦测器 B</td>
<td>侦测器 A 点亮，添加位于 gt 2 的计划刻事件。侦测器更新比较器，比较器尝试添加位于 gt 2 的计划事件，不过由于计划刻队列中已有该事件，忽略操作</td>
</tr>
<tr>
<td>2</td>
<td>TT.0.侦测器 A</td>
<td>侦测器 A 熄灭</td>
</tr>
<tr>
<td>2</td>
<td>TT.0.比较器</td>
<td>虽然侦测器 A 熄灭了，但是侦测器 B 仍处于亮起状态。比较器判断目前输出信号强度（0）与应当输出的信号强度（15），不相等。<strong>比较器亮起</strong></td>
</tr>
<tr>
<td>2</td>
<td>TT.0.侦测器 B</td>
<td>侦测器 B 熄灭</td>
</tr>
</tbody>
</table>
<p>值得注意的是，该方案的铁轨不可用 2gt 的计划刻元件脉冲去激活，具体原因与侦测器的实现有关</p>
<h4 id="使用-0gt-信号激活比较器"><a class="header-anchor" href="#使用-0gt-信号激活比较器"></a>使用 0gt 信号激活比较器</h4>
<p>通过上述例子我们可发现，若想要激活一个比较器，仅需要在比较器检查输入端是否有信号的时候，也就是以下两个时刻：</p>
<ul>
<li>添加计划刻事件时</li>
<li>执行计划刻事件时</li>
</ul>
<p>让输入端存在信号就行了。这意味着，激活比较器的信号并不需要是一个连续的信号，我们只需要用两次脉冲分别覆盖上述两个时刻，就能让比较器点亮。这两个脉冲的时长可以任意短，可以短到 0gt 时长，只要覆盖到了上述两个时刻就行了</p>
<p>对于上述的第一个时刻“添加计划刻事件时”，可在任意时刻实现；对于第二个时刻“执行计划刻事件时”，需理清楚比较器的计划刻事件的执行时间点</p>
<p>下图是一个使用两次 0gt 信号激活比较器的例子</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/0t_x_comparator.gif" alt="0gt脉冲激活比较器"></p>
<p>时序分析：</p>
<p>该装置中含有两个 0gt 脉冲发生器，脉冲的持续时间为 TT.-1 ~ BE，可覆盖正常优先级的比较器的计划刻事件时刻 TT.0</p>
<table>
<thead>
<tr>
<th>游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>TT.-1.上中继器 A</td>
<td>中继器 A 亮起，充能铁块激活红石粉，更新比较器。比较器添加位于 gt 2 的计划刻事件</td>
</tr>
<tr>
<td>0</td>
<td>BE</td>
<td>活塞 A 推出，红石粉熄灭</td>
</tr>
<tr>
<td>2</td>
<td>TT.-1.上中继器 B</td>
<td>中继器 B 亮起，充能铁块激活红石粉</td>
</tr>
<tr>
<td>2</td>
<td>TT.0.比较器</td>
<td>比较器亮起，信号强度为 14（信号强度源自中继器 B）</td>
</tr>
<tr>
<td>2</td>
<td>BE</td>
<td>活塞 B 推出，红石粉熄灭。红石粉更新比较器，比较器添加位于 gt 4 的计划刻事件</td>
</tr>
<tr>
<td>4</td>
<td>TT</td>
<td>比较器熄灭</td>
</tr>
</tbody>
</table>
<p>如果将比较器输入信号是否存在视作 0 1，画出波形图的话，是这样子的</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/comparetor_0t_wave.png" alt="波形图"></p>
<p>类似的，如果我们每 2gt 都发出一次上述 0gt 脉冲的话，比较器就能一直保持常亮状态。下方是上述例子示意装置的一个简单扩展，如果有必要的话甚至可以让比较器的输出信号强度也保持不变</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/0t_clock_comparator.gif" alt="0gt脉冲常激活比较器"></p>
<h4 id="无延迟比较器"><a class="header-anchor" href="#无延迟比较器"></a>无延迟比较器</h4>
<p>在传统的使用比较器传输模拟信号的线路中，比较器逐个亮起，依次往前传递信号，传输速度较慢，如下图</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/not_instant_comparator.gif" alt="有延迟比较器"></p>
<p>让我们分析一下上图，为什么这个比较器链传输信号如此之慢。上图中，比较器 B 需要等待比较器 A 亮起后才可亮起；比较器 C 需要等待比较器 B 亮起后才可亮起；比较器 D 需要等待比较器 C 亮起后才可亮起……每次等待，都耗费了 2gt 的时间进行延迟</p>
<p>这些一个个的 2gt 延迟真的有必要存在吗？答案是不。我们可以仅在一个 gt 的计划刻阶段中就完成所有比较器的点亮，这就是无延迟比较器</p>
<p>下图是一个简单的无延迟比较器的例子</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/instant_comparator.gif" alt="无延迟比较器"></p>
<p>无延迟比较器的基本思路是，通过使用额外的计划刻元件生成的短脉冲，主动使所有比较器在<strong>同一个 gt 依次</strong>执行自己用于亮起的计划刻事件，使得比较器链在瞬间同时点亮。这种诱导比较器在指定时刻添加计划刻事件的脉冲，我们称之为<strong>诱导脉冲</strong>。</p>
<p>上述操作将长距离传输信号的时间复杂度从 $\Theta(n)$ 降至了 $\Theta(1)$，从线性降为常数级，仿佛用于传输信号的比较器都是 0 延迟，因此我们称之为无延迟比较器</p>
<p>下面是上图中的无延迟比较器的亮起操作的时序分析。熄灭/信号改变的时序分析同理：</p>
<table>
<thead>
<tr>
<th>游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NU</td>
<td>拉杆拉下</td>
</tr>
<tr>
<td>2</td>
<td>TT</td>
<td>比较器 1 亮起。侦测器亮起，中继器<strong>从近到远依次</strong>添加位于 gt 4 的计划刻事件</td>
</tr>
<tr>
<td>4</td>
<td>TT.-1.中继器 A</td>
<td>亮起，更新比较器 A，比较器 A 添加位于 gt 6 的计划刻事件</td>
</tr>
<tr>
<td>4</td>
<td>TT.-1.中继器 B</td>
<td>亮起，更新比较器 B，比较器 B 添加位于 gt 6 的计划刻事件</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>4</td>
<td>TT.-1.中继器 F</td>
<td>亮起，更新比较器 F，比较器 F 添加位于 gt 6 的计划刻事件</td>
</tr>
<tr>
<td>4</td>
<td>TT.0</td>
<td>比较器 2 亮起。侦测器熄灭</td>
</tr>
<tr>
<td>6</td>
<td>TT.-1</td>
<td>中继器 A ~ F 依次熄灭</td>
</tr>
<tr>
<td>6</td>
<td>TT.0.比较器 A</td>
<td>比较器 A 发现其输入端有来自比较器 2 的信号，亮起</td>
</tr>
<tr>
<td>6</td>
<td>TT.0.比较器 B</td>
<td>比较器 B 发现其输入端有来自比较器 A 的信号，亮起</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>6</td>
<td>TT.0.比较器 F</td>
<td>比较器 F 发现其输入端有来自比较器 E 的信号，亮起</td>
</tr>
</tbody>
</table>
<p>不过，上述无延迟比较器有一个缺点，就是在输入信号强度为 15 的情况下改变信号强度时不能维持无延迟。这是因为当输入的信号强度是 15 时，比较器链中都储存着强度为 15 的信号，而侧方位中继器发出的脉冲信号强度也是 15，两者大小相等，导致了诱导脉冲无法诱使比较器添加计划刻事件。如下图所示：</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/half_instant_comparator.gif" alt="于输入15信号的下降沿失效"></p>
<p>对此的解决方法也并不困难。我们需要的是诱使比较器添加计划刻事件，只要按顺序添加了就可以，至于比较器是因为什么原因而添加计划刻事件，我们并不关心</p>
<p>当比较器输出信号是 15 的时候，还有什么方法能诱使比较器添加计划刻事件呢？在减法模式下向比较器侧面输入脉冲！这样子，比较器会发现其输出信号需要减去其侧面输入，从而添加计划刻事件</p>
<p>在向其侧面输入脉冲的条件下，向其背面输入端的脉冲也不可去掉，如下图所示</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/instant_comparator_sideway_pulse.png" alt="侧面输入脉冲"></p>
<p>设比较器的原信号强度为 $n$</p>
<ul>
<li>若 $n &gt; 0$，则来自比较器侧面的脉冲可让比较器输出的信号强度减小，从而诱使比较器添加计划刻事件</li>
<li>若 $n &lt; 15$，则来自比较器后方的脉冲可让比较器输出的信号强度变为 15，从而诱使比较器添加计划刻事件</li>
</ul>
<p>【疑似有虫】当侧面输入与后方输入的信号强度相等时，比如使用中继器或侦测器这类输出 15 强度信号的元件时，这两个脉冲的顺序也是有讲究的。对于无延迟链上的每一个比较器，我们需要首先向其后端输入脉冲，再向其侧面输入脉冲，才可在所有情况下无延迟地传递信号。如果顺序相反，则当后端输入脉冲时，由于比较器侧面已存在信号强度 15 的输入，比较器将会输出 0 强度信号。若比较器储存着的信号已经是 0 强度了，那么这次脉冲输入就无法诱使比较器添加计划刻事件，从而使无延迟比较器失效</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/instant_comparator_pulse_order.png" alt="脉冲顺序【此图有虫】"></p>
<p>下面图这类兼容所有情况的信号变化的无延迟比较器的一个实现</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/real_instant_comparator.gif" alt="全情况可用的无延迟比较器"></p>
<p>以上图为例，在使用中继器或中继器时，所有需要以以下的顺序向比较器输入诱导脉冲：</p>
<ol>
<li>比较器 A 的后方输入端</li>
<li>比较器 A 的侧面输入端</li>
<li>比较器 B 的后方输入端</li>
<li>比较器 B 的侧面输入端</li>
<li>……</li>
<li>比较器 F 的后方输入端</li>
<li>比较器 F 的侧面输入端</li>
</ol>
<p>当然，在实际使用中，由于上述无延迟比较器设计都不能无限地延长。不过，如果配合无延迟信号线使用，即可实现可无限延伸的无延迟比较器链。下面是一个可行的例子</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3.4/instant_comparator_inf.gif" alt="无限延伸的无延迟比较器链"></p>
<h4 id="比较器更新检测器"><a class="header-anchor" href="#比较器更新检测器"></a>比较器更新检测器</h4>
<h2 id="3-4-4-红石火把"><a class="header-anchor" href="#3-4-4-红石火把"></a>3.4.4 红石火把</h2>
<h3 id="计划刻事件执行"><a class="header-anchor" href="#计划刻事件执行"></a>计划刻事件执行</h3>
<p>blabla</p>
<h2 id="3-4-5-侦测器"><a class="header-anchor" href="#3-4-5-侦测器"></a>3.4.5 侦测器</h2>
<h3 id="3-4-5-1-方块状态"><a class="header-anchor" href="#3-4-5-1-方块状态"></a>3.4.5.1 方块状态</h3>
<p>作为一个可旋转的方块，侦测器拥有一个 <code>facing</code> 标签表示其指向。除此之外侦测器还具有以下标签：</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>取值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>powered</td>
<td>false, true</td>
<td>其当前的亮起状态。我们称该标签为假时侦测器熄灭，该标签为真时侦测器亮起</td>
</tr>
</tbody>
</table>
<h3 id="3-4-5-2-接受方块更新"><a class="header-anchor" href="#3-4-5-2-接受方块更新"></a>3.4.5.2 接受方块更新</h3>
<p>当侦测器输入端的位置发出了状态更新，将引起侦测器的检测</p>
<p>注意，用于块更新红石粉方侧下方红石粉链接状态的状态更新是不会被侦测器响应的</p>
<h3 id="3-4-5-3-计划刻事件执行"><a class="header-anchor" href="#3-4-5-3-计划刻事件执行"></a>3.4.5.3 计划刻事件执行</h3>
<p>blabla</p>
<h2 id="投掷器-发射器"><a class="header-anchor" href="#投掷器-发射器"></a>投掷器/发射器</h2>
<h3 id="计划刻事件执行-2"><a class="header-anchor" href="#计划刻事件执行-2"></a>计划刻事件执行</h3>
<p>blabla</p>
<h2 id="红石灯"><a class="header-anchor" href="#红石灯"></a>红石灯</h2>
<h3 id="计划刻事件执行-3"><a class="header-anchor" href="#计划刻事件执行-3"></a>计划刻事件执行</h3>
<p>blabla</p>
<h2 id="探测类元件"><a class="header-anchor" href="#探测类元件"></a>探测类元件</h2>
<h3 id="计划刻事件执行-4"><a class="header-anchor" href="#计划刻事件执行-4"></a>计划刻事件执行</h3>
<p>blabla</p>
<h2 id="其他红石元件"><a class="header-anchor" href="#其他红石元件"></a>其他红石元件</h2>
<h3 id="计划刻事件执行-5"><a class="header-anchor" href="#计划刻事件执行-5"></a>计划刻事件执行</h3>
<p>blabla</p>
<h2 id="非红石元件"><a class="header-anchor" href="#非红石元件"></a>非红石元件</h2>
<h3 id="计划刻事件执行-6"><a class="header-anchor" href="#计划刻事件执行-6"></a>计划刻事件执行</h3>
<p>blabla</p>
<h2 id="流体"><a class="header-anchor" href="#流体"></a>流体</h2>
<h3 id="计划刻事件执行-7"><a class="header-anchor" href="#计划刻事件执行-7"></a>计划刻事件执行</h3>
<p>blabla</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>net.minecraft.util.EnumFacing#values <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>net.minecraft.block.BlockRedstoneDiode#updateState <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>在 1.15 及以后，该事件的优先级改为 -2 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>也就是比较器方块实体并未实现 <code>net.minecraft.util.ITickable</code> 这个接口 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>net.minecraft.block.Block#isNormalCube <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>深度剖析MC</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析Minecraft #3 计划刻</title>
    <url>/zh-CN/2020/deeply-dissecting-minecraft_3/</url>
    <content><![CDATA[<h1 id="3-计划刻"><a class="header-anchor" href="#3-计划刻"></a>3 计划刻</h1>
<h2 id="3-1-什么是计划刻"><a class="header-anchor" href="#3-1-什么是计划刻"></a>3.1 什么是计划刻</h2>
<p>计划刻，英文为 Tile Tick。国内社区曾用 Next Tick Entry (NTE) 进行描述</p>
<p>在 Minecraft 中，许多方块对变化的响应并不是瞬时，而是延迟一定时间后方才开始执行的，如下面几个常见的例子：</p>
<ul>
<li>中继器响应信号输入</li>
<li>沙子检测下方方块以准备下落</li>
<li>流体进行流动</li>
<li>悬空脚手架的逐个掉落</li>
</ul>
<span id="more"></span>
<p>对于这一类具有共性的延迟执行的事件，Minecraft 使用计划刻这一概念进行统一的管理，每一个纬度的计划刻管理系统都是相互<strong>独立</strong>的</p>
<p>1.13 前，方块和流体共用一个计划刻管理系统进行储存，1.13 及以后，方块和流体为独立的计划刻管理系统</p>
<h2 id="3-2-计划刻的实现原理"><a class="header-anchor" href="#3-2-计划刻的实现原理"></a>3.2 计划刻的实现原理</h2>
<h3 id="3-2-1-计划刻管理系统"><a class="header-anchor" href="#3-2-1-计划刻管理系统"></a>3.2.1 计划刻管理系统</h3>
<p>一个计划刻管理系统，是一个包含了一套完善的与计划刻相关的状态、容器的对象，类名如下</p>
<blockquote>
<p>net.minecraft.world.ServerTickList (1.13.2 mcp)</p>
<p>net.minecraft.server.world.ServerTickScheduler (1.15.2 yarn)</p>
</blockquote>
<p>其中，有三个储存着计划刻事件的容器是我们所关注的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>属性名</th>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>计划刻队列</td>
<td>pendingTickListEntriesTreeSet</td>
<td>TreeSet</td>
<td>可视作一个优先队列，用于有序地储存计划刻事件</td>
</tr>
<tr>
<td>计划刻队列附属哈希表</td>
<td>pendingTickListEntriesHashSet</td>
<td>HashSet</td>
<td>用于快速判断计划刻事件是否在计划刻队列中</td>
</tr>
<tr>
<td>即将执行事件列表</td>
<td>pendingTickListEntriesThisTick</td>
<td>ArrayList</td>
<td>储存着即将在某个游戏刻执行的计划刻事件</td>
</tr>
</tbody>
</table>
<h3 id="3-2-2-计划刻事件"><a class="header-anchor" href="#3-2-2-计划刻事件"></a>3.2.2 计划刻事件</h3>
<p>对于一个计划刻事件（<code>net.minecraft.world.NextTickListEntry</code>）来说，它具有以下属性</p>
<ul>
<li>事件 id，一个递增的不重复整数</li>
<li>目标方块/流体类型</li>
<li>方块/流体的方块坐标</li>
<li>事件计划执行的游戏刻</li>
<li>事件优先级</li>
</ul>
<p>事件优先级一共有 7 种可能的取值，从 -3 至 +3，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EXTREMELY_HIGH(-<span class="number">3</span>),</span><br><span class="line">VERY_HIGH(-<span class="number">2</span>),</span><br><span class="line">HIGH(-<span class="number">1</span>),</span><br><span class="line">NORMAL(<span class="number">0</span>),</span><br><span class="line">LOW(<span class="number">1</span>),</span><br><span class="line">VERY_LOW(<span class="number">2</span>),</span><br><span class="line">EXTREMELY_LOW(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>由其中可看出，每个计划刻事件所储存的属性其实并不是十分详细，不少事件的具体细节是没有储存起来的，如：</p>
<ul>
<li>计划刻事件仅储存了方块的种类，未储存方块状态</li>
<li>计划刻事件未储存该事件将要执行什么动作，也即在该事件真正执行前游戏是不知道这个事件具体会引发什么动作的</li>
</ul>
<h4 id="3-2-2-1-计划刻事件间的比较"><a class="header-anchor" href="#3-2-2-1-计划刻事件间的比较"></a>3.2.2.1 计划刻事件间的比较</h4>
<p>两个计划刻事件是相同的（<code>equals</code> 方法），当且<strong>仅</strong>当这两个事件的以下属性相同</p>
<ul>
<li>目标方块/流体类型</li>
<li>方块/流体的方块坐标</li>
</ul>
<p>这将用在判断事件是否存在于 <code>即将执行的事件列表</code>（一个 <code>ArrayList</code>）中</p>
<hr>
<p>在判断事件的大小关系时（<code>compareTo</code> 方法），按照以下关键字依次比较：</p>
<ol>
<li>执行时刻，较小者优先</li>
<li>事件优先级</li>
<li>事件 id，较小者优先</li>
</ol>
<p>这将用在计划刻队列（一个 <code>TreeSet</code>）的实现中</p>
<h3 id="3-2-3-计划刻阶段"><a class="header-anchor" href="#3-2-3-计划刻阶段"></a>3.2.3 计划刻阶段</h3>
<p>每游戏刻中，计划刻阶段的执行入口是 <code>net.minecraft.world.WorldServer#tickPending</code>。其中，先处理方块的计划刻阶段，再处理流体相关的计划刻阶段</p>
<p>在计划刻阶段里，游戏将按照事件优先级从高到底的顺序执行将在此游戏刻中执行的计划刻事件。若优先级相同，则比较事件的id，id较小的先执行</p>
<p>具体实现是比较朴素的。Minecraft 使用了一个 TreeSet（使用红黑树实现的二叉平衡树）作为该纬度所有计划刻事件的容器</p>
<p>因为在代码中，不存在直接删改该容器某个具体元素的用法，仅存在插入元素及取出最小元素这两个操作，因此即便这个容器不是明面上的一个队列， 它仍可被视为一个队列，或者更准确的，优先队列。这也是计划刻队列这一词的来由</p>
<p>TreeSet 的时间复杂度是 O(nlogn)，这意味着实际上计划刻元件的卡顿并非线性增加的，不过在实际情况下由于 logn 变化极小，仍可以大致认为卡顿是线性增加的</p>
<p>下面以方块的计划刻阶段为例，核心流程如下：</p>
<ol>
<li>检索应在该游戏刻执行的事件
<ol>
<li>取出计划刻队列中位于最前的事件（比较方法见上方所列的优先级）</li>
<li>若当前的游戏时间小于该事件的执行时刻，或者本计划刻阶段已取出了 65536 个计划刻事件 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，则退出循环，跳出循环。超过上限的事件将会延迟到下一游戏刻尝试执行</li>
<li>将该事件<strong>移出计划刻队列</strong>，暂存入一个即将执行的事件列表</li>
</ol>
</li>
</ol>
<p>第一步执行完后，游戏已经确认下来了这个游戏刻中将执行哪些计划刻事件。注意到这些事件已经被移出了计划刻队列，因此一个新的相同的计划刻事件现在是可以添加成功了（计划刻事件添加的判据见 <a href="#3-2-4-%E8%AE%A1%E5%88%92%E5%88%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0">3.2.4 计划刻事件的添加</a>）</p>
<p>随后，游戏开始执行这些计划刻事件：</p>
<ol start="2">
<li>
<p>处理即将执行的事件列表</p>
<ul>
<li>
<p>对于列表中每个计划刻事件，若事件的方块的坐标所在区块处于加载状态，则：</p>
<ol>
<li>判断世界中此坐标的方块是否仍与该事件的方块类型相同，如果相同，则调用该方块的 <code>tick</code>方法</li>
</ol>
</li>
<li>
<p>若坐标所在的区块未加载，则：</p>
<ol>
<li>
<p>添加一个计划刻事件，属性为：</p>
<ul>
<li>坐标：该事件的坐标</li>
<li>方块：该事件的方块</li>
<li>延迟：0</li>
<li>优先级：0</li>
</ul>
<p>不过此计划刻事件不会添加成功，因为此事件的坐标所在区块未被加载。至于为何要实现此逻辑，仍有待考究</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>计划刻阶段结束</p>
</li>
</ol>
<p>为了让表述更流畅，上述描述并非与源代码 100% 对应的分析，但是其效果是等价的。具体代码可见：</p>
<p><code>net.minecraft.world.ServerTickList#tick (1.13.2 mcp) </code></p>
<p><code>net.minecraft.server.world.ServerTickScheduler#tick (1.15.2 yarn)</code></p>
<h3 id="3-2-4-计划刻事件的添加"><a class="header-anchor" href="#3-2-4-计划刻事件的添加"></a>3.2.4 计划刻事件的添加</h3>
<p>若要添加一个计划刻事件，需要传入以下的参数：</p>
<ul>
<li>方块/流体的坐标</li>
<li>方块/流体的类型</li>
<li>执行延迟</li>
<li>事件优先级。若未指定则为默认值 0</li>
</ul>
<p>随后，游戏会依次执行下述步骤判断此次添加是否合法：</p>
<ol>
<li>若添加的是方块计划刻事件，则该事件方块不可为空气；若添加的是流体计划刻事件，则流体不可为空</li>
<li>事件所在坐标的区块处于已加载状态</li>
<li><strong>计划刻队列中不存在相同的事件</strong></li>
</ol>
<p>最后，一个新的计划刻事件将会创建并加入至计划刻队列中 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，其方块/流体的类型与坐标即为所给值，而执行时刻则从给出的执行延迟计算得到，为 <code>执行延迟 + 该纬度当前的游戏时间</code></p>
<h3 id="3-2-5-计划刻事件的删除"><a class="header-anchor" href="#3-2-5-计划刻事件的删除"></a>3.2.5 计划刻事件的删除</h3>
<p>计划刻事件在添加入计划刻队列后，是不会直接被游戏删除的，即便原方块/流体已经被改变。游戏中唯一类似删除计划刻事件的地方，是由于事件所处的区块被卸载，从而导致执行该事件的时候被游戏移除队列且不再加入队列不过放心，在区块卸载保存的时候，计划刻队列是会保存至磁盘的，因此不需要担心计划刻元件的动作被丢失了</p>
<p>计划刻事件的不易被删除特性，在某些情况下是可以利用的</p>
<h2 id="3-3-计划刻事件执行顺序"><a class="header-anchor" href="#3-3-计划刻事件执行顺序"></a>3.3 计划刻事件执行顺序</h2>
<h3 id="3-3-1-单个元件"><a class="header-anchor" href="#3-3-1-单个元件"></a>3.3.1 单个元件</h3>
<blockquote>
<p>事件间比较大小的关键字依次为：</p>
<ol>
<li>执行时刻，较小者优先</li>
<li>事件优先级</li>
<li>事件 id，较小者优先</li>
</ol>
</blockquote>
<p>按照这三个关键字，我们可以很轻易地判断两个计划刻事件间的执行先后。前两个关键字很容易获得，但是第三个关键字并为直接给出，因此不能在前两个关键字相同的情况下，并不能直观地判断孰先孰后</p>
<p>观察 <code>事件 id</code> 的定义，这是一个递增的不重复的整数，因此，先创建的计划刻事件一定会有较小的 <code>事件 id</code> ，也就是在执行时刻与事件优先级相同的情况下，先创建的事件会优先于后创建的事件执行</p>
<p>也就是<strong>先进先出</strong>！</p>
<p>下面是一些例子：</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/single0.png" alt="single0"></p>
<p>执行时刻，A 先于 B，因此 A 先执行</p>
<hr>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/single1.png" alt="single1"></p>
<p>执行时刻：A 与 B 相同</p>
<p>优先级：A 大于B</p>
<p>因此 A 先执行</p>
<hr>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/single2.png" alt="single2"></p>
<p>执行时刻：相同</p>
<p>优先级：相同</p>
<p>创建顺序（事件 id）：A 先于 B</p>
<p>因此 A 先执行</p>
<h3 id="3-3-2-多元件组合"><a class="header-anchor" href="#3-3-2-多元件组合"></a>3.3.2 多元件组合</h3>
<p>在<strong>总延迟相同</strong>的前提下，用不同档位凑出来的中继器/比较器/序列谁先输出信号，是一个老生常谈的问题，比如下图</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/multi0.png" alt="multi0"></p>
<p>由于总延迟是相同的，并且最末端的元件具有相同的优先级，我们不能简单地观察最末端的元件来判断执行顺序，我们需要结合其余元件进行考虑，得出最末端元件创建事件的顺序间的先后关系，从而得到执行顺序</p>
<p>由于在这些判断顺序的实例中，第 n 个元件的计划刻事件创建事件往往是与第 n - 1 个元件的点亮时刻是相同的，因此可以用低 n -1 个元件的点亮时刻来替代第 n 个元件的创建事件时刻</p>
<p>令拉杆拉下的时刻为 gt0。由于序列 A 的第一个中继器是在 gt2 点亮，而序列 B 的第一个中继器是在 gt 8 点亮，晚于序列 A 的第一个中继器，因此序列 A 的第二个也就是末端的中继器先于序列 B 的末端中继器激活</p>
<p>如果还有更多的元件呢，那我们继续比较下去！</p>
<ul>
<li>若次末端的元件点亮时刻与优先级均相同，则判断倒数第三个元件的点亮先后顺序</li>
<li>若倒数第三个元件的元件点亮时刻与优先级均相同，则判断倒数第四个元件的点亮先后顺序</li>
<li>……</li>
</ul>
<p>也就是，<strong>从尾到头依次比较元件的点亮顺序，直到比较出结果</strong></p>
<p>若比较的两个序列的元件是同一个元件，这时比较更新顺序即可。如一个拉杆向两侧引出 1 挡中继器，这是就需要根据方块更新的顺序来判断哪一侧的中继器先被更新</p>
<p>下面是一些例子：</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/multi0.png" alt="multi0"></p>
<p>末端的中继器的优先级及点亮时间均相同，比较前端的中继器点亮时间：A 先，因此 A 序列比 B 序列先输出</p>
<hr>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/multi1.png" alt="multi1"></p>
<p>A, B 与 C, D, E 的比较与上图相同，对于 A, B，第一个元件点亮的优先级是 A 的中继器更高，因此 A 比 B 先输出。总输出顺序为 A, B, C, D, E</p>
<hr>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/multi2.png" alt="multi2"></p>
<p>根据最末端元件的优先级可立即得到 A, B, C 比 D, E 先输出。A 的中继器最先得到输入信号，因此 A 最先输出。剩余序列比较方法同上，比较第一个元件的优先级即可得出总输出顺序为 A, B, C, D, E</p>
<h2 id="3-4-计划刻元件"><a class="header-anchor" href="#3-4-计划刻元件"></a>3.4 计划刻元件</h2>
<p>见《<a href="/zh-CN/2020/deeply-dissecting-minecraft_3.4/" title="深度剖析Minecraft #3.4 计划刻元件">深度剖析Minecraft #3.4 计划刻元件</a>》</p>
<h2 id="3-5-时序描述"><a class="header-anchor" href="#3-5-时序描述"></a>3.5 时序描述</h2>
<p>在分析计划刻相关的时序的时候，计划刻事件的优先级以及计划刻事件的目标常常是我们关心的因素</p>
<p>对于一个优先级为 <code>x</code> ，目标为 <code>y</code> 的计划刻事件，下面使用记号 <code>TileTick.priority=x,target=y</code>，或者简称 <strong><code>TT.x.y</code></strong> 来表示该事件执行时所处在的游戏阶段。在不关心优先级或者目标的场合中，<code>.x</code> <code>.y</code> 是可以视情况选择省略的。在大多数情况下，时序精度划分至计划刻阶段或者计划刻优先级，就已经足够了。</p>
<p>例如，对于单个红石中继器的点亮事件，其发生的游戏阶段为 <code>TT.-1</code></p>
<p>当然，也可使用计划刻的旧称 <code>NTE</code> 来替换上述的 <code>TT</code> 以得到在特定情境下得到与已有理论体系更好的衔接</p>
<h2 id="3-6-计划刻性质的应用"><a class="header-anchor" href="#3-6-计划刻性质的应用"></a>3.6 计划刻性质的应用</h2>
<h3 id="3-6-1-计划刻滞后-EMP"><a class="header-anchor" href="#3-6-1-计划刻滞后-EMP"></a>3.6.1 计划刻滞后/EMP</h3>
<blockquote>
<p>More like a redstone EMP</p>
<p>—— Casper2002 @ <a href="https://youtu.be/1GWaZ5vEd3A">https://youtu.be/1GWaZ5vEd3A</a></p>
</blockquote>
<p>在分析计划刻阶段的流程时，细心的读者可能已经注意到了，每游戏刻可执行的计划刻事件数量有个 65536 的上限，超过上限的事件将会延迟到下一游戏刻尝试执行，这一点似乎是可以加以利用的</p>
<p>如果我们认为的在某一游戏刻中添加了巨量的延迟相同的计划刻事件，使其数量超过了 65536，则可在游戏中制造一些正常情况下不可能发生的事情：某些计划刻事件被延后执行了。这可以用于无线红石信号传输、无限遥控飞行器，也可以用恶意破坏红石电路。该机制的作用范围是整个维度</p>
<p>下面以该机制发现者 Xcom6000 的《<a href="https://www.bilibili.com/video/BV16t411s7qi">原版生存无线红石</a>》为例，分析下其时序</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/emp-tower.png" alt="emp-tower"></p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/emp-detector.png" alt="emp-detector"></p>
<table>
<thead>
<tr>
<th style="text-align:left">游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td>TT.-2</td>
<td>中继器熄灭，大量充能铁轨熄灭，更新 n, n &gt; 65536 个沙子方块。巨量的沙子方块添加了位于 gt 2 的计划刻事件</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td>TT.0</td>
<td>某一侧两个侦测器分别检测到对脸的侦测器的变化，添加位于 gt 2 的计划刻事件。这个事件可能是用于熄灭侦测器，也有可能是用于点亮侦测器，不过这并不影响</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td>TT.0</td>
<td>计划刻队列由 n 个沙子的事件以及 2 个侦测器的事件组成，其长度 &gt; 65536。游戏仅执行了前 65536 个计划刻事件吗，其余的 n - 65536 个计划刻事件，及侦测器的计划刻事件被推迟到下一个游戏刻执行</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>TT.0</td>
<td>其余的 n - 65536 个计划刻事件及侦测器的计划刻事件依次执行。<strong>我们获得了延迟了 3gt 才执行的侦测器</strong>。装置两侧的 4gt 对脸侦测器时钟从异步 1gt 变为同步或是异步 2gt</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td>无线红石检测装置检测到执行到了时序，输出信号</td>
</tr>
</tbody>
</table>
<p>不过，这一类装置<strong>仅可滞后计划刻事件的执行，不能让计划刻事件消失</strong></p>
<h3 id="3-6-2-随机刻伪造"><a class="header-anchor" href="#3-6-2-随机刻伪造"></a>3.6.2 随机刻伪造</h3>
<p>也不知道是历史遗留问题还是代码的复用问题，在游戏中，每个方块被随机刻选中时所调用的默认方法是其执行计划刻事件时所调用的方法 <code>net.minecraft.block.Block#tick</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomTick</span><span class="params">(IBlockState state, World worldIn, BlockPos pos, Random random)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.tick(state, worldIn, pos, random);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tick</span><span class="params">(IBlockState state, World worldIn, BlockPos pos, Random random)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那些既可以响应随机刻，又可以响应计划刻的方块，在执行 <code>tick</code> 方法的时候，是怎么确认它该执行哪一部分的逻辑呢？Mojang 给出的答案是，在 <code>tick</code> 方法内即时判断</p>
<p>以仙人掌为例。作为一种作物，仙人掌会在被随机刻选中时执行一次生长；作为一种对环境有依赖的植物，在发现其状态不适合生长时（沙子消失/水平毗邻 4 格方块存在可阻挡仙人掌生长的方块），会添加一个延迟为 1 的计划刻事件，用于变为空气并掉落物品，也用于使高耸入云的仙人掌柱能自底向上逐个破坏而减轻服务器的瞬时压力</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/cactus-broken.png" alt="仙人掌柱被破坏"></p>
<p>仙人掌 <code>tick</code> 方法内的逻辑如下所示（<code>net.minecraft.block.BlockCactus#tick</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tick</span><span class="params">(IBlockState state, World worldIn, BlockPos pos, Random random)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.isValidPosition(worldIn, pos))  <span class="comment">// 判断仙人掌所处位置是否合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        worldIn.destroyBlock(pos, <span class="literal">true</span>);  <span class="comment">// 破坏该仙人掌方块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 执行仙人掌生长逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略一看，这个实现好像并没有问题，因为状态不合法而添加的计划刻事件在执行 <code>tick</code> 方法时就会在第一行的 if 判断中进入到破坏仙人掌方块分支</p>
<p>不过仔细一想，并非如此。仙人掌在添加计划刻事件时所处位置不合法，<strong>并不意味</strong>着仙人掌在执行计划刻事件的时候所处位置仍不合法！如果我们通过某种手段，在仙人掌添加了用于破坏自身的计划刻事件后，在计划刻事件执行前，恢复仙人掌的生长环境，让仙人掌所处位置恢复到合法的适宜仙人掌生长的状态，则这个计划刻执行的时候将会执行随机刻的逻辑。这，就是随机刻伪造，也就算作物的强制催熟</p>
<p>下面是一个仙人掌强制催熟装置的示意图。指向仙人掌的活塞每 0t 伸出一次，即可让仙人掌使用计划刻事件伪造一次随机刻事件，使其生长阶段 +1</p>
<p><img data-src="/zh-CN/2020/deeply-dissecting-minecraft_3/force-growth.png" alt="强制催熟"></p>
<p>时序分析如下：</p>
<table>
<thead>
<tr>
<th>游戏刻</th>
<th>游戏阶段</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>BE.0 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></td>
<td>指向仙人掌的活塞开始伸出，活塞前方发出方块更新，更新到仙人掌方块。仙人掌检查自身状态，发现水平毗邻的方块存在一个活塞头，会阻挡生长，于是添加一个延迟为 1 的计划刻事件用于破坏自身</td>
</tr>
<tr>
<td>0</td>
<td>BE.2 <sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup></td>
<td>指向仙人掌的活塞开始收回，活塞前方方块变为空气。<strong>此时仙人掌所处位置状态变为合法</strong></td>
</tr>
<tr>
<td>1</td>
<td>TT</td>
<td>仙人掌执行其 <code>tick</code> 方法，判断所处位置是否合法，结果是合法，则执行随机刻相关的逻辑，生长阶段 +1</td>
</tr>
</tbody>
</table>
<p>这就是强制催熟仙人掌的时序分析。由于仙人掌的计划刻延迟为 1gt，我们最快每秒可进行 $20 / 1 = 20$ 次强制催熟，也就是在忽略随机刻作用的前提下，需要 16 次生长才可增高的仙人掌一小时即可长高 $3600 * 20 / 16 = 4500$ 次，效率远超传统的自然生长仙人掌农田</p>
<p>随机刻伪造在1.16中被修复，各种对随机刻有响应的方块执行随机刻相关逻辑的代码被移至了 <code>randomTick</code> 方法中</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在实际的代码实现中，65536 这个限制是在循环开始前就应用了 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在具体代码实现中，计划刻事件在检查的第三步已经创建，以便于判断计划刻队列中是否存在相同的事件 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>BE.x 表示方块事件阶段中，深度 = x 的方块事件执行时的阶段，将在第四章方块事件中作进一步的解释 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>深度剖析MC</tag>
      </tags>
  </entry>
  <entry>
    <title>对1.13后两种不同方块更新类型译名的探讨</title>
    <url>/zh-CN/2020/discussion-about-13-blockupdate-types/</url>
    <content><![CDATA[<p>先放结论，我打算将 NC 更新译为“方块更新”，与 1.12 及以前的方块更新接轨；将 1.13 新增的 “PP” 更新译为“状态更新”</p>
<span id="more"></span>
<hr>
<p>1.13 后方块更新分为了两大类，在我的文章《<a href="/zh-CN/2020/deeply-dissecting-minecraft_2/" title="深度剖析Minecraft #2 方块更新">深度剖析Minecraft #2 方块更新</a>》中我是用了 1.13.2 mcp mapping 的 NeighbourChange （NC）以及 PostPlacement （PP）进行区分</p>
<p>不过这两者并不是一个利于行文流畅及推广传播的名字，因此我想给他们一个恰当的译文</p>
<p><strong>NeighborChanged</strong></p>
<blockquote>
<p>NeighborChanged 更新，指的是最基础的，最符合“方块更新”一词含义的更新。红石元件的状态变化、方块的放置与破坏、方块开始移动以及方块到位都可以产生 NC 更新。除此之外，各种杂七杂八地方块变化大多也都能产生 NC 更新</p>
<p>游戏里能产生 NC 更新的事件太多了，不便于一一列举。不过能响应 NC 更新的却不算多。所有能响应 NC 更新的事件有： 活板门、栅栏门、木门、铁门更新开关状态 霜冰检测融化 活塞检测移动 活塞头给予活塞底座 NC 更新 红石粉、中继器、比较器、红石火把、各类铁轨、命令方块、投掷器、发射器、音符盒、红石灯、TNT更新状态 水、岩浆检测状态 灵魂沙、岩浆块添加生成气泡柱的 TT 事件 海绵尝试吸水</p>
<p>《深度剖析Minecraft #2 方块更新》</p>
</blockquote>
<p>NC 更新的译名应该较为容易解决，因为其于代码中的实现与 1.12 前的方块更新是一致的，也是游戏中最为常见且常用的一种更新。因此我打算继承最为通用的名称，方块更新，一词来表示 NC 更新</p>
<p>各大 mapping 的名称：</p>
<ul>
<li>mcp：neighborChanged</li>
<li>yarn：neighborUpdate</li>
<li>mojang：neighborChanged</li>
</ul>
<p><strong>PostPlacement</strong></p>
<blockquote>
<p>PostPlacement，指的是方块发生变化后导致的临近方块与之交互情况发生变化的更新。 所有能响应 PP 更新的事件有：</p>
<ul>
<li>各类依附性方块（火把、雪片地毯蛋糕、各类花草作物、拉杆按钮、木门铁门、火焰等）判断依附的方块是否合法并决定是否掉落</li>
<li>连接型方块（栅栏石墙玻璃板、楼梯、箱子、红石粉绊线、地狱门、高草紫颂植物等）更新当前与相邻方块连接状态</li>
<li>中继器更新被锁状态</li>
<li>音符盒更新乐器类型</li>
<li>树叶更新离木距离</li>
<li>……</li>
</ul>
<p><strong>《深度剖析Minecraft #2 方块更新》</strong></p>
</blockquote>
<p>这是一个 1.13 后才添加的新的方块类型，并不能直接通过旧时称法来分析，需要讨论其具体行为与作用</p>
<p>先看看各大 mapping 的名称：</p>
<ul>
<li>mcp：updatePostPlacement</li>
<li>yarn：getStateForNeighborUpdate</li>
<li>mojang：updateShape</li>
</ul>
<p>因为 PP 更新被大量应用在依附性方块/连接性方块的状态（blockstate）的更新上，尤其是连接性的方块，在受到 PP 更新的时候它们将会依据临近方块的方块状态而更新自己的方块状态，并不改变自己的方块类型</p>
<p>除此之外，作为 PP 更新最为典型的检测装置——侦测器而言，侦测器检测的一大特点是可以检测方块的状态是否发生变化</p>
<p>结合 PP 更新与方块状态的种种关系，我打算将 PP 更新称为状态更新</p>
<p>状态更新一词也符合（侦测器检测的是状态变化），也不会与方块更新的“方块”混淆</p>
<p>除此之外，在国外社区中，常用 state change 一词来表示 PP 更新，该词的翻译也恰好为“状态更新”，因此该翻译也可无缝地与国外社区接轨</p>
<p><img data-src="/zh-CN/2020/discussion-about-13-blockupdate-types/discord1.png" alt="网友讨论"></p>
<p><img data-src="/zh-CN/2020/discussion-about-13-blockupdate-types/discord2.png" alt="网友讨论"></p>
<hr>
<p>如果你有更好的译名，或者你了解一些已经在其他领域中已广泛传播的译名，都可以在评论区中发表相关看法</p>
<p>作者本人水平有限，如有错误欢迎指出</p>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>方块更新</tag>
        <tag>反混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>末影人西瓜农场笔记</title>
    <url>/zh-CN/2023/endermelon-notes/</url>
    <content><![CDATA[<h1 id="末影人西瓜农场笔记"><a class="header-anchor" href="#末影人西瓜农场笔记"></a>末影人西瓜农场笔记</h1>
<p>注意！这篇文章仍处于<strong>施工中</strong>，具体完工时间未知</p>
<span id="more"></span>
<h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2>
<p>末影人西瓜农场，指的是一类利用末影人死亡时必定掉落其手持方块物品形式的机制，让末影人捡起西瓜方块，随后杀死末影人的一种农场。本文将“小黑”这一末影人的俗称指代末影人，使用“小黑瓜机”或“瓜机”（无歧义时）指代末影人西瓜农场。</p>
<p>直接用活塞推动西瓜方块，只能掉落西瓜片，如果需要获得西瓜块的话，玩家还需要手动合成西瓜。作为唯一能全自动获得西瓜方块的方式，小黑瓜机可以避免传统推瓜农场在后续合成瓜块方面的工作量，能让西瓜的生产实现全自动。</p>
<p>小黑瓜机的产率在众多作物农场间并不出色。与普通作物农场相比，由于小黑瓜机涉及到了自然刷怪，因此无法简单地通过堆叠模块增加面积的方式提升效率；与普通刷怪塔相比，由于小黑在刷出后不能直接处死，而是需要放进瓜田里尝试捡一会瓜才能处死，这显著地增加了小黑存活时间，导致小黑瓜机无法像普通刷怪塔一样有着动辄几十万的产率。</p>
<p>本文主要内容如下：</p>
<ol>
<li>剖析小黑瓜机中涉及的游戏机制</li>
<li>从理论角度分析影响小黑瓜机效率的因素</li>
<li>分析现有小黑瓜机的设计思路</li>
</ol>
<h2 id="一些术语"><a class="header-anchor" href="#一些术语"></a>一些术语</h2>
<h3 id="坐标"><a class="header-anchor" href="#坐标"></a>坐标</h3>
<p>在分析中，常用的坐标有两种：一种是由 3 个实数组成的<strong>点坐标</strong>，如 <code>(1.7, 2.5, 3.0)</code>，可以确定世界中的一个点；另一种则是由 3 个整数组成的<strong>方块坐标</strong>，如 <code>(1, 2, 3)</code>，可以确定世界中的一个方块位置</p>
<p>在本文中，当我们描述一个坐标 $P$ 时，我们可以用 $P.x$ 代表该坐标的 x 值，$P.y$ 代表该坐标的 y 值，$P.z$ 代表该坐标的 z 值</p>
<p>在 MC 中，我们可以将一个点坐标转换为方块坐标，方法也很简单——将点坐标的三个坐标值向<strong>下</strong>取整，得到三个整数，组合起来即为其所对应的方块坐标，即 $B = (\lfloor{A.x}\rfloor, \lfloor{A.y}\rfloor, \lfloor{A.z}\rfloor)$。这一坐标转换的几何意义也很明显：当点坐标 A 位于方块坐标 B 所代表的方块位置的 1x1x1 的立方体中时，点坐标 A 转换为的方块坐标即为 B，如下图所示：</p>
<p><img data-src="/zh-CN/2023/endermelon-notes/coord.png" alt="方块坐标"></p>
<p>本文将对这一 1x1x1 立方体称为方块坐标 B 对应的方格</p>
<p>对于实体而言，一个实体的<strong>实体坐标</strong>，指的是该实体碰撞箱下表面中心点所在的<strong>点坐标</strong>，这也是在召唤/传送的实体的时所使用的的坐标。对于玩家而言，玩家的实体坐标即为 F3 中显示的 XYZ 坐标</p>
<p>对于生物而言，其<strong>眼部坐标</strong>是一个通过如下方法计算出来的点坐标：x / z 为其实体坐标的 x / z，y 为其实体坐标的 y 加上其眼部高度。可以使用 F3 + B 开启碰撞箱显示来可视化地观察一个生物的眼部坐标，如下图所示，从生物的头附近延伸出去的那根蓝线的起点，即为这个生物的眼部坐标</p>
<img data-src="/zh-CN/2023/endermelon-notes/eyepos.png" alt="村民的眼部坐标" style="zoom:67%;">
<h3 id="AI"><a class="header-anchor" href="#AI"></a>AI</h3>
<p>本文将使用以下与 生物 AI 相关的术语：</p>
<ul>
<li>行为：生物 AI 中的基本行为单元，如“随机移动”、“观察玩家”、“搜索目标”等行为，在代码中对应的基类为 <code>EntityAIBase</code>（MCP）、<code>Goal</code>（yarn、mojmap）。对于小黑而言，则存在着“捡起方块”、“放置方块”等行为</li>
<li>两个生物之间存在视野接触：指的是两者的眼部坐标之间的连线不存在方块阻挡。这里的方块阻挡判断使用了采用方块的碰撞箱作为方块轮廓，忽略实体的射线检测</li>
</ul>
<h2 id="理论知识"><a class="header-anchor" href="#理论知识"></a>理论知识</h2>
<h3 id="末影人"><a class="header-anchor" href="#末影人"></a>末影人</h3>
<p>小黑高 2.9m，宽 0.6m，眼部高度 2.55，为末地中唯一可自然生成的怪物。小黑的刷出条件与普通怪物一致，每次成群刷出的最大数量为 4</p>
<h4 id="瞬移"><a class="header-anchor" href="#瞬移"></a>瞬移</h4>
<p>小黑会在以下事件发生时，进行瞬移尝试：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>概率</th>
<th>尝试次数</th>
<th>瞬移指向</th>
</tr>
</thead>
<tbody>
<tr>
<td>暴露在天空光下</td>
<td>与天空光亮度相关</td>
<td>1</td>
<td>随机</td>
</tr>
<tr>
<td>受到远程攻击伤害，如箭矢、三叉戟等</td>
<td>100%</td>
<td>64</td>
<td>随机</td>
</tr>
<tr>
<td>受到无视护甲的伤害，无论该伤害是否成功作用于小黑</td>
<td>90%</td>
<td>1</td>
<td>随机</td>
</tr>
<tr>
<td>正攻击玩家，距离玩家小于 4m，且玩家盯着小黑自己时</td>
<td>N/A</td>
<td>1</td>
<td>随机</td>
</tr>
<tr>
<td>正攻击玩家，距离玩家大于 16m，且离上次攻击玩家时的传送一段时间</td>
<td>N/A</td>
<td>1</td>
<td>目标玩家</td>
</tr>
</tbody>
</table>
<p>小黑的瞬移尝试并不一定会成功：如果瞬移目的地不合法，则本次尝试将失败，小黑留在原地</p>
<p>由于小黑瓜机总是处于末地维度，也不依赖玩家的仇恨，因此我们仅需要考虑上表中与伤害相关的两种瞬移，可以发现它们都属于随机瞬移，仅仅是瞬移的尝试次数以及概率有所不同</p>
<p>小黑的随机瞬移分为两步执行，第一步是选取目标瞬移坐标，第二步为对目标坐标进行调整得到最终瞬移坐标</p>
<p>选取目标坐标 vec 逻辑的逻辑如下所示：</p>
<ol>
<li>令 vec = 为小黑当前实体坐标</li>
<li>vec.x += [-32, 32] 范围内随机实数</li>
<li>vec.y += [-32, 32] 范围内随机整数</li>
<li>vec.z += [-32, 32] 范围内随机实数</li>
<li>尝试瞬移至坐标 vec</li>
</ol>
<p>根据上述逻辑，我们可以发现，小黑瞬移目标的范围近似为以小黑实体坐标为中心的一个 64x64x64 立方体。之所以说这是近似，是因为目的地 y 坐标的的可能取值是离散的，不能取到这一立方体中所有可能的 y 值</p>
<p>调整目标坐标 vec 得到最终瞬移目标的逻辑如下：</p>
<ol>
<li>令目标坐标为 vec</li>
<li>令目标坐标所处于的方块坐标为 pos</li>
<li>找到 pos 下方的最高的一个 pos’，使得 pos’ 下方方块的材料种类为 <a href="https://joakimthorsen.github.io/MCPropertyEncyclopedia/?selection=variants,material_blocks_movement#">可阻挡移动</a> 的类型</li>
<li>如果 pos’ 不存在，传送失败，退出；否则继续执行</li>
<li>vec.y = vec.y - (pos.y - pos’.y + 1)</li>
<li>判断若小黑坐标设为 vec 后，其位置是否合法：小黑碰撞箱需要不与任意方块的碰撞箱重合，且碰撞箱中不能含有流体
<ul>
<li>如果位置合法，执行传送；否则传送失败</li>
</ul>
</li>
</ol>
<p>这部分逻辑也很移动，小黑并不想传送到半空中，在选定瞬移目标后会将其向下移动，找到一个“坚实”的落脚点，来作为最终的瞬移目的地。</p>
<p>从上述瞬移逻辑中我们可以看出，虽然小黑瞬移的目标坐标最多只能距离小黑 32m（切比雪夫距离），但是小黑传送的最终目的地是有可能下移至更低的位置。</p>
<img data-src="/zh-CN/2023/endermelon-notes/enderman-teleport.png" width="50%">
<h4 id="捡起方块"><a class="header-anchor" href="#捡起方块"></a>捡起方块</h4>
<p>小黑捡起方块的 AI 定义于名为 <code>EndermanEntity.PlaceBlockGoal</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 的行为中。当这一行为被执行时，小黑将根据如下步骤选取并尝试捡起身边的一个方块：</p>
<ol>
<li>令小黑的实体坐标为 $A$，小黑将随机选取一个点 $B$，代表即将捡起的方块的位置，其中</li>
</ol>

\begin{align}
B.x &= A.x + [-2, 2] \mbox{间随机实数} \\
B.y &= A.y + [0, 3] \mbox{间随机实数} \\
B.z &= A.z + [-2, 2] \mbox{间随机实数}
\end{align}

<p>如果我们绘制一个长宽均为 4，高为 3 的长方体 $R$，并令该长方体下表面的中心点与 $A$ 重合，那么 $B$ 即可视作此 $R$ 中的一个随机点。长方体 $R$ 的示意图如下：</p>
<img data-src="/zh-CN/2023/endermelon-notes/pickup-target.png" alt="捡起方块选择范围" style="zoom:67%;">
<ol start="2">
<li>令 $B$ 对应的方块坐标为 $B’$，则本次捡方块行为将尝试捡起位于 $B’$ 的方块。</li>
<li>进行如下射线判断，判断小黑自己能不能<strong>捡得到</strong>这一目标方块：
<ol>
<li>令 $A’$ 为 $A$ 对应的方块坐标，也即小黑的实体坐标所对应的方块坐标。可以理解为小黑脚底位于的方块的坐标。</li>
<li>令 $P_{start} = (A’.x + 0.5, B’ + 0.5, A’.z + 0.5)$，即取用 $A’$ 的 xz，再取 $B’$ 的 y，构造出一个方块坐标 $P$，最后取 $P$ 所代表方格的中心点。</li>
<li>令 $P_{end} = (B’.x + 0.5, B’.y + 0.5, B’.z + 0.5)$，即取 $B’$ 对应方格的中心点。</li>
<li>从 $P_{start}$ 至 $P_{end}$ 进行一次射线判定，射线判断可以认为是从起点到终点连一条线，看看该连线有没有与方块相交（被方块阻挡）。如果这一射线判定被除了 $P_{end}$ 所在的方块以外的方块阻挡，则判断失败，小黑无法捡到这一方块；如果射线判定未被任何方块阻挡，或者阻挡的方块即为 $P_{end}$ 所在的方块，那么判断成功，小黑能见到这一方块。</li>
</ol>
</li>
</ol>
<p>这部分判断的逻辑较为复杂，可以参考下图的实例进行理解。在下图中，紫色的点代表 $A$，绿色的点代表 $B$，紫色的框代表 $P$，绿色的框代表 $B’$，紫框与绿框间的淡灰线段的两个端点分别为 $P_{start}$ 与 $P_{end}$，同时这一线段也对应着射线判定时所代表的连线。</p>
<img data-src="/zh-CN/2023/endermelon-notes/pick.gif" alt="pick" style="zoom: 67%;">
<p>现在小黑已经确定自己能捡得到这一个方块了，只剩下最后一步，判断自己能不能<strong>捡得起</strong>这一个方块:</p>
<ol start="4">
<li>判断目标方块是否带有 <code>enderman_holdable</code> 标签，若有则代表小黑能捡起这一方块；若无则小黑不能捡起这一方块，终止流程。注意，具有 <code>enderman_holdable</code> 标签的方块集合随着 MC 版本的变更有修改，如在 1.13 中所有的小型花并不具有这一标签。在 1.12 及以前，小黑能捡起方块集合是硬编码于代码中，而非由方块标签控制的</li>
<li>小黑把目标方块捡到手里，随后移除世界中的这个方块</li>
</ol>
<p>在理解了上述目标方块选取的逻辑后，我们可以得到一些性质：</p>
<ul>
<li>一个方块是被小黑选中的概率至于其相对于小黑的位置有关，与方块的形状/属性无关</li>
<li>一个方块所在方格与长方体 R 重合的越多，它被小黑选中的概率也越高。在该方块的方格完全处于 R 的内部时，它被小黑选中的概率达到最大值，为 $\frac{1}{4*4*3} = \frac{1}{48}$</li>
<li>射线判断起点与重点的 y 坐标相等，它们的连线平行于水平面</li>
</ul>
<p>既然谈到了射线检测，那我们也需要明确一下此处用小黑捡方块使用的射线检测的一些特点：</p>
<ul>
<li>忽略流体</li>
<li>仅考虑方块的边界框，也即指针指向时渲染的黑线框。方块的碰撞箱将被忽略</li>
<li>1.13 及以前，无碰撞箱的方块，如栅栏门，会被忽略</li>
</ul>
<p>在判断射线是否会与方块相交的时候，常常会遇到如下图所示的临界情况：</p>
<img data-src="/zh-CN/2023/endermelon-notes/edgecase.png" alt="临界情况" style="zoom:67%;">
<p>对于这种射线穿对角的临界情况，射线是否会被阻挡，在不同的 Minecraft 版本有着不同的答案，其结果甚至可能依赖于位置，因此难以总结出一个通用的规律。各位读者如果有需要，建议自行前往游戏中进行验证。下面是 1.13.2 和 1.15.2 版本中，射线可穿对角情况的示意图
<img data-src="/zh-CN/2023/endermelon-notes/raycast-corner.png" alt="射线穿对角临界情况"></p>
<p>本章节剩余部分以 Minecraft 1.13.2 为例，讨论方块距离小黑切比雪夫距离为 1 的情况。虽然这一规律并不适用于 1.14+ 的版本，但与其的思想是相同的</p>
<p>直接上结论：在 1.13.2 中，仅在射线在 x 轴方向投影指向 x 轴负半轴时，也即朝西，射线会与这两个方块相交，此时这两个方块之间任意一个都能阻拦射线；反之，若射线在 x 轴上的投影指向 x 轴正半轴，也即朝东，则射线将忽略这两个方块，此时这两个方块都无法阻拦射线。如下图所示：</p>
<img data-src="/zh-CN/2023/endermelon-notes/edgecase-explaination.png" alt="临界情况性质" style="zoom:67%;">
<p>可以感性的理解这一特性：当且仅当射线朝向 x 正半轴时不会被方块阻拦。本文称上述方向依赖性的射线逻辑为“东向穿缝性”。这一个性质在设计小黑瓜机中的瓜布局时非常重要，对这一性质的充分利用可以有效地提升西瓜的密度，同时这也是不少小黑瓜机，如 <a href="https://www.bilibili.com/video/BV1YK4y1d7jD/">dugged 服务器的瓜机</a>，依赖于朝向的原因之一</p>
<p>上述这一射线传对角缝的性质，是我们在设计小黑瓜机中的瓜布局时需要常记于心的。同时这一性质也是不少小黑瓜机依赖于朝向的原因之一</p>
<p>本章节所使用的，用于展示末影人捡起方块射线端点逻辑的 scarpet 指令（在 fabric-carpet v1.4.8、v1.4.91 中测试可用）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/execute <span class="keyword">as</span> @e[<span class="built_in">type</span>=minecraft:enderman,distance=.<span class="number">.16</span>] run script run </span><br><span class="line">t=<span class="number">20</span>;[x,y,z]=pos(p);</span><br><span class="line">draw_shape(<span class="string">&#x27;box&#x27;</span>,<span class="number">2</span>,[<span class="string">&#x27;from&#x27;</span>,[x-<span class="number">2</span>,y,z-<span class="number">2</span>],<span class="string">&#x27;to&#x27;</span>,[x+<span class="number">2</span>,y+<span class="number">3</span>,z+<span class="number">2</span>],<span class="string">&#x27;color&#x27;</span>,<span class="number">0x2255AA88</span>]);</span><br><span class="line">draw_shape(<span class="string">&#x27;sphere&#x27;</span>,<span class="number">2</span>,[<span class="string">&#x27;center&#x27;</span>,[x,y,z],<span class="string">&#x27;radius&#x27;</span>,<span class="number">0.02</span>,<span class="string">&#x27;color&#x27;</span>,<span class="number">0xDD00DD88</span>]);</span><br><span class="line"><span class="keyword">if</span>(world_time()%t==<span class="number">0</span>,</span><br><span class="line">  [x1,y1,z1]=[x-<span class="number">2</span>+rand(<span class="number">4</span>),y+rand(<span class="number">3</span>),z-<span class="number">2</span>+rand(<span class="number">4</span>)];</span><br><span class="line">  <span class="keyword">from</span>=[floor(x)+<span class="number">0.5</span>,floor(y1)+<span class="number">0.5</span>,floor(z)+<span class="number">0.5</span>];</span><br><span class="line">  to=[floor(x1)+<span class="number">0.5</span>,floor(y1)+<span class="number">0.5</span>,floor(z1)+<span class="number">0.5</span>];</span><br><span class="line">  draw_shape(<span class="string">&#x27;box&#x27;</span>,t,[<span class="string">&#x27;from&#x27;</span>,<span class="keyword">from</span>-[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>],<span class="string">&#x27;to&#x27;</span>,<span class="keyword">from</span>+[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>],<span class="string">&#x27;color&#x27;</span>,<span class="number">0xFF33FFFF</span>]);</span><br><span class="line">  draw_shape(<span class="string">&#x27;box&#x27;</span>,t,[<span class="string">&#x27;from&#x27;</span>,to-[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>],<span class="string">&#x27;to&#x27;</span>,to+[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>],<span class="string">&#x27;color&#x27;</span>,<span class="number">0x00DD00DD</span>]);</span><br><span class="line">  draw_shape(<span class="string">&#x27;line&#x27;</span>,t,[<span class="string">&#x27;from&#x27;</span>,<span class="keyword">from</span>,<span class="string">&#x27;to&#x27;</span>,to,<span class="string">&#x27;line&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;color&#x27;</span>,<span class="number">0xDDDDDDFF</span>]);</span><br><span class="line">  draw_shape(<span class="string">&#x27;sphere&#x27;</span>,t,[<span class="string">&#x27;center&#x27;</span>,[x1,y1,z1],<span class="string">&#x27;radius&#x27;</span>,<span class="number">0.02</span>,<span class="string">&#x27;color&#x27;</span>,<span class="number">0x77FF77FF</span>]);</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="放置方块"><a class="header-anchor" href="#放置方块"></a>放置方块</h4>
<p>小黑放置方块的 AI 定义于名为 <code>EndermanEntity.PlaceBlockGoal</code> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 的行为中。当这一行为被执行时，小黑将根据如下步骤选取并尝试放置时其所持有的方块：</p>
<ol>
<li>令小黑的实体坐标为 $A$，小黑将随机选取一个点 $B$，代表即将放置的方块的位置，其中</li>
</ol>

\begin{align}
B.x &= A.x + [-1, 1] \mbox{间随机实数} \\
B.y &= A.y + [0, 2] \mbox{间随机实数} \\
B.z &= A.z + [-1, 1] \mbox{间随机实数}
\end{align}

<p>类似捡起方块的流程，如果我们绘制一个边长为 2 的立方体 $C$，并令该立方体下表面的中心点与 $A$ 重合，那么 $B$ 即可视作此 $C$ 中的一个随机点。立方体 $C$ 的示意图如下：</p>
<img data-src="/zh-CN/2023/endermelon-notes/placedown-target.png" alt="放下方块选择范围" style="zoom: 67%;">
<ol start="2">
<li>令 $B$ 对应的方块坐标为 $B’$，则本次放置方块行为将尝试将方块放至 $B’$ 处</li>
<li>判断此次方块放置是否合法。一次合法的方块放置需要满足以下条件：
<ol>
<li>$B’$ 处的方块为空气</li>
<li>$B’$ 下方的方块不是空气，且为一个碰撞箱是完整的 1x1x1 方块</li>
<li>$B’$ 所在环境对于小黑手持的方块而言，是一个合法的状态。如若小黑手持花方块，则 $B’$ 必须位于泥土类方块的上方</li>
<li>（1.16.2-pre1 及以后）$B’$ 下方的方块不是基岩</li>
<li>（1.16.2-pre2 及以后）$B’$ 所对应的方格范围，不与任何除了这只小黑外的实体的碰撞箱相交</li>
</ol>
</li>
<li>执行方块放置，将小黑手持的方块放置于 $B’$ 处</li>
</ol>
<p>下面是一个具体的例子，其中：</p>
<ul>
<li>紫点为点坐标 $A$</li>
<li>蓝框为立方体 $C$</li>
<li>绿点为点坐标 $B$</li>
<li>绿框为方块坐标 $B’$ 所处的方格</li>
</ul>
<img data-src="/zh-CN/2023/endermelon-notes/placedown-underneath.png" style="zoom:67%;">
<p>小黑准备把手持的西瓜方块放置于绿框处，进行放置检查，发现 $B’$ 下方的方块是平滑石上半砖，不是一个碰撞箱完整的方块，因此这次方块放置的尝试失败</p>
<p>在设计小黑瓜机时，大部分情况下我们需要阻止小黑随处放置手里的西瓜。对此，一些常用的手段有：</p>
<ul>
<li>将所有小黑可触及的位置都放上方块，火把按钮什么的均可，因为小黑只能在空气方块位置放置方块</li>
<li>确保不存在空气方块+碰撞箱完整方块的组合，例如用上半砖来替代实体方块来作为上表面完整的方块</li>
</ul>
<p><img data-src="/zh-CN/2023/endermelon-notes/placement-proof.png" alt="如何阻止末影人乱放方块"></p>
<p>本章节所使用的，用于展示末影人放下方块逻辑的 scarpet 指令（在 fabric-carpet v1.4.8、v1.4.91 中测试可用）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/execute <span class="keyword">as</span> @e[<span class="built_in">type</span>=minecraft:enderman,distance=.<span class="number">.16</span>] run script run </span><br><span class="line">t=<span class="number">20</span>;[x,y,z]=pos(p);</span><br><span class="line">draw_shape(<span class="string">&#x27;box&#x27;</span>,<span class="number">2</span>,[<span class="string">&#x27;from&#x27;</span>,[x-<span class="number">1</span>,y,z-<span class="number">1</span>],<span class="string">&#x27;to&#x27;</span>,[x+<span class="number">1</span>,y+<span class="number">2</span>,z+<span class="number">1</span>],<span class="string">&#x27;color&#x27;</span>,<span class="number">0x2255AA88</span>,<span class="string">&#x27;line&#x27;</span>,<span class="number">4</span>]);</span><br><span class="line">draw_shape(<span class="string">&#x27;sphere&#x27;</span>,<span class="number">2</span>,[<span class="string">&#x27;center&#x27;</span>,[x,y,z],<span class="string">&#x27;radius&#x27;</span>,<span class="number">0.02</span>,<span class="string">&#x27;color&#x27;</span>,<span class="number">0xDD00DD88</span>]);</span><br><span class="line"><span class="keyword">if</span>(world_time()%t==<span class="number">0</span>,</span><br><span class="line">  [x1,y1,z1]=[x-<span class="number">1</span>+rand(<span class="number">2</span>),y+rand(<span class="number">2</span>),z-<span class="number">1</span>+rand(<span class="number">2</span>)];</span><br><span class="line">  pos=[floor(x1),floor(y1),floor(z1)];</span><br><span class="line">  draw_shape(<span class="string">&#x27;box&#x27;</span>,t,[<span class="string">&#x27;from&#x27;</span>,pos,<span class="string">&#x27;to&#x27;</span>,pos+[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;color&#x27;</span>,<span class="number">0x00DD00DD</span>,<span class="string">&#x27;line&#x27;</span>,<span class="number">4</span>]);</span><br><span class="line">  draw_shape(<span class="string">&#x27;sphere&#x27;</span>,t,[<span class="string">&#x27;center&#x27;</span>,[x1,y1,z1],<span class="string">&#x27;radius&#x27;</span>,<span class="number">0.02</span>,<span class="string">&#x27;color&#x27;</span>,<span class="number">0x77FF77FF</span>]);</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="仇恨"><a class="header-anchor" href="#仇恨"></a>仇恨</h4>
<p>小黑对玩家生成的末影螨有着天然的仇恨，会主动移动至搜索范围内 <a href="#AI">视野可见</a> 的末影螨处并对其进行攻击。与之对应的行为为 <code>FollowTargetGoal</code> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，这一 goal 对目标实体的搜索范围为小黑的碰撞箱水平四方向扩展 <code>generic.followRange</code> 米，这里的 <code>generic.followRange</code> 为生物共有的一个属性，是在其生成时确定的一个定值。对于小黑而言，其计算算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 22w16a（1.19快照）及以后</span></span><br><span class="line">generic.followRange = <span class="number">64</span> * (<span class="number">1</span> + nextGaussian() * <span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 22w16a（1.19快照）以前</span></span><br><span class="line">generic.followRange = <span class="number">64</span> * (<span class="number">1</span> + nextTriangular(<span class="number">0</span>, <span class="number">0.11485</span>))</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>nextGaussian()</code> 返回一个标准正态分布随机数</li>
<li><code>nextTriangular(0, 0.11485)</code> 返回一个范围为 [-0.11485, 0.11485] 的三角分布随机数</li>
</ul>
<p>下面的图表展示了 <code>generic.followRange</code> 的概率分布</p>
<table>
<thead>
<tr>
<th>≤ n 的概率</th>
<th>22w16a 以前</th>
<th>22w16a 及以后</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>50%</td>
<td>50%</td>
</tr>
<tr>
<td>62</td>
<td>26.60%</td>
<td>26.49%</td>
</tr>
<tr>
<td>60</td>
<td>10.57%</td>
<td>10.39%</td>
</tr>
<tr>
<td>58</td>
<td>3.04%</td>
<td>1.69%</td>
</tr>
<tr>
<td>56</td>
<td>0.62%</td>
<td>0%</td>
</tr>
<tr>
<td>52</td>
<td>0.0088%</td>
<td>0%</td>
</tr>
<tr>
<td>48</td>
<td>2.87E-7</td>
<td>0%</td>
</tr>
</tbody>
</table>
<p><img data-src="/zh-CN/2023/endermelon-notes/followRange-distribution.png" alt="generic.followRange 的概率分布图"></p>
<p>由此可见：</p>
<ul>
<li>22w16a 以前，由于涉及无上下界的正态分布，<code>generic.followRange</code> 的值可能会非常大，也有可能会非常小。这也是使用末影螨作为仇恨源的小黑瓜机总是时不时会有一些眼瞎小黑一直获取不到末影螨仇恨的原因——无界正态分布总有概率能让小黑的仇恨范围 <code>generic.followRange</code> 变成一个特别小的值</li>
<li>22w16a 及以后，使用了有界的三角分布，因此 <code>generic.followRange</code> 不再可能取到过大或过小的值，其可能的取值范围约为 [56.65, 71.35]</li>
</ul>
<h3 id="生物-AI"><a class="header-anchor" href="#生物-AI"></a>生物 AI</h3>
<p>生物的行为大多由其 AI 控制，末影人也不例外，如上文 <a href="#%E6%9C%AB%E5%BD%B1%E4%BA%BA">末影人</a> 章节中 <a href="#%E6%8D%A1%E8%B5%B7%E6%96%B9%E5%9D%97">捡起方块</a>、<a href="#%E6%94%BE%E4%B8%8B%E6%96%B9%E5%9D%97">放下方块</a> 这两个行为即是由 AI 控制的</p>
<p>对于设计小黑瓜机而言，我们关注的生物 AI 如何控制 <a href="#AI">行为</a> 的执行，行为执行频繁会是怎样：是每 gt 都执行，还是每隔几个 gt 才执行；每次执行时是一定执行，还是有概率执行。毕竟，小黑“捡起方块”行为的执行频率，直接影响了小黑捡瓜的概率。</p>
<p>对于这部分的机制 &lt;=1.13 跟 &gt;=1.14 这两个版本范围间存在着不小的差异，具体分析如下：</p>
<p>1.13 及以前：</p>
<ul>
<li>每 3gt 将与执行中的目标不冲突，且可以开始的新目标，添加进执行列表</li>
<li>每 1gt 清理执行列表中的目标，将不可继续的目标移出执行列表</li>
<li>每 1gt 遍历并执行执行列表中的目标</li>
</ul>
<p>1.14 及以后：</p>
<ul>
<li>每 1gt 停止不可继续执行的目标，并将它们移出执行列表</li>
<li>每 1gt 将与执行中的目标不冲突且可以开始的新目标，添加进执行列表</li>
<li>每 1gt 遍历并执行执行列表中的目标</li>
</ul>
<p>其中：</p>
<ul>
<li>目标可以开始，指的是其 <code>Goal#canStart</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> 函数返回结果为 true</li>
<li>目标不可继续，指的是其 <code>Goal#shouldContinue</code> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> 函数返回值为 false</li>
<li>目标之间不冲突，指的是目标之间对生物的 控制类型 <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup> 的集合交集为空。一个目标可以占用生物若干个控制类型，包括移动、视野、跳跃以及索敌这四种</li>
</ul>
<p>对于小黑“捡起方块”这个目标而言：</p>
<ul>
<li>只有 $1 / 20$ 的概率可以开始，因为 <code>PickUpBlockGoal#canStart</code> 这个函数仅有 $1 / 20$ 的概率返回 true</li>
<li>可以继续的概率与可以开始的概率相同</li>
<li>不占用任何控制类型</li>
</ul>
<p>可以发现，1.14 及以后的行为执行频率模型非常简易，可以直接视为每个行为每 gt 只要可以开始，那就可以执行。因此，对于小黑“捡起方块”这个目标而言，每个 gt 执行的概率都相同，等于其可开始概率 $1 / 20$</p>
<p>不过，1.13 及以前的行为执行频率模型就复杂不少了，虽然都是每 gt 都会清理 &amp; 执行目标，但添加新的目标是每 3gt 才执行一次。目标添加进执行列表后，每个 gt 都得判断它是否还能继续，这会导致小黑“捡起方块”这种概率性可继续执行的目标，执行概率指数下跌</p>
<p>如果以 3gt 为周期，那么对于小黑“捡起方块”这个目标而言，有</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>执行概率</th>
</tr>
</thead>
<tbody>
<tr>
<td>gt0</td>
<td>$(1 / 20) = 0.05$</td>
</tr>
<tr>
<td>gt1</td>
<td>$(1 / 20) * (1 / 20) ^ 1 = 2.5 * 10 ^{-3}$</td>
</tr>
<tr>
<td>gt2</td>
<td>$(1 / 20) * (1 / 20) ^ 2 = 1.25 * 10 ^{-4}$</td>
</tr>
<tr>
<td>平均值</td>
<td>$0.01754$，约 $1/57$</td>
</tr>
</tbody>
</table>
<p>是的，在 1.13-，小黑每 gt 执行“捡起方块”目标的概率仅有 $1 / 57$，与 1.14+ 的 $1 / 20$ 相比有着明显的差距，大概仅为 1.14+ 概率的 $1 / 3$。执行“捡起方块”目标并尝试捡瓜的执行概率直接影响了小黑捡起西瓜的成功率，这就是 1.13- 和 1.14+ 之间小黑瓜机概率差距大的原因之一</p>
<h3 id="瓜苗"><a class="header-anchor" href="#瓜苗"></a>瓜苗</h3>
<p>西瓜苗跟南瓜苗一样，共用着 <code>StemBlock</code> <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup> 这个类，拥有着相同的生长逻辑。下文使用瓜苗一词来指代西瓜苗及南瓜苗</p>
<p>跟其他农作物一样，瓜苗的生长速度取决于其附近湿润耕地的数量，以及附近同种作物的数量。不防令其生长速度为 $s$，$s$ 越大则生长速度越快，那么对于瓜苗，我们可以通过如下流程计算出 $s$：</p>
<ol>
<li>
<p>令 $s$ 为初值 $1$</p>
</li>
<li>
<p>统计瓜苗附近耕地的湿润值。统计瓜苗下方一格，水平方向切比雪夫距离 &lt;= 1 的耕地。对于瓜苗正下方的耕地，若为湿润，则 $s$ 增加 $3$；若为干燥，则 $s$ 增加 $1$。对于范围内其余耕地，若为湿润，则 $s$ 增加 $0.75$。如下图左半边所示</p>
<p>其中，耕地为湿润 / 干燥是由其方块状态 <code>moisture</code> 决定的，<code>moisture</code> 为 0 时耕地干燥，<code>moisture</code> 大于 0 时耕地湿润</p>
</li>
<li>
<p>统计瓜苗附近的同种作物。当以下条件任意一者满足时，将 $s$ 值除以 $2$</p>
<ul>
<li>瓜苗的南方或北方的作物（下图右侧粉圈）为同种作物，且瓜苗的东方或西方的作物（下图右侧蓝圈）为同种作物</li>
<li>瓜苗的西北、东北、东南、西南处其中之一（下图右侧黄圈）的作物是同种作物</li>
</ul>
<p>其中，同种作物指的是方块类型相同的作物，比如西瓜苗跟南瓜苗不是同种作物，西瓜苗跟土豆也不是同种作物，但生长长度 <code>age</code> 不同的西瓜苗之间是同种作物</p>
<p>值得一提，在 1.13 及以后，麻将把生长中的瓜苗和长了瓜的瓜苗拆分成了 2 个不同的方块类型，这导致西瓜苗（<code>minecraft:melon_stem</code>）和长了瓜的瓜苗（<code>minecraft:attached_melon_stem</code>）不再是同种作物，南瓜同理</p>
</li>
<li>
<p>生长速度 $s$ 计算完毕</p>
</li>
</ol>
<p><img data-src="/zh-CN/2023/endermelon-notes/crop-grow-speed.png" alt="生长速度计算流程"></p>
<p>可以这样感性地理解生长速度的计算流程：周围湿润的耕地越多，营养就越多，生长速度就越快；附近的同种作物会争抢营养，导致生长速度下降</p>
<p>同其他作物一样，触发瓜苗生长的事件是随机刻。在瓜苗方块受到随机刻作用时，如果其光照条件满足要求，那么将会有 $\frac{1}{n}$ 的概率进行一次生长。其中：</p>
<ul>
<li>光照条件要求：
<ul>
<li>1.12：瓜苗上方一格方块的亮度等级 &gt;= 9。此处亮度计算包含天空光，考虑天空光衰减</li>
<li>1.13：瓜苗上方一格方块的亮度等级 &gt;= 9。此处亮度计算包含天空光，不考虑天空光衰减</li>
<li>1.14+：瓜苗处的亮度等级 &gt;= 9。此处亮度计算包含天空光，不考虑天空光衰减</li>
</ul>
</li>
<li>$n = \left\lfloor{\frac{25}{s}}\right\rfloor + 1$，其中 $s$ 即为上文描述的生长速度</li>
</ul>
<p>瓜苗进行生长时，首先会看看它的方块状态 <code>age</code> 值是否达到了最大值 7，若未达到，则将其 <code>age</code> 值 +1，生长结束；若 <code>age</code> 已达 7，瓜苗会随机挑选一个水平毗邻的方块坐标，尝试在次数结瓜。结瓜需要满足以下条件：</p>
<ul>
<li>结瓜处为空气。瓜只能长在空气里，不能挤掉已存在的方块</li>
<li>结瓜处下方一格为泥土类型方块，包括耕地、泥土、砂土、灰化土、草方块这一类等含有 <code>dirt</code> 方块标签的方块</li>
</ul>
<p>条件满足，那么瓜苗将进行结瓜，放置瓜苗方块、长了瓜的瓜苗方块；条件不满足，那么结瓜尝试失败，不会进行重试</p>
<p>至此，瓜苗的生长流程分析完毕。下面是一个具体的例子以供参考</p>
<p><img data-src="/zh-CN/2023/endermelon-notes/crop-grow-speed-example.png" alt="生长速度计算例子"></p>
<p>上图所示的瓜苗布局中，中心瓜苗的生长速度 $s$ 以及生长概率 $\frac{1}{n}$ 的计算流程如下</p>
<ol>
<li>$s$ 赋初值 $1$</li>
<li>统计瓜苗附近耕地的湿润值，$s$ 共增加 $7$，为 $8$</li>
<li>计瓜苗附近的同种作物，$s$ 折半，为 $4$</li>
<li>$n = \left\lfloor{\frac{25}{s}}\right\rfloor + 1 = \left\lfloor{\frac{25}{4}}\right\rfloor + 1 = 6 + 1 = 7$</li>
</ol>
<p>因此，中心瓜苗在每接受一次随机刻时，有 $1/7$ 的概率进行生长。由于其已达到最大 <code>age</code> 值，因此每次生长都将尝试长瓜。</p>
<p>考虑到中心瓜苗水平毗邻的 4 个位置只有 2 个位置为空气，因此尝试长瓜时，还需 2 / 4 的概率才能长出瓜来</p>
<p>令中心瓜苗每接受一次随机刻时的长出瓜的概率为 $p$，则 $p = \frac{1}{n} * \frac{2}{4} = \frac{1}{14}$</p>
<h2 id="呱唧分析"><a class="header-anchor" href="#呱唧分析"></a>呱唧分析</h2>
<h3 id="农场结构"><a class="header-anchor" href="#农场结构"></a>农场结构</h3>
<p>无论呱唧的结构，</p>
<p>无论采取怎样的呱唧设计思路，瓜机的结构都可以分为以下 3 个部分：</p>
<ol>
<li>刷怪单元</li>
<li>捡瓜通道</li>
<li>处死模块</li>
</ol>
<p><img data-src="/zh-CN/2023/endermelon-notes/farm-architecture.png" alt="农场结构"></p>
<p>我们称一个包含上述 3 个部分的最小可运行结构，为产瓜单元。通常来说，一个产瓜单元的独立性是比较强的</p>
<h3 id="前提假设"><a class="header-anchor" href="#前提假设"></a>前提假设</h3>
<p>下文对小黑瓜机分析的重点是，瓜机的效率上限计算，并以提升瓜机效率的最大值为设计目标。不妨作出下述的前提假设：</p>
<ul>
<li>
<p>刷怪上限有限。通常而言，这个上限值为 70，对应着单玩家所能提供的刷怪上限</p>
</li>
<li>
<p>瓜机的规模足够大。本文分析的小黑瓜机设计均由多个独立的产瓜单元组成，产瓜单元之间耦合度很低，可以直接通过堆叠产瓜单元的手段来增加瓜机效率</p>
<p>虽说一味地增加瓜机体积的收益是边际递减的，但在单元数量堆叠到一定程度时，其余条件就已经很接近理想情况了</p>
</li>
<li>
<p>刷怪满上限。瓜机的规模足够大意味着刷怪面积是充足的，那么每当小黑数量降至怪物容量内时，新的小黑会很快地刷出来，继续顶满刷怪上限</p>
<ul>
<li>这意味着同时存在小黑数量的期望值等于怪物容量，即在每时每刻都存在约 70 只小黑</li>
<li>在实际情况中，考虑到过量生成的情况，同时存在的小黑数量有可能超过怪物容量</li>
</ul>
</li>
<li>
<p>瓜田接近满瓜。考虑到同时存在的小黑数量是有限的，在瓜机规模足够大时，每个产瓜单元分到的小黑流量是很低的，这会导致瓜苗长瓜的速度明显高于小黑搬瓜的速度，进而导致瓜田是处于一个接近满瓜的状态</p>
</li>
</ul>
<p>若无特殊说明，下文的分析均以上述假设为背景进行</p>
<h3 id="理论效率计算"><a class="header-anchor" href="#理论效率计算"></a>理论效率计算</h3>
<p>核心公式：</p>
<ul>
<li>瓜机产率(瓜/h) = 小黑刷怪速率(只/h) * 小黑捡瓜率(瓜/只)</li>
</ul>
<p>刷怪公式：</p>
<p>[—][—][—][—][—][—]
[—][—][—][—][—][—]
[—][—][—][—][—][—]
[—][—][—][—][—][—]
[------------ 1h -----------]</p>
<ul>
<li>小黑刷怪速率(只/h)，即每小时小黑生成数量(只) / 1 小时(h)</li>
<li>= 平均同时存在的小黑数(只) / 小黑平均存活时间(h)</li>
<li>= 平均同时存在的小黑数(只) / 小黑平均存活时间(h)</li>
<li>=</li>
<li>= 平均同时存在的小黑数(只) * 每小时游戏刻数(gt/h) / 小黑平均存活时间(gt)</li>
<li>= (72000 * 70) / 平均存活时间</li>
</ul>

\begin{align}
小黑刷怪速率 &= 每小时小黑生成数量 / 1小时 \
&= 1 小时小黑生成数量 / 1小时 \
&= 平均小黑数量 * 
&= 每小时的游戏刻数 / 存活时间 * 70
&= 72000 / 存活时间 * 70
\end{align}

<p>其中存活时间以 gt 作为单位</p>
<p>捡瓜率：</p>
<h3 id="瓜密度"><a class="header-anchor" href="#瓜密度"></a>瓜密度</h3>
<p>小黑捡方块范围内有效瓜的总体积占比</p>
<h4 id="冲突瓜"><a class="header-anchor" href="#冲突瓜"></a>冲突瓜</h4>
<p>小红文</p>
<h2 id="设计思路"><a class="header-anchor" href="#设计思路"></a>设计思路</h2>
<h3 id="基于末影螨仇恨的瓜机"><a class="header-anchor" href="#基于末影螨仇恨的瓜机"></a>基于末影螨仇恨的瓜机</h3>
<p>使用末影螨吸引小黑最大的优点为，可以在主体结构不变的情况下轻易地增加大量刷怪面积。</p>
<p>缺点：小黑发现末影螨需要时间</p>
<p>总结：性价比高，上限低。</p>
<h4 id="刷怪单元"><a class="header-anchor" href="#刷怪单元"></a>刷怪单元</h4>
<h4 id="捡瓜通道"><a class="header-anchor" href="#捡瓜通道"></a>捡瓜通道</h4>
<h4 id="处死模块"><a class="header-anchor" href="#处死模块"></a>处死模块</h4>
<h3 id="基于机械结构的瓜机"><a class="header-anchor" href="#基于机械结构的瓜机"></a>基于机械结构的瓜机</h3>
<h4 id="刷怪单元-2"><a class="header-anchor" href="#刷怪单元-2"></a>刷怪单元</h4>
<h4 id="捡瓜通道-2"><a class="header-anchor" href="#捡瓜通道-2"></a>捡瓜通道</h4>
<h4 id="处死模块-2"><a class="header-anchor" href="#处死模块-2"></a>处死模块</h4>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><code>EntityEnderman.AITakeBlock</code>（MCP）；<code>EnderMan.EndermanTakeBlockGoal</code>（mojmap） <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><code>EntityEnderman.AIPlaceBlock</code>（MCP）；<code>EnderMan.EndermanLeaveBlockGoal</code>（mojmap） <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><code>EntityAINearestAttackableTarget</code>（MCP）；<code>NearestAttackableTargetGoal</code>（mojmap） <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><code>EntityAIBase#shouldExecute</code>（MCP）；<code>Goal#canUse</code> (mojmap) <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><code>EntityAIBase#shouldContinueExecuting</code>（MCP）；<code>Goal#canContinueToUse</code> (mojmap) <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>见函数 <code>EntityAIBase#getMutexBits</code>（MCP）；枚举类 <code>Goal.Control</code>（yarn）；枚举类 <code>Goal.Flag</code>（mojmap） <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><code>BlockStem</code>（MCP）；<code>StemBlock</code>（mojmap） <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>末影人</tag>
        <tag>刷怪</tag>
      </tags>
  </entry>
  <entry>
    <title>Minecraft 1.18.2+ 中地狱堡垒的地狱砖刷怪游走问题分析</title>
    <url>/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/</url>
    <content><![CDATA[<h2 id="太长不看版结论"><a class="header-anchor" href="#太长不看版结论"></a>太长不看版结论</h2>
<p>MC 1.18.2 及以后，对于地狱堡垒内部（整个外结构范围内）的堡垒特产刷怪：</p>
<ul>
<li>首次游走结束于&quot;地狱砖&quot;上的一次成群生成，不再能刷怪至&quot;内结构非地狱砖&quot;上</li>
<li>首次游走结束于&quot;内结构非地狱砖&quot;上的一次成群生成，不再能刷怪至&quot;地狱砖&quot;上</li>
</ul>
<p>摘自我的 b 站动态：<a href="https://t.bilibili.com/925169310311120902">https://t.bilibili.com/925169310311120902</a></p>
<p>（2025.1.17 更新）此 bug 已于 1.21.5 快照 25w02a 被修复</p>
<span id="more"></span>
<h2 id="现象"><a class="header-anchor" href="#现象"></a>现象</h2>
<p>多名玩家在 b 站上表示，在 <strong>未破基岩</strong> 的环境下，对于使用十字路口的 <strong>凋灵玫瑰+泥土/草方块/地狱岩</strong> 的凋灵骷髅刷怪塔，
在 MC 某个未知版本以后，若使用地狱砖为刷怪塔建造了游走平台拓展，则其效率会下降</p>
<p>堡垒外结构 + 地狱砖能刷凋灵骷髅，这些刷怪尝试游走进刷怪平台，就应该可以提升凋灵骷髅塔的效率，但实际上效率确实下降了。乍一看，很是奇怪</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/player_reports.png" alt="相关视频/动态"></p>
<p>一些相关的 b 站动态 / 视频：</p>
<ul>
<li><a href="https://space.bilibili.com/259168987">As_One_</a> 的视频：<a href="https://www.bilibili.com/video/BV1oM4m1Q7TH/">https://www.bilibili.com/video/BV1oM4m1Q7TH/</a></li>
<li><a href="https://space.bilibili.com/349715795">-小何不是河-</a> 的动态：<a href="https://t.bilibili.com/919854760729772038">https://t.bilibili.com/919854760729772038</a></li>
<li><a href="https://space.bilibili.com/358574449">FhFhhhhh</a> 的动态：<a href="https://t.bilibili.com/919553893964185617">https://t.bilibili.com/919553893964185617</a></li>
</ul>
<h2 id="实验验证"><a class="header-anchor" href="#实验验证"></a>实验验证</h2>
<p><a href="https://space.bilibili.com/454002796">Youmiel</a> 对各个 MC 版本进行了大量测试，定位出这个问题的引入区间：1.18.1 ~ 1.18.2。</p>
<p>在 MC 1.18.1 及以前，地狱砖游走能加效率；在 MC 1.18.2 及以后，地狱砖游走反而会减效率</p>
<h3 id="测试环境"><a class="header-anchor" href="#测试环境"></a>测试环境</h3>
<p>为了方便得到测试数据，<a href="https://space.bilibili.com/454002796">Youmiel</a> 搭建了一个测试存档，环境如下：</p>
<ul>
<li>灵魂沙峡谷，空置域环境，带基岩天花板</li>
<li>单十字路口凋灵骷髅塔，3 层刷怪平台，凋灵玫瑰 + 地狱岩刷怪平台。最下层刷怪平台地板的方块 Y 坐标为 69</li>
<li>使用命令方块切换如下 3 种测试场景：
<ul>
<li>无游走平台</li>
<li>带有 5m 的普通方块（石砖）作为游走平台</li>
<li>带有 5m 的地狱砖作为游走平台</li>
</ul>
</li>
</ul>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/test_env.png" alt="测试环境"></p>
<p>存档：<a href="FortressTest-Minimal.zip">FortressTest-Minimal</a>。已授权发布。存档版本为 MC 1.16.5</p>
<h3 id="测试方式"><a class="header-anchor" href="#测试方式"></a>测试方式</h3>
<ul>
<li>使用 <a href="https://github.com/gnembon/fabric-carpet">fabric-carpet</a> 模组的 <code>/spawn tracking</code> 指令来统计凋灵骷髅的生成速率</li>
<li>每 gt 执行指令将所有凋灵骷髅 tp 出 128m，清除凋灵骷髅（存档中使用数据包实现）</li>
<li>使用存档中数据包指令 <code>/function qc:start_test</code> 开启测试：<code>/tick warp</code> 运行 180min 后，读取 <code>/spawn tracking</code> 的输出，得到测试结果</li>
</ul>
<h3 id="测试结果"><a class="header-anchor" href="#测试结果"></a>测试结果</h3>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/test_result.png" alt="测试结果"></p>
<p>可以发现，在 1.18.1 和 1.18.2 之间：</p>
<ul>
<li>无游走、普通方块游走，这两个场景之间的效率，及 1.18.1、1.18.2 两个版本间的效率，均无明显差距。实际数据的差距可认为是测试误差</li>
<li>在 1.18.1 里，地狱砖游走，比无游走、普通方块游走，效率 <strong>更高</strong>。符合以往对凋灵骷髅塔的预期</li>
<li>在 1.18.2 里，地狱砖游走，比无游走、普通方块游走，效率 <strong>跟低</strong>。不符合预期，但是与上面 <a href="#%E7%8E%B0%E8%B1%A1">现象</a> 小节的表述一致</li>
</ul>
<p><a href="#%E7%8E%B0%E8%B1%A1">现象</a> 小节中提到的神秘现象已复现成功，地狱砖制成的游走平台，会让凋灵骷髅塔的效率不升反降。这其中必有蹊跷</p>
<h3 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h3>
<p>MC 1.20.3 官方引入了 <code>/tick</code> 指令的支持，MC 1.21 对数据包结构进行了一顿改。因此，如需在 MC 1.21+ 使用这个存档，
可参考使用 <a href="FortressTest-Minimal-mc1.21.4.zip">FortressTest-Minimal-mc1.21.4</a> 这个存档</p>
<p>若需在这个版本里使用数据包里的 <code>/function qc:start_test</code> 等指令来运行测试，除了装上 fabric-carpet 外，还需要：</p>
<ol>
<li>安装 <a href="https://github.com/TISUnion/Carpet-TIS-Addition">Carpet-TIS-Addition</a> 模组，用于调整 <code>/tick</code> 指令的结构和权限需要</li>
<li>执行 <code>/carpet tickCommandCarpetfied true</code> 指令，回调 <code>/tick</code> 指令的一些机制。若在打开存档前已装好了 Carpet-TIS-Addition，则无需此操作，存档里默认已经配置好了</li>
<li>执行 <code>/reload</code> 指令，正确加载带 <code>/tick</code> 指令的那些 <code>.mcfunction</code></li>
<li>开始测试</li>
</ol>
<h2 id="分析"><a class="header-anchor" href="#分析"></a>分析</h2>
<h3 id="刷怪流程"><a class="header-anchor" href="#刷怪流程"></a>刷怪流程</h3>
<p>下面简要摘要一下自然刷怪中，刷怪循环的相关流程。注意下面流程并未包括所有实现细节，仅作为下文分析的背景。
若想要了解更多自然生成的机制，可以去看一下 <a href="https://space.bilibili.com/20649038">五羊飞kaniol</a> 的 b 站专栏 <a href="https://www.bilibili.com/read/cv8274017/">cv8274017</a></p>
<ol>
<li>对于每个区块，选取区块中的一个随机位置，作为刷怪起始点（y 的值域上界为 heightmap），并尝试 3 次刷怪</li>
<li>对于每次刷怪尝试，会从刷怪起始点开始，游走 k 次。每次游走都会将坐标水平随机偏移一定距离，然后尝试生成一只怪。这 k 次游走+刷怪也被称为&quot;成群生成&quot;</li>
<li>在 <strong>第 1 次</strong> 游走结束后，基于当前坐标所处于的群系、结构等环境信息，获取该坐标可生成的 <strong>怪物列表</strong>，并在其中挑选一个怪物种类，作为本次成群生成的目标怪物。同时成群生成的次数 k 也将于此处，基于怪物种类确认</li>
<li>在每次游走结束后，将尝试在当前坐标刷一只怪。怪物是否可生成需要进行一系列的检查
<ul>
<li>其中有一项检查是：确认将要生成的怪物种类，位于当前坐标的 <strong>怪物列表</strong> 里。这是用于避免例如史莱姆刷怪，游走刷到了史莱姆区块外面的情况</li>
</ul>
</li>
</ol>
<p>上述流程中，<strong>怪物列表</strong> 计算了 2 次：</p>
<ul>
<li>一次是在首次游走结束后，选取要刷的怪物时
<ul>
<li>函数为 <code>net.minecraft.world.SpawnHelper#pickRandomSpawnEntry</code></li>
</ul>
</li>
<li>一次是在刷怪检查过程中，确认当前要刷的怪物，是位于当前坐标的 <strong>怪物列表</strong> 里
<ul>
<li>函数为 <code>net.minecraft.world.SpawnHelper#containsSpawnEntry</code></li>
</ul>
</li>
</ul>
<p>这两次计算，都会调用 <code>SpawnHelper</code> 中的 <code>getSpawnEntries</code> 函数，来获取给定坐标的怪物列表</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/code-spawn-entries-relationships.png" alt="函数调用链"></p>
<p>在 <code>getSpawnEntries</code> 函数中，有一个对地狱堡垒的特判：</p>
<ul>
<li>若 <code>shouldUseNetherFortressSpawns</code> 函数返回 <code>true</code>，则直接返回 <code>NetherFortressStructure.MONSTER_SPAWNS</code> 属性里储存的怪物列表，即堡垒特产怪
<ul>
<li><code>shouldUseNetherFortressSpawns</code> 函数当且仅当如果满足下方 3 个条件，则认为可使用地狱堡垒的特殊结构刷怪
<ol>
<li>要刷出的实体是类型是怪物</li>
<li>当前坐标下方是地狱砖</li>
<li>当前坐标位于地狱堡垒的外结构范围</li>
</ol>
</li>
</ul>
</li>
<li>否则，调用 <code>chunkGenerator.getEntitySpawnList</code>，基于当前坐标所处的结构、当前群系，获取怪物列表
<ul>
<li>对于地狱堡垒，坐标需要位于内结构中，才可得到堡垒特产怪</li>
</ul>
</li>
</ul>
<p>这部分特判是为了，让地狱堡垒外结构的地狱砖上，也能和保留内结构一样，可以刷出堡垒特有的怪物，如凋灵骷髅、烈焰人等</p>
<p>上面几个函数的源代码如下图所示：</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/code-spawn-entries-source.png" alt="源代码"></p>
<p>这看上去没啥问题，只是 mojang 给地狱堡垒 + 地狱砖这种特殊刷怪情况搞了个特判而已。可惜，事实并非 mojang 所愿</p>
<h3 id="地狱堡垒怪物"><a class="header-anchor" href="#地狱堡垒怪物"></a>地狱堡垒怪物</h3>
<p>基于上文 <a href="#%E5%88%B7%E6%80%AA%E6%B5%81%E7%A8%8B">刷怪流程</a> 小节的分析，地狱堡垒的刷怪列表，有以下两种可能的取值来源</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>地狱堡垒中的位置</th>
<th>条件</th>
<th>怪物列表取值来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>外结构</td>
<td>地狱砖上方</td>
<td><code>NetherFortressStructure.MONSTER_SPAWNS</code></td>
</tr>
<tr>
<td>B</td>
<td>内结构</td>
<td>非地狱砖上方</td>
<td><code>chunkGenerator.getEntitySpawnList()</code></td>
</tr>
</tbody>
</table>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/fortress-bounding-box.png" alt="内结构/外结构示意"></p>
<p>具体的：</p>
<ul>
<li>来源 A：直接为 <code>NetherFortressFeature.MONSTER_SPAWNS</code> 的值</li>
<li>来源 B：从 <code>world.getRegistryManager()</code> 中取得。而其中的 registry 数据，是在载入世界时，
对包含 <code>NetherFortressFeature.MONSTER_SPAWNS</code> 的 <code>BuiltinRegistries.DYNAMIC_REGISTRY_MANAGER</code>进行深拷贝（序列化 + 反序列化）后得到的。
总而言之，来源 B 的返回值，是来源 A 的列表的深拷贝</li>
</ul>
<p>再回到 <code>containsSpawnEntry</code> 函数里，就能发现有些不对劲了</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/code-containsSpawnEntry-contains.png" alt="List#contains"></p>
<p>mojang 在这里使用了 java 的 <code>List#contains</code> 方法，来判断给定的刷怪类型是否位于当前坐标的刷怪列表中，这便是问题所在：
列表储存的元素类型 <code>SpawnSettings.SpawnEntry</code> 并没有实现 <code>equals</code> 方法，这将导致只有引用相等的元素才能返回 <code>true</code></p>
<p>举个例子，如果用来源 A 的元素 <code>entry</code> 来询问来源 B 的列表 <code>list</code>，那 <code>list.contains(entry)</code> 就会返回 <code>false</code>。
于是，<code>containsSpawnEntry</code> 函数也会返回 <code>false</code>，刷怪尝试便因此失败</p>
<h3 id="问题引入"><a class="header-anchor" href="#问题引入"></a>问题引入</h3>
<p>捋一下与这个 bug 有关的相关变更节点，都是 1.18.2 的快照</p>
<ol>
<li><a href="https://www.minecraft.net/en-us/article/minecraft-snapshot-22w06a">22w06a</a>，
创建 world 的 <code>DynamicRegistryManager</code> 时，引入了序列化+反序列化的方式，对 registry 数据进行了深拷贝</li>
<li><a href="https://www.minecraft.net/en-us/article/minecraft-1-18-2-pre-release-1">1.18.2-pre1</a>，
不再直接用 if 链来计算各种结构的刷怪列表，而将其交由数据驱动的 registry 系统管理。从此开始，来源 B 返回的列表，便成了来源 A 的深拷贝</li>
</ol>
<p>注意，1.18.2-pre1 和 1.18.2-pre2 存在与结构刷怪相关的 bug（如 <a href="https://bugs.mojang.com/browse/MC-248717">MC-248717</a>），
因此，若在这些版本进行测试，将会得到与 1.18.1、1.18.2 均不相同的数据。1.18.2-pre3 及以后的表现，才和 1.18.2 及以后一致</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/test_result_full.png" alt="测试结果-带预览版"></p>
<p>上图效率的一些简单解释</p>
<ul>
<li>1.18.1：地狱砖游走进刷怪平台正常刷怪，效率上升</li>
<li>1.18.2-pre1：判定过程中外结构就是内结构，哪里都能刷堡垒怪，且刷怪列表来源都是上文的来源 B，因此无游走/非地狱砖游走的效率上升至有地狱砖游走水平</li>
<li>1.18.2-pre2：判定过程中不存在外结构，因此地狱砖游走平台不影响刷怪平台，3 种场景效率都一样</li>
<li>1.18.2-pre3：外结构/内结构的判定正常了，地狱砖游走进刷怪平台无法刷怪，效率下降</li>
<li>1.18.2：同 1.18.2-pre3</li>
</ul>
<h2 id="结论"><a class="header-anchor" href="#结论"></a>结论</h2>
<h3 id="直接结论"><a class="header-anchor" href="#直接结论"></a>直接结论</h3>
<p>在 MC 1.18.2 后，对于地狱堡垒内部（整个外结构范围内）的堡垒特产刷怪：</p>
<ul>
<li>首次游走结束于&quot;地狱砖&quot;上的一次成群生成，不再能刷怪至&quot;内结构非地狱砖&quot;上</li>
<li>首次游走结束于&quot;内结构非地狱砖&quot;上的一次成群生成，不再能刷怪至&quot;地狱砖&quot;上</li>
</ul>
<p>换而言之：</p>
<ul>
<li>首次游走结束于&quot;地狱砖&quot;上的一次成群生成，只能把怪刷在&quot;地狱砖&quot;上</li>
<li>首次游走结束于&quot;内结构非地狱砖&quot;上的一次成群生成，只能把怪刷在&quot;内结构非地狱砖&quot;上</li>
</ul>
<p>地狱砖地板、非地狱砖地板，这两类地板间再无互利共赢的关系。一道不可逾越的鸿沟已经产生了</p>
<p>这种现象，如果要起个名字的话，不妨称之为“地狱砖隔离性”？</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/spawning-attempt-isolation.png" alt="地狱砖隔离性"></p>
<h3 id="现象分析"><a class="header-anchor" href="#现象分析"></a>现象分析</h3>
<p>回到最开始，那些游走表现“奇怪”的凋灵骷髅塔，即符合如下条件的，常见的那种凋灵玫瑰十字路口设计：</p>
<ul>
<li>基岩天花板完好</li>
<li>使用堡垒十字路口这一内结构</li>
<li>刷怪平台地板使用泥土、草方块、地狱岩等 <strong>非地狱砖</strong> 的方块</li>
</ul>
<p>对于这一类凋灵骷髅塔，有：</p>
<ul>
<li>基岩天花板的存在，使游走平台不会提供拉高 heightmap 的效果。</li>
<li>刷怪平台位于内结构，地板非地狱砖，因此要想怪物能刷在这个刷怪平台上，刷怪的那次成群生成的首次游走，必须结束于同样的非地狱砖上</li>
<li>若游走平台由地狱砖组成，则首次游走结束于这些地狱砖上的成群生成，将无法把怪刷在刷怪平台上
<ul>
<li>无游走相比地狱砖游走平台，多出来的那些效率，由与十字路口相接的其他堡垒内结构提供。毕竟只有内结构才能让非地狱砖上也能出堡垒怪
<ul>
<li>可构造一个这样的游走平台：平台位于内结构的部分用非地狱砖（如石头），其他部分用地狱砖。该场景效率将与全石头游走平台的效率一致（已实验验证）
<img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/spawn_platform_mixed.png" alt="混合游走平台"></li>
</ul>
</li>
<li>如果十字路口不与任何堡垒内结构相接，则不管游走平台是否存在，游走平台地板是什么，基岩天花板是否存在，效率都是一样的</li>
</ul>
</li>
</ul>
<h3 id="推论"><a class="header-anchor" href="#推论"></a>推论</h3>
<p>在 MC 1.18.2 及以后，建造地狱堡垒怪物的刷怪塔时（如凋灵骷髅塔、烈焰人塔），在 heightmap 环境相同时，需要注意：</p>
<ul>
<li>若刷怪平台的地板使用了非地狱砖，那游走平台就不能用地狱砖
<ul>
<li>如非更新抑制换地板的，凋灵玫瑰凋灵骷髅塔</li>
<li>只能用非地狱砖作为地板，也意味着只能利用内结构</li>
</ul>
</li>
<li>若刷怪平台的地板使用了地狱砖，则游走平台的地板也得是地狱砖
<ul>
<li>如利用地狱堡垒外结构的凋灵骷髅塔、烈焰人塔</li>
</ul>
</li>
<li>对于常见的十字路口凋灵骷髅塔，不能用地狱砖来做游走平台。与十字路口相接的内结构面积越大，可利用的游走面积也越大，这种凋灵骷髅塔效率就越高</li>
</ul>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/spawn_platform.png" alt="刷怪平台-游走平台"></p>
<h3 id="反馈"><a class="header-anchor" href="#反馈"></a>反馈</h3>
<p>本文所述问题已提交至 mojang 的 bug tracker：<a href="https://bugs.mojang.com/browse/MC-271630">MC-271630</a></p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/mc-271630.png" alt="MC-271630"></p>
<p>和以往一样，如果你想要在这个 bug report 下发表评论，请确保是在发表有价值有意义的评论。不要在评论区无意义灌水</p>
<h2 id="修复"><a class="header-anchor" href="#修复"></a>修复</h2>
<p>此 bug 已于 1.21.5 的快照 25w02a 被修复。不过由于另一个 bug <a href="https://bugs.mojang.com/browse/MC-279245">MC-279245</a>，这一修复得到 25w03a 才可被观察到</p>
<p>具体修法，25w02a 里 <code>SpawnEntry</code> 类变成了一个 record 类，因此自动获得了一个实现正确的 <code>equals</code> 方法，就酱。估计是麻将对游戏做日常的数据驱动改造时，随手改的 record 类</p>
<p><img data-src="/zh-CN/2024/fortress-nether-bricks-pack-spawning-issue-1182/test_result_with_fix.png" alt="测试结果-修复"></p>
<p>若想在低版本也把这个 bug 干掉，可以使用 <a href="https://github.com/TISUnion/Carpet-TIS-Addition">Carpet-TIS-Addition</a> 模组的
<a href="https://carpet.tis.world/zh-Hans/docs/rules#%E5%9C%B0%E7%8B%B1%E5%A0%A1%E5%9E%92%E5%9C%B0%E7%8B%B1%E7%A0%96%E5%88%B7%E6%80%AA%E6%B8%B8%E8%B5%B0%E4%BF%AE%E5%A4%8D-fortressnetherbrickspackspawningfix">地狱堡垒地狱砖刷怪游走修复 (fortressNetherBricksPackSpawningFix)</a>
规则来进行修复</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<h3 id="反混淆映射对照表"><a class="header-anchor" href="#反混淆映射对照表"></a>反混淆映射对照表</h3>
<p>如果你使用的反混淆表是 mojang mapping 的话，下面是本文出现过的函数/方法/对象的对照关系，可供参考</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>Yarn mapping (MC 1.20.6 build.1)</th>
<th>Mojang mapping  (MC 1.20.6)</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td><code>net.minecraft.registry.DynamicRegistryManager</code></td>
<td><code>net.minecraft.core.RegistryAccess</code></td>
</tr>
<tr>
<td>类</td>
<td><code>net.minecraft.util.collection.Pool</code></td>
<td><code>net.minecraft.util.random.WeightedRandomList</code></td>
</tr>
<tr>
<td>类</td>
<td><code>net.minecraft.world.biome.SpawnSettings.SpawnEntry</code></td>
<td><code>net.minecraft.world.level.biome.MobSpawnSettings.SpawnerData</code></td>
</tr>
<tr>
<td>方法</td>
<td><code>net.minecraft.world.SpawnHelper#pickRandomSpawnEntry</code></td>
<td><code>net.minecraft.world.level.NaturalSpawner#getRandomSpawnMobAt</code></td>
</tr>
<tr>
<td>方法</td>
<td><code>net.minecraft.world.SpawnHelper#containsSpawnEntry</code></td>
<td><code>net.minecraft.world.level.NaturalSpawner#canSpawnMobAt</code></td>
</tr>
<tr>
<td>方法</td>
<td><code>net.minecraft.world.SpawnHelper#getSpawnEntries</code></td>
<td><code>net.minecraft.world.level.NaturalSpawner#mobsAt</code></td>
</tr>
<tr>
<td>方法</td>
<td><code>net.minecraft.world.SpawnHelper#shouldUseNetherFortressSpawns</code></td>
<td><code>net.minecraft.world.level.NaturalSpawner#isInNetherFortressBounds</code></td>
</tr>
<tr>
<td>方法</td>
<td><code>net.minecraft.world.World#getRegistryManager</code></td>
<td><code>net.minecraft.world.level.Level#registryAccess</code></td>
</tr>
<tr>
<td>方法</td>
<td><code>net.minecraft.world.gen.chunk.ChunkGenerator#getEntitySpawnList</code></td>
<td><code>net.minecraft.world.level.chunk.ChunkGenerator#getMobsAt</code></td>
</tr>
<tr>
<td>属性</td>
<td><code>net.minecraft.world.gen.structure.NetherFortressStructure#MONSTER_SPAWNS</code></td>
<td><code>net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure#FORTRESS_ENEMIES</code></td>
</tr>
</tbody>
</table>
<h3 id="代码"><a class="header-anchor" href="#代码"></a>代码</h3>
<p>数据作图脚本：<a href="https://gist.github.com/Fallen-Breath/da87d76df3b5012ef1d93626dca96233">https://gist.github.com/Fallen-Breath/da87d76df3b5012ef1d93626dca96233</a></p>
]]></content>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title>Carpet TIS Addition 介绍：索引</title>
    <url>/zh-CN/2022/introduction-to-carpet-tis-addition/</url>
    <content><![CDATA[<p>Carpet TIS Addition 介绍相关系列文章的索引</p>
<span id="more"></span>
<h2 id="索引"><a class="header-anchor" href="#索引"></a>索引</h2>
<ul>
<li>规则：《<a href="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/" title="Carpet TIS Addition 介绍：规则">Carpet TIS Addition 介绍：规则</a>》</li>
<li>记录器：<em>TODO</em></li>
<li>指令：<em>TODO</em></li>
<li>杂项：<em>TODO</em></li>
</ul>
<p>Carpet TIS Addition 相关链接：</p>
<ul>
<li><a href="https://github.com/TISUnion/Carpet-TIS-Addition">Github 仓库</a>
<ul>
<li><a href="https://github.com/TISUnion/Carpet-TIS-Addition/blob/master/README_CN.md">中文文档</a></li>
</ul>
</li>
<li><a href="https://www.curseforge.com/minecraft/mc-mods/carpet-tis-addition">CurseForge 页面</a></li>
<li><a href="https://modrinth.com/mod/carpet-tis-addition">Modrinth 页面</a></li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Carpet TIS Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>Carpet TIS Addition 介绍：规则</title>
    <url>/zh-CN/2022/introduction-to-carpet-tis-addition_rules/</url>
    <content><![CDATA[<p>索引页：<a href="/zh-CN/2022/introduction-to-carpet-tis-addition/" title="Carpet TIS Addition 介绍：索引">Carpet TIS Addition 介绍：索引</a></p>
<h1 id="Carpet-TIS-Addition-介绍：规则"><a class="header-anchor" href="#Carpet-TIS-Addition-介绍：规则"></a>Carpet TIS Addition 介绍：规则</h1>
<p>作为一个地毯 mod 扩展，Carpet TIS Addition （也称为 TIS Carpet）自然拥有着大量的可用于操控游戏特性的规则（截止至 v1.47 版本，共含有 94 个的规则），
它们可以通过指令 <code>/carpet &lt;规则名&gt; &lt;规则值&gt;</code> 来使用。在默认情况下，所有的规则均为关闭状态，以保证服务端的原版性以及对性能的零额外开销</p>
<p>这一系列的规则大部分是用于增强创造模式游戏体验的，包括对游戏特性的控制、修改和开关等。除此之外还有不少为生存模式添加的有意思的机制、bug 修复，以及一些对游戏的优化</p>
<p>下文将按照这些规则的类别，按照字母顺序，对他们进行详细的介绍。在zhao叙chao述规则简介的同时，我还会写下这些规则的设计意图、常见用途、注意事项，以及背后隐藏着的游戏机制</p>
<span id="more"></span>
<p>Carpet TIS Addition 相关链接：</p>
<ul>
<li><a href="https://github.com/TISUnion/Carpet-TIS-Addition">Github 仓库</a>
<ul>
<li><a href="https://github.com/TISUnion/Carpet-TIS-Addition/blob/master/README_CN.md">中文文档</a></li>
</ul>
</li>
<li><a href="https://www.curseforge.com/minecraft/mc-mods/carpet-tis-addition">CurseForge 页面</a></li>
<li><a href="https://modrinth.com/mod/carpet-tis-addition">Modrinth 页面</a></li>
</ul>
<hr>
<h2 id="创造模式用新增机制"><a class="header-anchor" href="#创造模式用新增机制"></a>创造模式用新增机制</h2>
<p>这一系列规则添加了为创造模式设计的新功能/新机制，能有效地提升创造模式下的游戏体验</p>
<h3 id="方块放置忽略实体-blockPlacementIgnoreEntity"><a class="header-anchor" href="#方块放置忽略实体-blockPlacementIgnoreEntity"></a>方块放置忽略实体 (blockPlacementIgnoreEntity)</h3>
<blockquote>
<p>方块可放置时无视实体碰撞检测，也就是你可以将方块放在实体内，仅对创造模式玩家有效</p>
</blockquote>
<p>在设计各种包含实体的机器，遇到比如盔甲架开盒检测合成站、漏斗矿车藏方块等情况的时候，容易出现需要在实体碰撞箱范围内放置方块的情况，
但原版又不允许玩家在实体碰撞箱中放方块，因此就可以借助这条规则进行绕过</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/blockPlacementIgnoreEntity.gif" alt="blockPlacementIgnoreEntity"></p>
<h3 id="创造玩家强制打开容器-creativeOpenContainerForcibly"><a class="header-anchor" href="#创造玩家强制打开容器-creativeOpenContainerForcibly"></a>创造玩家强制打开容器 (creativeOpenContainerForcibly)</h3>
<blockquote>
<p>允许创造模式的玩家打开被阻挡的容器，如潜影盒</p>
</blockquote>
<p>在设计如打包机等机器时，经常需要查看并操控其中的潜影盒，但打包机的潜影盒往往会被一些实体方块所阻挡。借助这条规则，创造模式玩家可以无视其上方的方块，强行打开这种被阻挡的潜影盒。</p>
<p>除了潜影盒外，被阻挡的箱子末影箱等也可以被创造模式强制打开</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/creativeOpenContainerForcibly.gif" alt="creativeOpenContainerForcibly"></p>
<h3 id="发射器不消耗物品-dispenserNoItemCost"><a class="header-anchor" href="#发射器不消耗物品-dispenserNoItemCost"></a>发射器不消耗物品 (dispenserNoItemCost)</h3>
<blockquote>
<p>开启后，发射器和投掷器使用被激活时不再消耗物品。无论投掷物品还是使用物品都如此，但是投掷器传输物品仍会消耗物品</p>
</blockquote>
<p>当你需要测试基于发射器/投掷器的机器，但又不想做补货模块的话，可以用这条规则来让发射器/投掷器不消耗物品</p>
<p>不过由于这条规则会对所有发射器/投掷器造成影响，如果可行的话建议使用规则“漏斗不消耗物品”替代</p>
<h3 id="enchant指令约束移除-enchantCommandNoRestriction"><a class="header-anchor" href="#enchant指令约束移除-enchantCommandNoRestriction"></a>enchant指令约束移除 (enchantCommandNoRestriction)</h3>
<blockquote>
<p>移除 <code>/enchant</code> 指令中所有对目标附魔的约束</p>
</blockquote>
<p>包括附魔与物品的匹配性检查、附魔间的冲突检查、附魔重复检查、附魔等级上限检查。</p>
<h3 id="实体放置无视碰撞-entityPlacementIgnoreCollision"><a class="header-anchor" href="#实体放置无视碰撞-entityPlacementIgnoreCollision"></a>实体放置无视碰撞 (entityPlacementIgnoreCollision)</h3>
<blockquote>
<p>在使用物品放置实体时禁用相关的方块与实体的碰撞检测。受影响的物品：盔甲架、末影水晶、所有种类的船。刷怪蛋物品不在作用范围内</p>
</blockquote>
<p>类似规则“方块放置忽略实体”，不过这次针对的是实体的放置</p>
<h3 id="方块状态解析忽略失败-failSoftBlockStateParsing"><a class="header-anchor" href="#方块状态解析忽略失败-failSoftBlockStateParsing"></a>方块状态解析忽略失败 (failSoftBlockStateParsing)</h3>
<blockquote>
<p>忽略在 <code>/setblock</code> 等指令的方块状态参数中出现的无效键/值参数。原版中这些无效的键/值会导致指令解析出错。这条规则抑制了这一出错，有助于跨版本粘贴 litematica 原理图等</p>
</blockquote>
<p>例如，在 mc 1.14 中音符盒添加了铁木琴音色，在音符盒放置于铁块上时其方块状态 <code>instrument</code> 的值将被设置为 <code>iron_xylophone</code>。
如果使用投影将这一方块粘贴至 mc 1.13 中，会由于该方块状态无法被解析而导致对应的 <code>/setblock</code> 指令出错，导致位于铁块上的音符盒无法被放置。
如果启用本条规则，那么该音符盒将会使用默认的 <code>instrument</code> 方块状态正常地由 <code>/setblock</code> 指令放置</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/failSoftBlockStateParsing.gif" alt="failSoftBlockStateParsing"></p>
<h3 id="fill指令模式增强-fillCommandModeEnhance"><a class="header-anchor" href="#fill指令模式增强-fillCommandModeEnhance"></a>fill指令模式增强 (fillCommandModeEnhance)</h3>
<blockquote>
<p>增加 <code>/fill</code> 指令中各种模式的功能：增加 <code>softreplace</code> 模式: 尽可能地保留原方块的方块状态，可用于替换楼梯/半砖的材质等</p>
</blockquote>
<p>指令例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/fill ~ ~ ~ ~<span class="number">10</span> ~<span class="number">10</span> ~<span class="number">10</span> minecraft:stone_brick_stairs softreplace minecraft:oak_stairs</span><br></pre></td></tr></table></figure>
<p>这个指令会将范围内的所有橡木楼梯替换成石砖楼梯，并保留楼梯的方块状态</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/fillCommandModeEnhance.jpg" alt="fillCommandModeEnhance"></p>
<p>技术上来讲，该功能并不关心新旧方块的种类是什么，它只管确保那些新旧方块均拥有的方块状态，在 <code>/fill</code> 前后保持不变。
举个例子，在侦测器 / 活塞 / 末地烛三者相互 <code>softreplace</code> 时，它们的“朝向”（<code>facing</code>）方块状态将会保持不变</p>
<h3 id="禁用流体破坏-fluidDestructionDisabled"><a class="header-anchor" href="#禁用流体破坏-fluidDestructionDisabled"></a>禁用流体破坏 (fluidDestructionDisabled)</h3>
<blockquote>
<p>禁用流体流动造成的方块破坏，包括水和岩浆。此时流体会简单地停留在即将破坏方块时的状态</p>
</blockquote>
<p>在设计包含流体的机器/建筑时，比如带有水道的机器，很容易有意无意地破坏了水道导致漏水，然后把电路装饰方块冲坏。
借助这条规则，把流体破坏关掉后，就可以大胆地修改与流体相关的部件，随便漏水，完全不需要担心流体冲坏东西了</p>
<p>不过还是得小心水固化混凝土、岩浆点着地毯等情况，这些情况是本条规则无法阻止的</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/fluidDestructionDisabled.gif" alt="fluidDestructionDisabled"></p>
<h3 id="漏斗计数器无限速度-hopperCountersUnlimitedSpeed"><a class="header-anchor" href="#漏斗计数器无限速度-hopperCountersUnlimitedSpeed"></a>漏斗计数器无限速度 (hopperCountersUnlimitedSpeed)</h3>
<blockquote>
<p>当漏斗指向羊毛方块时，漏斗将拥有无限的物品吸取以及传输速度，且无冷却时间</p>
<p>仅当 Carpet Mod 中的规则 <code>hopperCounters</code> 开启时有效</p>
</blockquote>
<p>作为一个漏斗计数器，这个漏斗就别在拘束于原版一次一组的吸物品速度，也别 8gt 才工作一次了，来点无限的吸物品速度，来多少物品就吸多少物品。
借此，对于需要用到漏斗计数器的时候，一个漏斗 + 一个羊毛即可处理干净所有来到的物品，不需要担心出现机器产率过高，漏斗吸不过来的情况</p>
<p>实际的代码实现中，作为漏斗计数器的漏斗会尝试传输 32767 次，以防止在与其他 mod 冲突时无限死循环吸物品</p>
<h3 id="漏斗不消耗物品-hopperNoItemCost"><a class="header-anchor" href="#漏斗不消耗物品-hopperNoItemCost"></a>漏斗不消耗物品 (hopperNoItemCost)</h3>
<blockquote>
<p>上方放有羊毛方块的漏斗可不消耗物品地无限输出储存的物品</p>
</blockquote>
<p>谁不想要一个可以无限输出物品的漏斗呢？</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/hopperNoItemCost.gif" alt="hopperNoItemCost"></p>
<h3 id="瞬时命令方块-instantCommandBlock"><a class="header-anchor" href="#瞬时命令方块-instantCommandBlock"></a>瞬时命令方块 (instantCommandBlock)</h3>
<blockquote>
<p>令位于红石矿上的命令方块瞬间执行命令，而不是添加一个 1gt 的计划刻事件用于执行。仅影响普通命令方块</p>
</blockquote>
<p>在原版中，脉冲型命令方块接收到红石信号时并非是瞬间执行所储存的命令的，而是添加一个延迟为 1gt 的计划刻事件，然后在该计划刻事件中执行命令，这会影响我们一些与微时序紧密相关的操作</p>
<p>该规则移除了这一延迟，让位于红石矿上方的命令方块在受激活的瞬间执行命令</p>
<p>除此之外，原版的命令方块有着每 gt 只能执行最多一次指令的限制。这一限制也被该规则移除了，当然只对红石矿上方的命令方块有效</p>
<h3 id="微时序-microTiming"><a class="header-anchor" href="#微时序-microTiming"></a>微时序 (microTiming)</h3>
<p>微时序记录器的的总开关。微时序记录器相关介绍较长，本篇文章不进行叙述</p>
<h3 id="微时序染料记号-microTimingDyeMarker"><a class="header-anchor" href="#微时序染料记号-microTimingDyeMarker"></a>微时序染料记号 (microTimingDyeMarker)</h3>
<blockquote>
<p>允许玩家手持染料右击方块来将其标记为微时序监视器的目标</p>
</blockquote>
<p>微时序记录器的染料记号功能的开关。微时序记录器相关介绍较长，本篇文章不进行叙述</p>
<h3 id="微时序目标-microTimingTarget"><a class="header-anchor" href="#微时序目标-microTimingTarget"></a>微时序目标 (microTimingTarget)</h3>
<blockquote>
<p>设置指定微时序记录器记录目标的方法</p>
<ul>
<li><code>labelled</code>: 记录被羊毛块标记的事件</li>
<li><code>in_range</code>: 记录离任意玩家 32m</li>
<li><code>all</code>: 记录所有事件。<strong>谨慎使用</strong></li>
<li><code>marker_only</code>: 仅记录被染料记号标记的方块。将其与规则 <code>microTimingDyeMarker</code>  一起使用</li>
</ul>
</blockquote>
<p>指定微时序记录器该记录哪些目标。如果能确保客户端均有 carpet 的话，可以选择 <code>marker_only</code>，让玩家都用染料记号来标记目标</p>
<h3 id="微时序游戏刻划分-microTimingTickDivision"><a class="header-anchor" href="#微时序游戏刻划分-microTimingTickDivision"></a>微时序游戏刻划分 (microTimingTickDivision)</h3>
<blockquote>
<p>设置指定微时序记录器划分两个游戏刻的方法</p>
<ul>
<li>world_timer: 划分于世界计时器自增时</li>
<li>player_action: 划分于玩家操作阶段开始前</li>
</ul>
</blockquote>
<p>国内外玩家微时序相关的模型在游戏刻的划分上有着不小差别：</p>
<ul>
<li>国内玩家将世界计时器自增时刻作为游戏刻的划分点，优势是计划刻元件的延迟可以跟游戏刻完全对应上，缺点是跨维度分析时序/分析非主世界其他游戏阶段时序时会比较困难</li>
<li>国外玩家将游戏代码中完整的一次循环作为一个游戏刻的范围，优势是游戏刻能跟服务端的 tick 计数器完美匹配，面对多维度时序分析时也轻而易举，不过缺点需要对玩家操作等阶段触发的计划刻元件的延迟减少作特殊解释处理</li>
</ul>
<p>该规则则作为一种为微时序记录器切换两种游戏刻模型的方式</p>
<h3 id="精准实体放置-preciseEntityPlacement"><a class="header-anchor" href="#精准实体放置-preciseEntityPlacement"></a>精准实体放置 (preciseEntityPlacement)</h3>
<blockquote>
<p>当使用物品放置/召唤实体时，将实体准确地放置在玩家指针指向的坐标点。受影响的物品：刷怪蛋、盔甲架、末影水晶</p>
</blockquote>
<p>可以配合 <code>entityPlacementIgnoreCollision</code> 一起使用，达到快速放置合成站的盔甲架的效果</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/preciseEntityPlacement.gif" alt="preciseEntityPlacement"></p>
<h3 id="中继器延迟折半-repeaterHalfDelay"><a class="header-anchor" href="#中继器延迟折半-repeaterHalfDelay"></a>中继器延迟折半 (repeaterHalfDelay)</h3>
<p>当红石中继器位于红石矿上方时，红石中继器的延迟将减半。延迟将会由 2, 4, 6, 8 游戏刻变为 1, 2, 3, 4 游戏刻</p>
<p>需要 1gt 或者奇数 gt 的延迟，或者想要逐 gt 地调整电路延迟看看效果，但又懒得用原版电路实现，怎么办？启用这一条规则，把中继器放在红石矿上，完事！</p>
<h3 id="红石粉随机更新顺序-redstoneDustRandomUpdateOrder"><a class="header-anchor" href="#红石粉随机更新顺序-redstoneDustRandomUpdateOrder"></a>红石粉随机更新顺序 (redstoneDustRandomUpdateOrder)</h3>
<blockquote>
<p>随机化红石粉发出方块更新的顺序，有助于测试你的装置是否依赖于位置。在规则 <code>fastRedstoneDust</code> 启用时无效</p>
</blockquote>
<p>一个简单快捷的方式，用于测试你的红石粉飞线是否具有位置依赖性</p>
<p>由于该规则的实现为随机打乱红石粉发出更新的顺序，与真实情况下出现的依赖位置是“随机”是有区别的。
你可以视为该规则随机出更新顺序集合是真实情况更新顺序集合的超集，也就是能在该规则启用下稳定正常工作的机器一定能不会在真实情况中出现问题，
但在该规则启用下可能出错的机器不一定会在真实情况中出现问题，或者在真实情况下出现问题的概率极低</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/redstoneDustRandomUpdateOrder.gif" alt="redstoneDustRandomUpdateOrder"></p>
<h3 id="同步服务端mspt指标数据-syncServerMsptMetricsData"><a class="header-anchor" href="#同步服务端mspt指标数据-syncServerMsptMetricsData"></a>同步服务端mspt指标数据 (syncServerMsptMetricsData)</h3>
<blockquote>
<p>向客户端同步服务端的 mspt 指标数据，借此，玩家可使用 F3 + ALT 在调试界面中看到这一服务端的指标。需要在客户端中安装 Carpet TIS Addition 模组</p>
</blockquote>
<p>单人游戏的 F3 调试界面中，右下角的那个显示 mspt 的图表可是个好东西。可惜在原版里，多人游戏中用不了这个功能</p>
<p>这条规则的功能即为让调试界面的 mspt 显示功能在多人游戏中也能用，也即让服务端把它的 mspt 数据同步给客户端，进而在客户端显示相关数据</p>
<p>由于需要进行服务端与客户端之间的网络通讯，本规则依赖规则 <code>tiscmNetworkProtocol</code></p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/syncServerMsptMetricsData.png" alt="syncServerMsptMetricsData"></p>
<h3 id="TISCM网络协议-tiscmNetworkProtocol"><a class="header-anchor" href="#TISCM网络协议-tiscmNetworkProtocol"></a>TISCM网络协议 (tiscmNetworkProtocol)</h3>
<blockquote>
<p>TISCM 网络协议的开关</p>
</blockquote>
<p>作为一个总开关，这条规则可以一键让所有用了 TISCM 网络协议的规则失效，让 MC 的网络层面上回归原版表现</p>
<p>当然，这条规则默认值是 <code>false</code>，因此你需要把它设置为 <code>true</code> 来使得用了 TISCM 网络协议的规则生效</p>
<p>可以使用指令 <code>/carpet list TISCM_protocol</code> 来列出所有使用了 TISCM 网络协议的规则</p>
<h2 id="创造模式用游戏修改"><a class="header-anchor" href="#创造模式用游戏修改"></a>创造模式用游戏修改</h2>
<p>为创造模式设计的，对游戏参数/行为的更改，让你更好的控制 Minecraft</p>
<h3 id="方块事件广播范围-blockEventPacketRange"><a class="header-anchor" href="#方块事件广播范围-blockEventPacketRange"></a>方块事件广播范围 (blockEventPacketRange)</h3>
<blockquote>
<p>设置会在方块事件成功执行后收到数据包的玩家范围。对于活塞而言，这一个数据包用于显示活塞的运动。把这个值调小以减小客户端卡顿</p>
</blockquote>
<p>在服务端成功执行一次方块事件时，服务端将会把这一方块事件广播给 64m 范围内的玩家。对于活塞而言，这一广播的方块事件数据包将触发客户端为活塞添加方块事件，
随即计算活塞的推拉并借助客户端的 b36 方块实体显示活塞的移动动画。本规则的用途即为修改 64m 这一常量</p>
<p>如果你在调试一些有着大量活塞运行导致客户端帧率很低的机器，你可以将这个值调低，降低活塞动画的范围，提升帧数</p>
<p>如果你想要录制机器的运行，如使用 replay mod，你可以将这个值调高，这样离玩家很远的活塞动画也不会丢失</p>
<p>该功能与 g4mespeed 的 Block Event Distance 设置相同。若本规则的值有修改，g4mespeed 所设值将被覆盖；否则 g4mespeed 的值将会被使用</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/blockEventPacketRange.gif" alt="blockEventPacketRange"></p>
<p>p.s. 本规则是 Carpet TIS Addition 的第一条规则</p>
<h3 id="炼药锅方块类物品交互修复-cauldronBlockItemInteractFix"><a class="header-anchor" href="#炼药锅方块类物品交互修复-cauldronBlockItemInteractFix"></a>炼药锅方块类物品交互修复 (cauldronBlockItemInteractFix)</h3>
<blockquote>
<p>让玩家可以对着填充有水的炼药锅放置方块。仅对 Minecraft &lt;= 1.16.x 有效。这个烦人的机制已经在 1.17+ 中被修复了</p>
</blockquote>
<p>麻将的奇怪脑回路在为了处理有水炼药锅为潜影盒去色的逻辑时，直接影响了非潜影盒的方块类物品的放置，导致玩家需要按住 shift 才可在炼药锅旁放方块。这当然不能忍，用这条规则给我修！</p>
<h3 id="区块更新数据包阈值-chunkUpdatePacketThreshold"><a class="header-anchor" href="#区块更新数据包阈值-chunkUpdatePacketThreshold"></a>区块更新数据包阈值 (chunkUpdatePacketThreshold)</h3>
<blockquote>
<p>如果方块变化的数量大于这个阈值，则游戏将仅发送区块更新数据包而非若干个方块变更数据包。增加该数值或许可以减小网络带宽用量，并在子区段同时存在不少方块实体与方块变化时提升客户端的帧数</p>
<p>将其设为非常高以模拟1.16+的表现，也就是不存在区块更新数据包，仅有多个方块变更数据包。<strong>该规则仅于1.16前的版本有效</strong></p>
</blockquote>
<p>大型机器运行时客户端的卡顿源之一，为区块重建，而区块重建是因由服务端发送的区块数据包（yarn 名 <code>ChunkDataS2CPacket</code>）引起的</p>
<p>在区块刻阶段前后（是前是后根据游戏版本决定，在此不重要），服务端会将每个区块中这一 gt 内发生的方块变化同步至客户端。
在 1.16 前，当一个区块中发生的方块变化数量超过 64 时，服务端将把整个区块的数据完整地同步给玩家，这会导致客户端重建区块，
重新增删内部的方块实体，导致了较高的客户端卡顿，以及较大的网络负载。不过完整的区块数据包也有一个好处，它可以去除客户端在这个区块中出现的幽灵方块</p>
<p>这一规则的用途即为调整 64 这一常量，毕竟 1gt 发生至少 64 处方块更新在大型机器中实在是太常见了。
将其调高，可以避免服务端发送大量区块数据包，提升客户端帧数，减少网络带宽占用，但得小心幽灵方块</p>
<h3 id="区块刻速度-chunkTickSpeed"><a class="header-anchor" href="#区块刻速度-chunkTickSpeed"></a>区块刻速度 (chunkTickSpeed)</h3>
<blockquote>
<p>修改每游戏刻每区块的区块刻运算的频率。默认值为 <code>1</code>。将其设为 <code>0</code> 以禁用区块刻。受影响的游戏阶段：雷电、结冰与积雪、随机刻</p>
<p>在值为 <code>n</code> 时，每游戏刻每区块，气候相关的阶段会发生 <code>n</code> 次，而随机刻会在每区段中发生 <code>n</code> * <code>randomTickSpeed</code> 次</p>
</blockquote>
<p>一个区块刻阶段包含着以下多种游戏阶段：雷电&amp;骷髅马的生成、雨雪的降落与水源结冰，以及随机抽取方块执行随机刻。
对于其中的随机刻阶段，我们可以简单地使用 <code>/gamerule randomTickSpeed</code> 来控制其运行速度，或者阻止随机刻的执行，
不过对于雷电冰雪这一类气候相关的运行逻辑，并没有对应的游戏规则</p>
<p>本规则即为一个类似 <code>/gamerule randomTickSpeed</code> 的游戏规则，可以将其设为一个很大的数值来加速气候逻辑的执行，让你的刷冰机快速结满冰，
也可以将其设为 0 来阻止游戏落雷降雪结冰。由于它的作用范围是完整的区块刻阶段，且随机刻阶段包含于区块刻阶段中，
因此要注意到该规则数值的变化是会同时影响随机刻的作用速度的。你可以将随机刻调为 0 以防止随机刻阶段占用了过高的 mspt</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/chunkTickSpeed.jpg" alt="chunkTickSpeed"></p>
<h3 id="创造玩家地狱放水-creativeNetherWaterPlacement"><a class="header-anchor" href="#创造玩家地狱放水-creativeNetherWaterPlacement"></a>创造玩家地狱放水 (creativeNetherWaterPlacement)</h3>
<blockquote>
<p>允许创造模式的玩家在地狱通过水桶放出水。技术上来讲，本条规则对所有 ultrawarm 的维度都生效</p>
</blockquote>
<p>都已经是创造模式了，玩家当然是想干什么就干什么，想划水就放水</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/creativeNetherWaterPlacement.gif" alt="creativeNetherWaterPlacement"></p>
<h3 id="创造玩家无物品冷却-creativeNoItemCooldown"><a class="header-anchor" href="#创造玩家无物品冷却-creativeNoItemCooldown"></a>创造玩家无物品冷却 (creativeNoItemCooldown)</h3>
<blockquote>
<p>取消创造模式玩家的任何物品使用冷却，例如使用末影珍珠的 20gt 冷却</p>
</blockquote>
<p>都已经是创造模式了，麻将为何还要用物品使用冷却逻辑约束玩家</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/creativeNoItemCooldown.png" alt="creativeNoItemCooldown"></p>
<h3 id="实体速度丢失-entityMomentumLoss"><a class="header-anchor" href="#实体速度丢失-entityMomentumLoss"></a>实体速度丢失 (entityMomentumLoss)</h3>
<blockquote>
<p>将其设为 <code>false</code> 以关闭从磁盘载入时实体超过10m/gt部分的沿轴速度的丢失</p>
</blockquote>
<p>对于实体而言，在从 nbt 读取读取到的速度矢量中，对于每一坐标轴上的速度分量，如果它的绝对值大于 10 （单位：m/gt）的话，那就将该速度分量置为 0</p>
<p>从 nbt 读取数据这一操作常见于实体通过传送门跨维度时，以及加载区块读取储存着的实体数据时</p>
<p>对于珍珠炮而言，是很容易出现发射出去的珍珠存在大于 10m/gt 的沿轴速度分量的。当这一种高速珍珠所在区块被卸载的时候，若重新加载此区块，
该珍珠对应的沿轴速度分量将会置零，导致我们不能直观地看到珍珠的运动轨迹。这时候我们就可以通过本规则，将这一机制进行暂时性的抑制处理</p>
<h3 id="实体同步距离-entityTrackerDistance"><a class="header-anchor" href="#实体同步距离-entityTrackerDistance"></a>实体同步距离 (entityTrackerDistance)</h3>
<blockquote>
<p>服务器同步实体信息至客户端的最大水平切比雪夫距离（单位: 区块）。基本上这就是服务端的“实体渲染视距”，不过这个距离依旧会被服务端视距所约束</p>
<p>将其设为一个不小于服务端视距的数值，就能令服务端将玩家视距内的所有实体都同步至客户端；将其设为一个非正值以使用原版逻辑</p>
<p>需要重新加载区块以将新的规则数值应用到实体上</p>
</blockquote>
<p>服务器中的每个实体被载入游戏时，服务器都会为其分配一个实体追踪器（EntityTracker），用于同步这一实体的数据给玩家。
根据实体类型的不同，实体追踪器会有着不同的同步距离上限以及不同的同步频率</p>
<p>在 1.15.2 中，实体追踪器的默认同步距离如下所示：</p>
<table>
<thead>
<tr>
<th>实体种类</th>
<th>同步距离（单位：区块）</th>
</tr>
</thead>
<tbody>
<tr>
<td>玩家</td>
<td>32</td>
</tr>
<tr>
<td>末影水晶</td>
<td>16</td>
</tr>
<tr>
<td>末影龙、TNT、落沙、物品展示框、栓绳结、画、盔甲架、经验球、滞留药水效果云、唤魔者尖牙</td>
<td>10</td>
</tr>
<tr>
<td>鱼钩、箭、光灵箭、三叉戟、各种火球、凋灵头颅、所有投掷物（雪球、羊驼口水、末影珍珠、鸡蛋、喷溅药水、经验瓶）、烟花火箭、物品</td>
<td>4</td>
</tr>
<tr>
<td>其他</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>客户端仅能显示同步范围内的实体并接受它们的数据，超出同步范围实体将会从客户端中移出，因此实体同步间隔可看做服务端的实体渲染距离，一个根据实体类型而变的实体渲染距离</p>
<p>要注意实体同步距离的实际值会与服务端的视距取最小值，这保证了实体视距总是不会超过服务端的视距</p>
<p>当我们想要让客户端能尽可能地显示出极远处的实体时，如使用 replay mod 摄像时，可以修改本规则，拉高所有实体的实体视距。
你可以直接将本规则设置为一个足够大的值（如 64），以此让实体视距等同于服务端视距</p>
<h3 id="实体同步间隔-entityTrackerInterval"><a class="header-anchor" href="#实体同步间隔-entityTrackerInterval"></a>实体同步间隔 (entityTrackerInterval)</h3>
<blockquote>
<p>服务器同步实体信息至客户端的时间间隔（单位: gt）。如果设为一个较小的数值，如 1，服务器将每 1gt 都同步实体信息至客户端，这能减小客户端发生实体不同步现象的概率</p>
<p>将其设为一个非正值以使用原版逻辑</p>
<p>需要重新加载区块以将新的规则数值应用到实体上</p>
</blockquote>
<p>实体追踪器的相关信息见 entityTrackerDistance 的介绍</p>
<p>在 1.15.2 中，实体追踪器的默认同步周期如下所示：</p>
<table>
<thead>
<tr>
<th>实体种类</th>
<th>同步周期（单位：游戏刻）</th>
</tr>
</thead>
<tbody>
<tr>
<td>玩家、唤魔者尖牙</td>
<td>2</td>
</tr>
<tr>
<td>末影之眼</td>
<td>4</td>
</tr>
<tr>
<td>鱼钩</td>
<td>5</td>
</tr>
<tr>
<td>各种火球、凋灵头颅、所有投掷物（雪球、羊驼口水、末影珍珠、鸡蛋、喷溅药水、经验瓶）、烟花火箭、TNT</td>
<td>10</td>
</tr>
<tr>
<td>箭、光灵箭、三叉戟、物品、落沙、经验球</td>
<td>20</td>
</tr>
<tr>
<td>物品展示框、栓绳结、画、滞留药水效果云、末影水晶</td>
<td>Integer.MAX_VALUE，可视作无穷大</td>
</tr>
<tr>
<td>其他</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>除非一个实体发生了速度的突变，或者一些重要的数据发生了变化，实体追踪器只会每隔一定时间才向范围内的玩家发送相关的数据，而这一间隔则为实体追踪器的同步时间</p>
<p>投掷物、重力方块、TNT 等实体有着较大的实体同步周期，而末影水晶甚至不与客户端进行信息同步，这导致在设计相关机器的时候，
客户端容易出现实体运动与服务端不同步的情况，这是很烦人的。这时，你可以使用本规则将实体同步间隔设为 1，让服务端每 gt 都同步所有实体的数据，尽可能避免不同步的发生</p>
<h3 id="爆炸不影响实体-explosionNoEntityInfluence"><a class="header-anchor" href="#爆炸不影响实体-explosionNoEntityInfluence"></a>爆炸不影响实体 (explosionNoEntityInfluence)</h3>
<blockquote>
<p>爆炸不会影响任何实体。这里的影响包括伤害、加速等效果</p>
</blockquote>
<p>虽然 carpet 的规则 <code>explosionNoBlockDamage</code> 可以阻止爆炸对方块的影响，但它并不阻止爆炸对实体的影响，
会导致乱飞的 TNT 依然可以把意料之外的实体炸没。这不好，用这条规则给我关</p>
<h3 id="爆炸数据包广播范围-explosionPacketRange"><a class="header-anchor" href="#爆炸数据包广播范围-explosionPacketRange"></a>爆炸数据包广播范围 (explosionPacketRange)</h3>
<blockquote>
<p>设置在爆炸发生时，爆炸数据包对玩家的广播范围</p>
</blockquote>
<p>在爆炸发生时，服务端仅会告知离爆点 64m 内的玩家，这里发生了爆炸，而离爆点 64m 范围外的玩家是见不到爆炸效果的</p>
<p>本规则的作用即为修改 64m 这一常量，你可以将其调大以见到更远的爆炸，也可以将其调小来减轻巨量爆炸时客户端的压力</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/explosionPacketRange.gif" alt="explosionPacketRange"></p>
<h3 id="禁用耕地被踩踏-farmlandTrampledDisabled"><a class="header-anchor" href="#禁用耕地被踩踏-farmlandTrampledDisabled"></a>禁用耕地被踩踏 (farmlandTrampledDisabled)</h3>
<blockquote>
<p>阻止耕地被生物踩成泥土</p>
</blockquote>
<p>在设计一些如小黑瓜机这种，使用了生物 + 耕地的机器时，很容易会遇到生物踩烂了耕地的情况。
这挺烦人的，尤其是在做概念验证的时候，毕竟这时我们更关心其他数据，并不在意耕地是否足够安全</p>
<h3 id="拍扁三角形分布-flattenTriangularDistribution"><a class="header-anchor" href="#拍扁三角形分布-flattenTriangularDistribution"></a>拍扁三角形分布 (flattenTriangularDistribution)</h3>
<blockquote>
<p><strong>本规则仅在 Minecraft &gt;= 1.19 中存在</strong></p>
<p>把 Minecraft 随机数发生器的三角形分布改为均匀分布。借此，边界情况就更有可能发生了</p>
</blockquote>
<p>在 MC 1.19 版本之前，fabric carpet 提供了一个被命名为 <code>extremeBehaviours</code> 的规则，它能使得一些依赖正态分布随机数生成器的游戏机制更频繁地产生极端情况。
这些机制包括：投掷器喷出物品的随机速度、箭矢的基础伤害、生物生成时的 <code>FOLLOW_RANGE</code> 属性随机调整等</p>
<p>正态分布的随机数生成器产生的结果是无边界的，在极端情况下可能会产生偏差很大的随机值。<code>extremeBehaviours</code> 正是为了测试机器在这些极端情况的稳定性而生。
不过随着 MC 1.19 的到来，麻将把各种正态分布换成了有界的三角分布，fabric carpet 也因此将 <code>extremeBehaviours</code> 规则删除了</p>
<p>但是，就算是三角分布，它的边界情况依然也是罕见的，设计机器时也依然存在着测试边界情况的需求。
那么不如整一个 <code>flattenTriangularDistribution</code>，把三角分布替换成值域相同的均匀分布，让边界情况更容易发生</p>
<p>在本规则开启前后，相关随机数生成器的概率密度函数变化如下所示。左侧为原来的三角分布，右侧为修改后的均匀分布</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/flattenTriangularDistribution.png" alt="flattenTriangularDistribution"></p>
<h3 id="禁用物品实体跳过移动运算-itemEntitySkipMovementDisabled"><a class="header-anchor" href="#禁用物品实体跳过移动运算-itemEntitySkipMovementDisabled"></a>禁用物品实体跳过移动运算 (itemEntitySkipMovementDisabled)</h3>
<blockquote>
<p>移除物品实体跳过移动运算的机制。改回为 1.13 及以前的物品实体机制，也就是低速着地的物品实体依然会每 gt 都运算移动，而非每 4gt</p>
<p>当你需要精准使用物品实体运动逻辑时有用。会导致利用了相关机制的机器无法工作，如 2no2name 的无线红石</p>
</blockquote>
<p>在 1.14+ 中，mojang 为物品实体引入了一个新逻辑：当物品实体满足以下两种情况</p>
<ul>
<li>物品实体着地</li>
<li>物品实体水平方向的速度小于等于的平方 &gt; $10^{-5}m/gt$，即水平速度不超过约 0.063m/s</li>
</ul>
<p>的时候，每 4gt 才运算一次物品实体的移动逻辑。这虽然能减少在地面上扎堆不动物品实体带来的运算量，但也会带来一些额外的问题：
一大堆物品实体从一个平台落下时，会分成 4 批逐批落下，这有时候会对我们的实验造成影响</p>
<p>本规则的作用即为移除这一“着地低速物品实体每 4gt 运算一次移动”的机制，让物品实体在任何情况下都能每 gt 运算一遍移动逻辑</p>
<h3 id="重新引入瞬时方块更新逻辑-instantBlockUpdaterReintroduced"><a class="header-anchor" href="#重新引入瞬时方块更新逻辑-instantBlockUpdaterReintroduced"></a>重新引入瞬时方块更新逻辑 (instantBlockUpdaterReintroduced)</h3>
<blockquote>
<p><strong>本规则仅在 Minecraft &gt;= 1.19 中存在</strong></p>
<p>重新引入 1.19 以前的瞬时方块更新逻辑。本规则让基于栈溢出的更新抑制在 1.19+ 中再次可行</p>
<p>它还可以让微时序记录器的记录结果更加清晰有逻辑，如 1.19 以前的版本一样的清晰</p>
</blockquote>
<p>MC 1.19 引入了人工栈数据结构来处理 MC 方块更新，这导致 1.19 之后，方块并不会瞬时发出更新了。这带来了两个影响：</p>
<ul>
<li>足够长的方块更新链不再能引发 JVM 栈溢出异常，这导致基于方块更新栈溢出的更新抑制不再可行</li>
<li>方块更新之间的代码调用关系从直接调用变成了间接调用，变得更加晦涩。这不仅仅使得代码阅读的难度增加，还会使得微时序记录器的输出变得抽象起来，增加借助微时序记录器分析时序的难度</li>
</ul>
<p>好在麻将并没有完全移除瞬时更新的逻辑，因此可以整条规则把 1.19 以前的瞬时方块更新带回来</p>
<p>参考 Void514 的观点，在这里，一个操作是“瞬时”的，指：在操作的结果发生时，触发操作的原因位于当前 JVM 的函数调用栈上</p>
<h3 id="光照更新-lightUpdates"><a class="header-anchor" href="#光照更新-lightUpdates"></a>光照更新 (lightUpdates)</h3>
<blockquote>
<p>暂停或者禁止光照更新</p>
<ul>
<li>若被设为抑制(suppressed)，光照更新不会被执行，这可用于模拟光照抑制器</li>
<li>若被设为忽略(ignored)，光照更新不会被计划，这常用于在创造模式中制造光照错误</li>
<li>若被设为关闭(off)，光照更新不会被计划或被执行</li>
</ul>
<p><strong>【警告】</strong>：若被设为抑制或关闭，新的区块将无法被加载。如果此时玩家等原因尝试加载新的区块，服务端将进入无法跳出的死循环</p>
</blockquote>
<p>1.14 后，Minecraft 的光照引擎被重写，服务端的光照更新被安排至一个独立的光照线程执行。Mojang 使用了队列来进行主线程与光照线程间的通讯，
因此一次光照更新想要执行，得先进入光照队列排队等待，等待光照线程将光照队列取出并执行这一更新</p>
<p>该规则用于控制原版的光照队列，它的四种可能取值对应着下方的行为逻辑表格</p>
<table>
<thead>
<tr>
<th>值</th>
<th>是否将光照更新入队</th>
<th>是否执行光照队列中的更新</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>开启 (on)</td>
<td>是</td>
<td>是</td>
<td>原版表现，光照更新正常执行</td>
</tr>
<tr>
<td>抑制 (suppressed)</td>
<td>是</td>
<td>否</td>
<td>光照更新入队，但不出队。模拟光照队列被光照抑制器阻塞的情况。在本规则的值调回为<em>开启</em>或<em>忽略</em>时，队列中积攒的光照更新会依次执行</td>
</tr>
<tr>
<td>忽略 (ignored)</td>
<td>否</td>
<td>是</td>
<td>光照更新不入队，但队列中的光照更新正常执行。常用于制作一些幽灵光源或无亮度光源</td>
</tr>
<tr>
<td>关闭 (off)</td>
<td>否</td>
<td>否</td>
<td>光照更新不入队，队列中的光照更新也不执行。相比于选项“抑制”，光照更新被关闭地更彻底</td>
</tr>
</tbody>
</table>
<h3 id="矿车搭载乘客最小速度-minecartTakePassengerMinVelocity"><a class="header-anchor" href="#矿车搭载乘客最小速度-minecartTakePassengerMinVelocity"></a>矿车搭载乘客最小速度 (minecartTakePassengerMinVelocity)</h3>
<blockquote>
<p>决定矿车将其附近实体作为乘客搭载上车所需的最低水平方向速度（m/gt）。将其设为 0 以让矿车忽略速度，像船一样总能将附件实体载上车。将其设为 NaN 以让矿车永远不能把实体载上车</p>
</blockquote>
<p>一个矿车想要把附近的生物吸上车，需要满足其在水平方向上的速度大于 0.1m/gt（2m/s）这个条件，这意味着静止 / 慢慢移动的矿车无法把生物吸上车</p>
<p>在设计机器时，这个矿车吸生物上车的条件有时候就挺烦人的。为了把生物装进矿车里，我们还得专门搞一段铁轨来给矿车加速。
如果矿车能像船一样，蹭着生物就能吸上车，那就最好了。多说无益，整条规则改之</p>
<p>由于本规则修改的是“矿车搭载乘客的最小速度”，因此你可以把它设置成不同的取值，来满足不同场景下的需求：</p>
<ul>
<li>把值设成 <code>0</code>：矿车像船一样，蹭着生物就能把生物吸上去</li>
<li>把值设成 <code>NaN</code>：矿车无论怎样都不会把生物吸上去</li>
</ul>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/minecartTakePassengerMinVelocity.gif" alt="minecartTakePassengerMinVelocity"></p>
<h3 id="橡树长成鸡腿树百分率-oakBalloonPercent"><a class="header-anchor" href="#橡树长成鸡腿树百分率-oakBalloonPercent"></a>橡树长成鸡腿树百分率 (oakBalloonPercent)</h3>
<blockquote>
<p>橡树树苗长成鸡腿树（fancy_oak）的概率，使用百分率作为值。如，0 代表没有鸡腿树，50 代表有 50% 的概率长成鸡腿树，100 代表总长成鸡腿树</p>
<p>将其设为 -1 以禁用本规则并使用原版逻辑（10% 概率长成鸡腿树）</p>
</blockquote>
<p>若想高效地测试树场对鸡腿橡树的兼容性，与其对着原版的 10% 鸡腿树概率慢慢尝试，不如开条规则来修改原版的概率。必出鸡腿树 / 必不出鸡腿树，任你选择</p>
<h3 id="禁用侦测器检测功能-observerNoDetection"><a class="header-anchor" href="#禁用侦测器检测功能-observerNoDetection"></a>禁用侦测器检测功能 (observerNoDetection)</h3>
<blockquote>
<p>不准侦测器在受状态更新时添加计划刻事件。可以认为这条规则禁用了观察者的检测功能</p>
</blockquote>
<p>在使用 <code>/fill</code>、<code>/clone</code> 指令、结构方块、worldedit 等方式来修改世界时，有时候会莫名其妙地把侦测器给激活了。
与其想办法关掉方块更新，排除各种误触的地方，不如直接禁止侦测器检测方块变化，从源头上解决问题</p>
<p>值得注意的是，不要在机器开着的时候启用这条规则，毕竟这条规则的作用范围是整个服务器</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/observerNoDetection.gif" alt="observerNoDetection"></p>
<h3 id="POI更新开关-poiUpdates"><a class="header-anchor" href="#POI更新开关-poiUpdates"></a>POI更新开关 (poiUpdates)</h3>
<blockquote>
<p>方块变化时是否会更新 POI。将其设为 <code>false</code> 以禁用 POI 更新</p>
</blockquote>
<p>POI 的更新是方块变化流程的最后一步，用于移除旧方块的 POI 并添加新方块的 POI。这一操作是可以被更新抑制所抑制的。
在创造模式中，如果构造 POI 不一致的方块依然得用到更新抑制器显然太麻烦了，于是就有了本条规则</p>
<p>可用于如在 1.15 方便地制作无 POI 的地狱门方块</p>
<h3 id="融雪最小亮度-snowMeltMinLightLevel"><a class="header-anchor" href="#融雪最小亮度-snowMeltMinLightLevel"></a>融雪最小亮度 (snowMeltMinLightLevel)</h3>
<blockquote>
<p>雪片融化所需的最小亮度等级。在原版里这个值为 12，意味着雪片将在亮度等级 &gt;= 12时于随机刻中融化</p>
<p>将其设为 0 以将所有位于你建筑上的烦人的雪片融化；将其设为与防止降雪的最小亮度等级 (12) 来方便地测试你的建筑是否能借助亮度来防降雪</p>
<p>你可以修改游戏规则 <code>randomTickSpeed</code> 来加速雪的融化，也可以修改地毯规则 <code>chunkTickSpeed</code> 来加速降雪的过程</p>
</blockquote>
<p>规则简介已经描述的很清楚了 XD</p>
<h3 id="结构方块不保留流体-structureBlockDoNotPreserveFluid"><a class="header-anchor" href="#结构方块不保留流体-structureBlockDoNotPreserveFluid"></a>结构方块不保留流体 (structureBlockDoNotPreserveFluid)</h3>
<blockquote>
<p>结构方块在放置含水方块时，不保留已存在的流体。同时有着抑制 <a href="https://bugs.mojang.com/browse/MC-130584">MC-130584</a> 发生的副作用</p>
</blockquote>
<p>如图所示</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/structureBlockDoNotPreserveFluid.jpg" alt="structureBlockDoNotPreserveFluid"></p>
<p><a href="https://bugs.mojang.com/browse/MC-130584">MC-130584</a> 是一个在结构方块放置结构的时候，水会蔓延至含水方块里的 bug。
它在 1.17 的快照 20w45a 中被修复。这条规则也可以作为 1.17 前对这一 bug 的补丁</p>
<h3 id="结构方块范围限制-structureBlockLimit"><a class="header-anchor" href="#结构方块范围限制-structureBlockLimit"></a>结构方块范围限制 (structureBlockLimit)</h3>
<blockquote>
<p>覆写结构方块的范围限制。当相对位置的值大于32时客户端里结构的位置可能会错误地显示</p>
</blockquote>
<p>原版结构方块怎么只有这么一点大小限制？给我改！</p>
<p>fabric carpet 1.4.25 中引入了功能一致的规则，因此在 MC 1.16 及以后的 Carpet TIS Addition 中该规则被移除</p>
<p>由于原版的结构方块数据包中使用了 byte 来储存结构的大小及偏移，因此在只使用原版协议的前提下可操作的结构方块大小最大为 127。
fabric-carpet 给出的解决方法是在原版数据包末端追加使用 int 储存的结构大小及偏移，该规则也同样地移植了这一实现</p>
<h3 id="同步光照线程-synchronizedLightThread"><a class="header-anchor" href="#同步光照线程-synchronizedLightThread"></a>同步光照线程 (synchronizedLightThread)</h3>
<blockquote>
<p>将光照线程与主线程同步，这样光照线程就不会于落后主线程而失去同步。服务器将会在每个世界开始运算时等待光照线程的任务完成。你可以借此安全地 <code>/tick warp</code> 而不用担心潜在的光照抑制或光照不同步</p>
</blockquote>
<p>在很多时候，我们宁可服务端主线程等待光照线程把光照更新执行完，也不愿让光照队列堆积导致光照抑制甚至内存溢出。
本规则是一简单又有效的实现：在服务端线程开始运算一个维度时，先等待这一维度的光照线程将队列里的更新都处理完，再继续处理这一维度的服务端线程任务</p>
<p>这一规则还为 CarpetProfiler 添加了一个名为 <code>Lighting synchronization</code> 的游戏阶段，用于记录服务端等待光照线程所造成的额外 mspt。这会在 <code>/tick health</code> 指令中显示</p>
<h3 id="计划刻上限-tileTickLimit"><a class="header-anchor" href="#计划刻上限-tileTickLimit"></a>计划刻上限 (tileTickLimit)</h3>
<blockquote>
<p>修改每游戏刻中计划刻事件的执行次数上限</p>
</blockquote>
<p>一个计划刻队列每 gt 只会执行最多 65536 个计划刻事件，超出这一限制的计划刻事件将被延后至下一个 gt 执行。该规则的作用即为修改这一常量，常用于方便地触发/模拟计划刻 EMP</p>
<h3 id="TNT引信时长-tntFuseDuration"><a class="header-anchor" href="#TNT引信时长-tntFuseDuration"></a>TNT引信时长 (tntFuseDuration)</h3>
<blockquote>
<p>覆盖 TNT 的默认引信时长。这也会影响被爆炸点燃的 TNT 的引信时长</p>
</blockquote>
<p>有时候你想快速地点几个 TNT 测试它们的爆炸，你可以借助这一规则将 TNT 的引信改短，让它们快速爆炸</p>
<p>有时候你只想要一个不会爆炸的 TNT 实体来做实验，这时你也可以借助这一规则将 TNT 的引信加长，从而生成一个几乎不会爆的任你揉搓的 TNT</p>
<p>注意到在 TNT 实体保存至/读取自 nbt 数据时，其 Fuse 标签使用的是 short 数据类型进行储存，因此 TNT 的引信时长最大值为 32767（约 27.3 分钟），这也足够长了</p>
<h3 id="TNT忽略红石信号-tntIgnoreRedstoneSignal"><a class="header-anchor" href="#TNT忽略红石信号-tntIgnoreRedstoneSignal"></a>TNT忽略红石信号 (tntIgnoreRedstoneSignal)</h3>
<blockquote>
<p>阻止 TNT 被红石信号点燃。你仍可以使用爆炸等方式点燃 TNT</p>
</blockquote>
<p>在使用原版指令 / WorldEdit 等工具修改移动含 TNT 的机器时，总有那么些时候会不小心误触导致其中的 TNT 被点燃。
用 <code>totallyNoBlockUpdate</code> 规则扬掉所有更新的副作用又太大，这时你就需要本规则，让 TNT 怎么激活也不会被点燃了</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/tntIgnoreRedstoneSignal.gif" alt="tntIgnoreRedstoneSignal"></p>
<h3 id="完全没有方块更新-totallyNoBlockUpdate"><a class="header-anchor" href="#完全没有方块更新-totallyNoBlockUpdate"></a>完全没有方块更新 (totallyNoBlockUpdate)</h3>
<blockquote>
<p>禁用所有方块更新以及状态更新的执行</p>
</blockquote>
<p>这条规则的功能很简单：禁止所有方块更新及状态更新的执行，常用于使用指令 / WorldEdit 等工具修改移动机器</p>
<p>值得注意的是，除了更新外的其他机制依然可以正常运作，如流体通过计划刻流动，比较器检测到容器容量变化而更新其状态。
以及本规则的作用范围是整个服务器，盲目地开启这一规则很有可能会损坏/冻结住那些一直在运行的机器</p>
<h3 id="坚韧的凋零玫瑰-toughWitherRose"><a class="header-anchor" href="#坚韧的凋零玫瑰-toughWitherRose"></a>坚韧的凋零玫瑰 (toughWitherRose)</h3>
<blockquote>
<p>由死而生，凋零玫瑰非常坚韧，能在任意表面上种植。该规则移除了凋零玫瑰所有的放置约束，这意味着你可以将零玫瑰种植在任何地方。</p>
<p>在你想用更新抑制的凋零玫瑰做凋灵骷髅塔时，这条规则可以帮你一把</p>
</blockquote>
<p>背景知识：凋灵玫瑰在受到状态更新时会检查其是否处于合法的状态，如果不合法则立即掉落</p>
<p>如规则介绍所述，在设计把凋灵玫瑰种在地狱砖上的凋灵骷髅塔时，很容易因误触而整掉了一整片的凋灵玫瑰，非常烦人</p>
<p>本条规则的作用就是去除凋灵玫瑰的一切放置限制，让凋灵玫瑰可以种在任何方块上。在什么地狱砖，铁轨，岩浆，甚至空气之上，都能种凋灵玫瑰</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/toughWitherRose.png" alt="toughWitherRose"></p>
<h3 id="禁用海龟蛋被践踏-turtleEggTrampledDisabled"><a class="header-anchor" href="#禁用海龟蛋被践踏-turtleEggTrampledDisabled"></a>禁用海龟蛋被践踏 (turtleEggTrampledDisabled)</h3>
<blockquote>
<p>阻止海龟蛋因实体踩踏而破坏</p>
</blockquote>
<p>如规则描述所述，当你想要测试一个机器是否能正确通过海龟蛋处理僵尸猪人，但又暂时不想考虑海龟蛋被不明原因踩坏的时候，你就可以把这条规则开起来，让海龟蛋怎么踩都踩不烂</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/turtleEggTrampledDisabled.gif" alt="turtleEggTrampledDisabled"></p>
<h3 id="亡灵生物别在阳光下着火-undeadDontBurnInSunlight"><a class="header-anchor" href="#亡灵生物别在阳光下着火-undeadDontBurnInSunlight"></a>亡灵生物别在阳光下着火 (undeadDontBurnInSunlight)</h3>
<blockquote>
<p>阻止亡灵生物在阳光下着火。不过他们的头盔依然会在阳光下损失耐久</p>
</blockquote>
<p>有时在主世界测试一些与亡灵生物相关的机器时，还得记得给做个遮阳天花板，防止亡灵生物被晒死。
这挺烦人的，不如整个规则给亡灵涂足防晒霜。毕竟绝大部分情况下，给最终实装版本加个天花板防晒是很容易的操作</p>
<h3 id="虚空伤害数值-voidDamageAmount"><a class="header-anchor" href="#虚空伤害数值-voidDamageAmount"></a>虚空伤害数值 (voidDamageAmount)</h3>
<blockquote>
<p>修改虚空伤害的数值</p>
</blockquote>
<p>让掉虚空的生物死快些，原版虚空的 4 点伤害有点太低了，直接加到 1000 点</p>
<h3 id="虚空伤害忽略玩家-voidDamageIgnorePlayer"><a class="header-anchor" href="#虚空伤害忽略玩家-voidDamageIgnorePlayer"></a>虚空伤害忽略玩家 (voidDamageIgnorePlayer)</h3>
<blockquote>
<p>阻止玩家受到任何虚空伤害。对玩家完全无害的虚空，好耶！</p>
</blockquote>
<p>有些时候，你想飞到虚空深处，来从远处贴近世界底部的机器的整体运行情况，但又担心会被无视游戏模式的虚空伤害搞死。
不如整个规则，移除虚空对玩家的伤害，让玩家想在虚空逛多深逛多久都没问题</p>
<h3 id="虚空相对海拔高度-voidRelatedAltitude"><a class="header-anchor" href="#虚空相对海拔高度-voidRelatedAltitude"></a>虚空相对海拔高度 (voidRelatedAltitude)</h3>
<blockquote>
<p>修改虚空相对世界底部的海拔高度，此处的虚空指实体会受到虚空伤害的区域</p>
</blockquote>
<p>有时候你想往虚空飞一飞，飞低点得到机器底部的视角，但又恐 y=-64 虚空伤害直击创造模式玩家，这时你可以用这条规则，把虚空伤害所在的海拔高度阈值调低，这样你就可以尽情地在虚空里遨游了</p>
<p>注意该规则所表示的海拔高度是一个相对值，是相对世界底部 y 值的相对高度值</p>
<h3 id="禁用凋灵生成音效-witherSpawnedSoundDisabled"><a class="header-anchor" href="#禁用凋灵生成音效-witherSpawnedSoundDisabled"></a>禁用凋灵生成音效 (witherSpawnedSoundDisabled)</h3>
<blockquote>
<p>禁用凋灵在召唤后生命值回满时发出的世界中所有玩家都能听到的音效</p>
</blockquote>
<p>凋灵生命值回满爆炸时发出的那一个声音全世界都能听到，真的吵死了，快给我关掉</p>
<h3 id="经验球追踪距离-xpTrackingDistance"><a class="header-anchor" href="#经验球追踪距离-xpTrackingDistance"></a>经验球追踪距离 (xpTrackingDistance)</h3>
<blockquote>
<p>修改经验球检测并追踪玩家的距离。将其调至 0 以禁用追踪</p>
</blockquote>
<p>当你想要在经验球管道附近修改东西，但又不想因为自己在经验球附近而扰乱了经验球的运动，你就可以用这条规则将经验球的追踪给禁用掉。
当然你也可以把经验球的追踪距离拉到很高，感受经验球漫天飞舞最终汇聚于身的体验</p>
<h2 id="生存模式用新增特性-bug修复"><a class="header-anchor" href="#生存模式用新增特性-bug修复"></a>生存模式用新增特性/bug修复</h2>
<h3 id="玩家重生丢失客户端设置数据修复-clientSettingsLostOnRespawnFix"><a class="header-anchor" href="#玩家重生丢失客户端设置数据修复-clientSettingsLostOnRespawnFix"></a>玩家重生丢失客户端设置数据修复 (clientSettingsLostOnRespawnFix)</h3>
<blockquote>
<p>修复在玩家重生或从末地进入末地门时，新创建的玩家实体未迁移旧玩家实体中储存着的客户端设置的问题。因此依赖客户端设置数据的模组总能正常的工作，如本模组以及 worldedit 模组的服务端翻译</p>
</blockquote>
<p>对于玩家重生，以及玩家从末地进入末地门这两个操作，MC 会重建一个玩家实体对象，并把原实体的数据复制到新实体上</p>
<p>可惜，在这个复制数据的过程中，麻将忘了复制客户端配置相关的数据，这包括但不限于玩家客户端的语言设置。
这会导致一些依赖客户端设置数据的 mod 无法按照预期工作，比如 worldedit 和本 mod 的文本在玩家重生后都变成了英文</p>
<p>这是个 bug，虽然不严重，但挺影响游戏体验的，得重进服务器或者手动调一下客户端设置，才能恢复正常</p>
<p>有虫，得修，<code>/carpet setDefault clientSettingsLostOnRespawnFix true</code>，done</p>
<p>技术上来讲，在从旧玩家实体复制数据到新玩家实体的过程中，这条规则会重新将曾经用于旧玩家实体的客户端设置数据包（<code>ClientSettingsC2SPacket</code>）应用到新的玩家实体上。</p>
<h3 id="发射器发射龙息-dispensersFireDragonBreath"><a class="header-anchor" href="#发射器发射龙息-dispensersFireDragonBreath"></a>发射器发射龙息 (dispensersFireDragonBreath)</h3>
<blockquote>
<p>发射器可使用龙息瓶创造出龙息效果云</p>
</blockquote>
<p>新特性，让生存玩家可以在不依赖末影龙的情况下生成龙息效果云。可与规则 <a href="#%E5%8F%AF%E5%86%8D%E7%94%9F%E9%BE%99%E8%9B%8B-renewabledragonegg">renewableDragonEgg</a> 配合使用</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/dispensersFireDragonBreath.gif" alt="dispensersFireDragonBreath"></p>
<h3 id="保持弱加载区块的怪物-keepMobInLazyChunks"><a class="header-anchor" href="#保持弱加载区块的怪物-keepMobInLazyChunks"></a>保持弱加载区块的怪物 (keepMobInLazyChunks)</h3>
<blockquote>
<p>弱加载区块的怪物不再会被刷新掉，就像 1.15 之前版本似的。此选项仅对 1.15 至 1.16 间的版本有效</p>
</blockquote>
<p>在 1.15 ~ 1.16 中，位于弱加载区块中的生物也会同位于强加载时一样，执行离所有玩家 128m 则立即消失的逻辑。这导致了玩家无法使用存放在弱加载区块中的普通怪物制作伪和平装置</p>
<p>改规则将生物处理立即消失的逻辑改回了 1.14 及以前的逻辑，让弱加载区块中的生物不会因为远离玩家而立即消失</p>
<h3 id="大木桶-largeBarrel"><a class="header-anchor" href="#大木桶-largeBarrel"></a>大木桶 (largeBarrel)</h3>
<blockquote>
<p>史上最棒的物品仓储方块: 大木桶！两个相邻的底部相连木桶可以组成一个大木桶，大木桶的行为逻辑跟大箱子相近</p>
</blockquote>
<p>箱子能拼成大箱子，储量大，但它渲染很卡；木桶渲染不卡，但只有小箱子的容量。没有两全其美的储存容器真是令人纠结，不过有了这条规则后，就可以说：我全都要！</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/largeBarrel.gif" alt="largeBarrel"></p>
<p>底座相连的木桶将组成一个大木桶，位于坐标轴负方向的木桶作为大木桶的上半部分，位于坐标轴正方向的木桶作为大木桶的下半部分</p>
<h3 id="刷铁轨机修复-railDupingFix"><a class="header-anchor" href="#刷铁轨机修复-railDupingFix"></a>刷铁轨机修复 (railDupingFix)</h3>
<blockquote>
<p>禁用老式的移动点亮的充能或激活铁轨的刷铁轨机</p>
</blockquote>
<p>这种老式的刷铁轨机只对充能铁轨 &amp; 激活铁轨有效，效果如下</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/railDupingFix.gif" alt="railDupingFix"></p>
<p>修复方式：在充能铁轨 &amp; 激活铁轨更新自身状态前先确保这格铁轨依然存在</p>
<h3 id="可再生龙蛋-renewableDragonEgg"><a class="header-anchor" href="#可再生龙蛋-renewableDragonEgg"></a>可再生龙蛋 (renewableDragonEgg)</h3>
<blockquote>
<p>让龙蛋变得可再生：当龙蛋处于龙息效果云内时，龙蛋有一定概率吸收龙息并“召唤”出一个新的龙蛋</p>
<p>可与选项 <a href="#%E5%8F%91%E5%B0%84%E5%99%A8%E5%8F%91%E5%B0%84%E9%BE%99%E6%81%AF-dispensersfiredragonbreath">dispenserFireDragonBreath</a> 联动</p>
</blockquote>
<p>沐浴在龙息中的龙蛋吸收了足够的能量后，召唤出了一个新的龙蛋</p>
<p>实现的具体逻辑：</p>
<ol>
<li>在随机刻选中龙蛋方块后，龙蛋有 1 / 64 的几率尝试再生。这一否决率能保证龙蛋虽然可再生，但仍然是一种较为稀有的物资</li>
<li>龙蛋会找到与其所在位置 1 立方米范围相交的龙息效果云。若没找到，终止再生流程；否则随机挑选一个效果云</li>
<li>龙蛋会选择附近的一个随机位置，尝试生成龙蛋方块。选择位置的逻辑跟龙蛋被点击后随机传输的逻辑一致，不过仅有一次尝试机会。如果被选中的位置是空气的话，则龙蛋生成成功，龙息效果云的半径变为原 1 / 5</li>
</ol>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/renewableDragonEgg.gif" alt="renewableDragonEgg"></p>
<h3 id="可再生龙首-renewableDragonHead"><a class="header-anchor" href="#可再生龙首-renewableDragonHead"></a>可再生龙首 (renewableDragonHead)</h3>
<blockquote>
<p>被高压爬行者杀死的末影龙将会掉落一个龙首</p>
</blockquote>
<p>闪电苦力怕的斩首效果怎么能让末影龙逃过一劫？不过真要在生存中实现的话恐怕会有不小难度</p>
<h3 id="可再生鞘翅-renewableElytra"><a class="header-anchor" href="#可再生鞘翅-renewableElytra"></a>可再生鞘翅 (renewableElytra)</h3>
<blockquote>
<p>当幻翼被潜影贝杀死时有给定概率掉落鞘翅。设置为 0 以禁用</p>
</blockquote>
<p>需要潜影贝：玩家无法跳 Minecraft 的科技树，必须前往末地城才能拿到鞘翅
涉及幻翼：既然幻翼膜能拿来修鞘翅，那幻翼膜一定是鞘翅的原材料吧</p>
<h3 id="刷沙机修复-sandDupingFix"><a class="header-anchor" href="#刷沙机修复-sandDupingFix"></a>刷沙机修复 (sandDupingFix)</h3>
<blockquote>
<p>禁用使用末地门的刷沙机以及刷重力方块机。这里的重力方块包括沙子、铁砧、龙蛋等。在开启后刷沙机的沙子将会仅被传送至另一个纬度</p>
</blockquote>
<p>末地门刷沙机的原理很简单：Mojang 在执行重力方块实体落地转换为方块的逻辑前，忘了判断这个重力方块是否仍然存在与这个世界里，
结果就是只要重力方块在碰到末地门的同时落地，就能既前往另一纬度又可以转换为方块</p>
<p>修复也很简单，把缺失的判断加上就行了</p>
<h3 id="TNT复制修复-tntDupingFix"><a class="header-anchor" href="#TNT复制修复-tntDupingFix"></a>TNT复制修复 (tntDupingFix)</h3>
<blockquote>
<p>禁用TNT、地毯以及部分铁轨的复制机。基于依附性方块的复制机会无法复制，基于红石原件更新的复制机会无法保留被复制的方块</p>
<p><s>Dupe bad dig good</s></p>
</blockquote>
<p>这一类的方块复制均发生于活塞将所推动的方块一次转换为 b36 的过程中，根据更新源的不同可以分为两种复制机：</p>
<ul>
<li>基于依附性方块掉落而发出更新的，如死珊瑚更新源。原理为 b36 方块的放置会发出状态更新，导致还未被置为 b36 的依附性方块发现自己附着于 b36 上，或者依附在空气上，从而掉落，并发出更新</li>
<li>基于方块被移除时发出更新的，如亮起侦测器更新源。原理为一些红石原件（侦测器、中继器等）在亮起时被移除的时候，会发出方块更新，用于告知附近方块你的信号源没了</li>
</ul>
<p>为了修复这两种复制机，同时保证不破坏其他的逻辑时序而保证原版性，我们可以这样做：</p>
<ul>
<li>
<p>使被活塞所推动的方块间接地转换为 b36：</p>
<ol>
<li>先不发出任何更新地，将活塞所推动方块的原位置替换为空气方块</li>
<li>再让原版的逻辑将这些空气方块转换为 b36</li>
</ol>
<p>这保证了生成 b36 的时候不会有残留的方块作妖</p>
</li>
<li>
<p>在将方块设置为空气之前才把世界里的方块状态储存进活塞推动列表中，这样就算基于方块被移除时发出更新的复制机刷出了 TNT，这 TNT 也是真的点着掉了下来，不再会被存入活塞推动列表里变成 b36</p>
</li>
</ul>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/tntDupingFix.gif" alt="tntDupingFix"></p>
<h3 id="工具化TNT-tooledTNT"><a class="header-anchor" href="#工具化TNT-tooledTNT"></a>工具化TNT (tooledTNT)</h3>
<blockquote>
<p>由玩家引发的爆炸破坏并掉落物品时会应用玩家手上的工具，因此你可以点燃TNT以采集需要特定工具或者附魔的方块，只要你在爆炸时拿着正确的工具。比如，你可以拿着精准采集镐子来采集冰，或者拿着剪刀来采集草</p>
<p>此规则同样适用于玩家以外的生物。技术上来讲，此规则将来源生物主手上的物品应用在了爆炸里战利品表的创建中</p>
</blockquote>
<p>精准采集 TNT，从梦想变为现实——既然都有 TNT 掠夺了，那么为啥不来一个TNT 精准呢</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/tooledTNT.gif" alt="tooledTNT"></p>
<h2 id="游戏优化"><a class="header-anchor" href="#游戏优化"></a>游戏优化</h2>
<h3 id="优化高速实体移动-optimizedFastEntityMovement"><a class="header-anchor" href="#优化高速实体移动-optimizedFastEntityMovement"></a>优化高速实体移动 (optimizedFastEntityMovement)</h3>
<blockquote>
<p>通过仅检测沿轴移动方向的方块碰撞来优化高速实体的移动</p>
<p>受 <a href="https://github.com/gnembon/carpetmod112">carpetmod112</a> 的规则 <code>fastMovingEntityOptimization</code> 启发</p>
<p>同规则 <code>optimizedTNT</code> 一起使用可大幅度提升炮的性能表现</p>
</blockquote>
<p>在实体移动的过程中，原版游戏会获取实体速度矢量构成的长方体中所有能阻挡其移动的碰撞箱</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/optimizedFastEntityMovement.png" alt="optimizedFastEntityMovement"></p>
<p>如上图所示，TNT 从右下移动至左上，游戏会获取图中白色染色玻璃范围的所有碰撞箱</p>
<p>由于实体实际上是沿轴分步移动的，这个长方体中中并非所有数据都是我们需要的，只有实体沿轴移动路径上的碰撞箱有可能阻挡实体移动（上图红色玻璃），
因此我们可以仅获得这条路径上的碰撞箱，而非获取整个长方体中的碰撞箱</p>
<p>在与 TNT 炮相关的机器中，TNT 的速度往往会被加速到极大值，又因为长方体的体积随实体速度大小立方级地增长，TNT 速度提上去之后带来的卡顿会急剧升高。
在使用本规则进行优化后，所需要扫描的碰撞箱范围体积变为与实体速度大小线性增长，能非常有效地缓解这部分的卡顿</p>
<h3 id="优化硬碰撞箱实体碰撞-optimizedHardHitBoxEntityCollision"><a class="header-anchor" href="#优化硬碰撞箱实体碰撞-optimizedHardHitBoxEntityCollision"></a>优化硬碰撞箱实体碰撞 (optimizedHardHitBoxEntityCollision)</h3>
<blockquote>
<p>优化实体与硬碰撞箱实体的碰撞</p>
<p>它使用了一个额外的独立的列表在区块中储存带有硬碰撞箱的实体，包括船和潜影贝。它能在实体移动并搜索路径上的带有硬碰撞箱的实体时减少大量无用的运算，因为世界里船和潜影贝的数量总是少数</p>
<p>在加载区块前开启它以使其工作，在地狱门刷怪塔中有~20%的性能提升。与添加了新实体的 mod 可能不兼容</p>
</blockquote>
<p>实体移动时，需要搜寻其移动路径上所有能阻挡其移动的碰撞箱对象，这包括方块以及带有硬碰撞箱的实体（对非矿车的实体而言，为船和潜影贝），然后计算它们对实体移动的阻挡效果</p>
<p>搜寻带有硬碰撞箱的实体的实现是，遍历一遍范围内所有区段中的所有实体，然后将其中具有硬碰撞箱的实体提取出来。如果范围内的实体数量非常多，这部分遍历将会非常耗时，
即便这个范围内几乎没有硬碰撞箱的实体。这种情况常出现于双维度刷怪塔的怪物处理维度端，其中有着大量刷出的怪物，但却几乎没有船跟潜影贝</p>
<p>该优化使用了一个独立的列表来储存含硬碰撞箱的实体，这样在需要于区段中搜索硬碰撞箱实体时就不用遍历整个包含所有实体的列表了，可以有效地减少这部分遍历的耗时</p>
<p>Lithium 模组在 v0.5.5 后也加入了类似的优化，位于 <code>chunk.entity_class_groups</code> 中</p>
<h3 id="TNT优化高优先级-optimizedTNTHighPriority"><a class="header-anchor" href="#TNT优化高优先级-optimizedTNTHighPriority"></a>TNT优化高优先级 (optimizedTNTHighPriority)</h3>
<blockquote>
<p>用带有更高优先级的 Mixin 注入来实现 carpet 规则 <code>optimizedTNT</code>，因此规则 <code>optimizedTNT</code> 可以覆盖 lithium 的爆炸优化</p>
<p>当然，它需要规则 <code>optimizedTNT</code> 开启才能工作</p>
</blockquote>
<p>fabric carpet 的爆炸优化有着实体接触率射线计算结果缓存的功能，这是 lithium 的爆炸优化所不具有的，</p>
<p>在默认情况下，lithium 的爆炸优化是会覆盖掉 fabric carpet 的爆炸优化的，两者无法共存。当你想使用 fabric carpet 的爆炸优化，而非 lithium 的爆炸优化的时候，即可启用本规则</p>
<p>Lithium 模组在 v0.6.2 后修改了其爆炸优化的实现，据其称这些修改能提升 lithium 的爆炸优化与其他修改爆炸的模组的兼容性。本规则与 lithium v0.6.2+ 的组合效果仍有待测试</p>
<h2 id="其他规则"><a class="header-anchor" href="#其他规则"></a>其他规则</h2>
<h3 id="禁用反刷屏监测-antiSpamDisabled"><a class="header-anchor" href="#禁用反刷屏监测-antiSpamDisabled"></a>禁用反刷屏监测 (antiSpamDisabled)</h3>
<blockquote>
<p>禁用玩家身上的刷屏检测，包括：聊天信息发送冷却、创造模式扔物品冷却</p>
</blockquote>
<p>在原版游戏中，若非 OP 玩家发消息 / 指令发的过快，会被因刷屏而踢出游戏；创造模式中从创造模式物品栏扔物品是有速度上限的，超过上限了只能以一秒一个物品的速度扔出物品</p>
<p>这些限制对于服务器成员遵纪守法的服务器而言显然只能提供烦人的作用，不如用这条规则将它扬了吧</p>
<h3 id="存活时间追踪器-commandLifeTime"><a class="header-anchor" href="#存活时间追踪器-commandLifeTime"></a>存活时间追踪器 (commandLifeTime)</h3>
<blockquote>
<p>启用 <code>/lifetime</code> 命令用于追踪生物存活时间等信息。可助于调试刷怪塔等</p>
</blockquote>
<p><code>/lifetime</code> 存活时间追踪器指令的开关及其权限控制</p>
<h3 id="世界控制命令开关-commandManipulate"><a class="header-anchor" href="#世界控制命令开关-commandManipulate"></a>世界控制命令开关 (commandManipulate)</h3>
<blockquote>
<p>启用 <code>/manipulate</code> 命令用于控制世界</p>
</blockquote>
<p><code>/manipulate</code> 指令的开关及其权限控制</p>
<h3 id="袭击追踪器-commandRaid"><a class="header-anchor" href="#袭击追踪器-commandRaid"></a>袭击追踪器 (commandRaid)</h3>
<blockquote>
<p>启用 <code>/raid</code> 命令用于列出或追踪袭击信息</p>
</blockquote>
<p><code>/raid</code> 指令的开关及其权限控制</p>
<h3 id="射线追踪命令开关-commandRaycast"><a class="header-anchor" href="#射线追踪命令开关-commandRaycast"></a>射线追踪命令开关 (commandRaycast)</h3>
<blockquote>
<p>启用 <code>/raycast</code> 命令用于分析射线追踪</p>
</blockquote>
<p><code>/raycast</code> 指令的开关及其权限控制</p>
<h3 id="刷新命令开关-commandRefresh"><a class="header-anchor" href="#刷新命令开关-commandRefresh"></a>刷新命令开关 (commandRefresh)</h3>
<blockquote>
<p>启用 <code>/refresh</code> 命令让你的客户端与服务端保持同步</p>
</blockquote>
<p><code>/refresh</code> 指令的开关及其权限控制</p>
<h3 id="移除实体命令开关-commandRemoveEntity"><a class="header-anchor" href="#移除实体命令开关-commandRemoveEntity"></a>移除实体命令开关 (commandRemoveEntity)</h3>
<blockquote>
<p>启用 <code>/removeentity</code> 命令用于直接在世界中抹除目标实体</p>
</blockquote>
<p><code>/removeentity</code> 指令的开关及其权限控制</p>
<h3 id="睡眠命令开关-commandSleep"><a class="header-anchor" href="#睡眠命令开关-commandSleep"></a>睡眠命令开关 (commandSleep)</h3>
<blockquote>
<p>启用 <code>/sleep</code> 命令用于制造卡顿</p>
</blockquote>
<p><code>/sleep</code> 指令的开关及其权限控制</p>
<h3 id="反混淆崩溃报告堆栈追踪-deobfuscateCrashReportStackTrace"><a class="header-anchor" href="#反混淆崩溃报告堆栈追踪-deobfuscateCrashReportStackTrace"></a>反混淆崩溃报告堆栈追踪 (deobfuscateCrashReportStackTrace)</h3>
<blockquote>
<p>反混淆崩溃报告中输出的堆栈追踪</p>
</blockquote>
<p>在分析生产环境下游戏崩溃的日志时，一份反混淆好的堆栈追踪所提供的阅读体验可比混淆版的堆栈追踪好多了</p>
<h3 id="假人名称前缀-fakePlayerNamePrefix"><a class="header-anchor" href="#假人名称前缀-fakePlayerNamePrefix"></a>假人名称前缀 (fakePlayerNamePrefix)</h3>
<blockquote>
<p>为 <code>/player</code> 指令召唤出来的假人名称添加指定前缀</p>
<p>将其设置为 <code>#none</code> 以阻止添加前缀</p>
<p>这可阻止玩家召唤奇怪名字的假人，还能让玩家列表变得更整洁</p>
</blockquote>
<p>让所有的假人均统一带有 <code>bot_</code> 什么的前缀，是非常令人舒适且便于管理的</p>
<p>如果输入的假人的名字已含给定前缀，召唤出来的假人名字则不会重复添加前缀</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/fakePlayerNamePrefix.jpg" alt="fakePlayerNamePrefix"></p>
<h3 id="假人名称后缀-fakePlayerNameSuffix"><a class="header-anchor" href="#假人名称后缀-fakePlayerNameSuffix"></a>假人名称后缀 (fakePlayerNameSuffix)</h3>
<blockquote>
<p>为 <code>/player</code> 指令召唤出来的假人名称添加指定后缀</p>
<p>将其设置为 <code>#none</code> 以阻止添加后缀</p>
</blockquote>
<p>类似 <a href="#%E5%81%87%E4%BA%BA%E5%90%8D%E7%A7%B0%E5%89%8D%E7%BC%80-fakeplayernameprefix">fakePlayerNamePrefix</a>，不过本条规则添加的是后缀</p>
<h3 id="假人远程召唤-fakePlayerRemoteSpawning"><a class="header-anchor" href="#假人远程召唤-fakePlayerRemoteSpawning"></a>假人远程召唤 (fakePlayerRemoteSpawning)</h3>
<blockquote>
<p>使用 <code>/player</code> 指令远程召唤假人的权限需求。在这里，“远程”指的是被召唤的假人位于 16m 以外，或另一个维度</p>
</blockquote>
<p>禁止远程召唤 bot，这可一点都不像一个“小号”能做的事情</p>
<p>默认值为 <code>true</code>，对应着 fabric carpet 的原始表现——你可以在任意地方召唤假人</p>
<h3 id="HUD记录器更新间隔-HUDLoggerUpdateInterval"><a class="header-anchor" href="#HUD记录器更新间隔-HUDLoggerUpdateInterval"></a>HUD记录器更新间隔 (HUDLoggerUpdateInterval)</h3>
<blockquote>
<p>覆写 Carpet Mod HUD 记录器的更新间隔，单位为 gametick</p>
</blockquote>
<p>在 fabric carpet 的框架中，位于 tab 栏玩家列表下方的 HUD 记录器的更新间隔是一个定值，20gt 定值。如果我们想要更高频率地刷新 HUD 记录器的信息刷，就可以使用本规则来修改这个间隔</p>
<h3 id="存活时间追踪器考虑怪物容量-lifeTimeTrackerConsidersMobcap"><a class="header-anchor" href="#存活时间追踪器考虑怪物容量-lifeTimeTrackerConsidersMobcap"></a>存活时间追踪器考虑怪物容量 (lifeTimeTrackerConsidersMobcap)</h3>
<blockquote>
<p>存活时间追踪器对不占怪物容量的生物的策略</p>
<ul>
<li><code>true</code>: 不追踪不占用怪物容量的生物，并与生物不影响怪物容量的时刻将其标记为已移除，如当它们捡起物品时。便于设计刷怪塔</li>
<li><code>false</code>: 追踪所有可追踪的生物，在生物确实被删除时将其标记为已移除。便于设计袭击农场或非刷怪塔的机器</li>
</ul>
</blockquote>
<p>存活时间追踪器所使用的的一个参数</p>
<h3 id="光照队列记录器采样时长-lightQueueLoggerSamplingDuration"><a class="header-anchor" href="#光照队列记录器采样时长-lightQueueLoggerSamplingDuration"></a>光照队列记录器采样时长 (lightQueueLoggerSamplingDuration)</h3>
<blockquote>
<p>光照队列记录器的采样时长，单位为游戏刻。影响记录器中显示的，除队列大小外的所有数据</p>
</blockquote>
<p>光照队列记录器（<code>lightQueue</code>）所使用的的一个参数</p>
<h3 id="移动记录器-loggerMovement"><a class="header-anchor" href="#移动记录器-loggerMovement"></a>移动记录器 (loggerMovement)</h3>
<blockquote>
<p>移动记录器的开关 / 权限等级需求</p>
</blockquote>
<p>移动记录器（<code>movement</code> logger）并不是一个适合在生存服中使用的记录器，毕竟它容易刷屏 + 会暴露其他玩家的位置信息，最好还是加个权限开关来控制下</p>
<h3 id="怪物容量显示忽略杂项-mobcapsDisplayIgnoreMisc"><a class="header-anchor" href="#怪物容量显示忽略杂项-mobcapsDisplayIgnoreMisc"></a>怪物容量显示忽略杂项 (mobcapsDisplayIgnoreMisc)</h3>
<blockquote>
<p>在 carpet 怪物容量显示中忽略杂项 (misc) 这一生物类型</p>
<p>因为它既占空间还没用：杂项生物类型不参与刷怪循环，在统计怪物容量时也被游戏忽略</p>
<p>影响 mobcaps 记录器以及 <code>/spawn mobcaps</code> 指令</p>
</blockquote>
<p>占空间还没用的数据，当然是选择删掉啦</p>
<h3 id="op玩家不准作弊-opPlayerNoCheat"><a class="header-anchor" href="#op玩家不准作弊-opPlayerNoCheat"></a>op玩家不准作弊 (opPlayerNoCheat)</h3>
<blockquote>
<p>禁用部分指令以避免op玩家意外地作弊</p>
<p>影响的指令列表：<code>/gamemode</code>, <code>/tp</code>, <code>/teleport</code>, <code>/give</code>, <code>/setblock</code>, <code>/summon</code></p>
</blockquote>
<p>在拥有 OP 权限的情况下有时候会不小心误触到一些作弊的快捷键，包括：</p>
<ul>
<li>原版的 F3 + N、F3 +F4 切换游戏模式（<code>/gamemode</code>）</li>
<li>小地图模组里的选点传送（<code>/tp</code>、<code>/teleport</code>）</li>
<li>JEI 等物品列表显示模组中的物品给予（<code>/give</code>）</li>
<li>投影模组粘贴原理图的方块放置与实体召唤（<code>/setblock</code>、<code>/summon</code>）</li>
</ul>
<p>虽说是无意触发的，但总会烦人，不如直接禁掉这些指令，不准这些指令给任何玩家执行。这也正是本条规则的功能</p>
<p>当然如果你真的需要使用这些被禁用指令的话，把本条规则关闭即可</p>
<h3 id="持久性记录器订阅-persistentLoggerSubscription"><a class="header-anchor" href="#持久性记录器订阅-persistentLoggerSubscription"></a>持久性记录器订阅 (persistentLoggerSubscription)</h3>
<blockquote>
<p>在服务器重启后依然记忆着玩家订阅的记录器及记录器选项</p>
<p>仅在玩家首次登录时应用 carpet 的 <code>defaultLoggers</code> 规则</p>
<p>记录器订阅储存于 <code>config/carpettisaddition/logger_subscriptions.json</code> 中</p>
</blockquote>
<p>虽说 fabric carpet 有着一个叫 <code>defaultLoggers</code> 的规则，让玩家上线后可以自动订阅一些记录器，但单一一条规则显然不能满足每名玩家的个性化自定义需求</p>
<p>换个角度想想，只要我们记忆着玩家所订阅的记录器，以及记录器的选项，并在玩家下次登录时自动回复订阅，不仅能避免玩家每次上线时都得重新订阅的繁琐，还能满足每名玩家的个性化订阅需求</p>
<h3 id="stop指令两步确认-stopCommandDoubleConfirmation"><a class="header-anchor" href="#stop指令两步确认-stopCommandDoubleConfirmation"></a>stop指令两步确认 (stopCommandDoubleConfirmation)</h3>
<blockquote>
<p>为 <code>/stop</code> 指令添加两步确认机制，以防止误触导致意外地关掉了服务器。你需要在1分钟内输入两次 <code>/stop</code> 指令来关闭服务器。该确认机制仅对玩家有效</p>
</blockquote>
<p>一波操作猛如虎，<code>/st</code> + tab 一顿敲，一按回车服务器无。这种输错指令把服务器关掉了的情况是小天才最喜欢干的事，比如在敲 <code>//stack</code> 时少打了个 <code>/</code></p>
<p>对于这种手抖问题，加一个两步确认就能很好的避免了</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/stopCommandDoubleConfirmation.gif" alt="stopCommandDoubleConfirmation"></p>
<h3 id="可视化投掷物记录器-visualizeProjectileLoggerEnabled"><a class="header-anchor" href="#可视化投掷物记录器-visualizeProjectileLoggerEnabled"></a>可视化投掷物记录器 (visualizeProjectileLoggerEnabled)</h3>
<blockquote>
<p>启用可视化投掷物记录器。试试 <code>/log projectiles visualize</code> 吧</p>
</blockquote>
<p>为投掷物每游戏刻所在位置，以及投掷物的撞击点，召唤一个固定的不与红石交互的雪球，指示投掷物的运动轨迹</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/visualizeProjectileLoggerEnabled.jpg" alt="visualizeProjectileLoggerEnabled"></p>
<h3 id="阻止更新抑制崩溃-yeetUpdateSuppressionCrash"><a class="header-anchor" href="#阻止更新抑制崩溃-yeetUpdateSuppressionCrash"></a>阻止更新抑制崩溃 (yeetUpdateSuppressionCrash)</h3>
<blockquote>
<p>阻止服务端因栈溢出异常造成崩溃。具体功能实现类似 carpet 的 <code>updateSuppressionCrashFix</code> 规则，但包含更多信息</p>
</blockquote>
<p>并不是所有版本的 fabric carpet / carpet extra 都提供了更新抑制防崩服的规则。对于那些缺失 <code>updateSuppressionCrashFix</code> 的场景，就是本规则派上用场的时候了</p>
<p>借助微时序记录器同款游戏阶段记录功能，该规则可在更新抑制崩服时提供更加丰富的信息</p>
<p><img data-src="/zh-CN/2022/introduction-to-carpet-tis-addition_rules/yeetUpdateSuppressionCrash.png" alt="yeetUpdateSuppressionCrash"></p>
<p>若 fabric carpet / carpet extra 存在规则 <code>updateSuppressionCrashFix</code>，本规则会自动禁用，以避免发生冲突</p>
<ul>
<li>移植自：
<ul>
<li>fabric carpet <a href="https://github.com/gnembon/fabric-carpet/releases/tag/1.4.50">1.4.50</a> 的规则 <code>updateSuppressionCrashFix</code></li>
<li>TISCarpet13 <a href="https://github.com/TISUnion/TISCarpet113/releases/tag/build238">build238</a> 的规则 <code>yeetUpdateSuppressionCrash</code></li>
</ul>
</li>
<li>冲突版本：
<ul>
<li>fabric carpet: <code>[1.4.49, 1.4.76]</code></li>
<li>carpet extra: <code>[1.4.14, 1.4.43]</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Carpet TIS Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>Minecraft 开发环境 Intellij IDE 的 Run Configuration 损坏修复</title>
    <url>/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/</url>
    <content><![CDATA[<h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2>
<p>在升级 Intellij IDEA、修改系统中的 JDK 配置后，打开某些许久未启动的项目时，
总易发现已存在的，用于启动 Minecraft Server 或 Minecraft Client 的 Run Configuration 会被 IDEA 标红，无法运行</p>
<p><img data-src="/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/run-configuration-error.png" alt="一堆错误"></p>
<p>直接把这些 Run Configuration 删掉并运行 Gradle 任务自动生成一份？并不能解决问题，新生成的 Run Configuration 依然是红彤彤的</p>
<p>简单粗暴地把 <code>.idea</code> 文件夹删掉，再重启打开这个项目？这固然能解决问题，但这个项目已有的 IDEA 项目配置数据等都会消失不见</p>
<p>有没有什么简单有效且不破坏 IDEA 项目配置数据的好方法呢？</p>
<span id="more"></span>
<h2 id="说明"><a class="header-anchor" href="#说明"></a>说明</h2>
<p>本文只考虑如下这种典型的 MC 开发环境：</p>
<ul>
<li>使用 Intellij IDEA 这个 IDE</li>
<li>装有 <a href="https://plugins.jetbrains.com/plugin/8327-minecraft-development">Minecraft Development</a> 这个插件</li>
<li>使用 Gradle 管理 Java 项目</li>
<li>使用 <a href="https://github.com/FabricMC/fabric-loom">Loom</a> / <a href="https://github.com/architectury/architectury-loom">Architectury Loom</a> 来配置 MC mod 开发环境</li>
</ul>
<p>其他环境下若出现了类似问题，本文的提供方法不保证能用</p>
<p>本人能力有限，所提供的方法可能不够完善，存在一定局限性。如有大佬有更优雅、更治本的解决方案，或发现本文有遗漏或疏忽，欢迎随时指出</p>
<h2 id="修复方法"><a class="header-anchor" href="#修复方法"></a>修复方法</h2>
<p>方法很简单，只需删掉两个文件即可。具体步骤如下：</p>
<ol>
<li>关闭 Intellij IDEA。只需关掉这个项目的窗口就行了</li>
<li>去项目文件夹里，删掉这两个文件</li>
</ol>
<ul>
<li><code>.idea/misc.xml</code></li>
<li><code>.idea/modules.xml</code></li>
</ul>
<ol start="3">
<li>重新用 Intellij IDEA 打开这个项目。如果发现项目文件结构变成下图这样也问题不大，继续操作</li>
</ol>
<p><img data-src="/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/delete-and-reopen.png" alt="重新打开 IDEA"></p>
<ol start="4">
<li>菜单栏选择 File - Project Structure 打开窗口，重新配置 SDK，选择要用的那个 JDk，然后确认</li>
</ol>
<p><img data-src="/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/configure-jdk.png" alt="配置 SDK"></p>
<ol start="5">
<li>最后，Sync 一下 Gradle 项目</li>
</ol>
<p><img data-src="/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/sync-gradle.png" alt="sync 一下"></p>
<ol start="6">
<li>等 Gradle Sync 结束，Intellij 处理完 Sync 结果后，就修好了。每个 Run Configuration 都不再泛红，可以正常运行，且之前的 Run Configuration 配置都完好如初</li>
</ol>
<p><img data-src="/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/run-configuration-fixed.png" alt="修好啦"></p>
<p>如果 Gradle Sync 会失败的话，建议先检查下自己的项目是否有 bug，毕竟上述操作都不影响此 gradle 项目的可运行性</p>
<h2 id="为啥这能修好"><a class="header-anchor" href="#为啥这能修好"></a>为啥这能修好</h2>
<p>（我猜的）删掉 <code>.idea/</code> 文件夹下的 <code>misc.xml</code>、<code>modules.xml</code> 这俩文件，
就能重新触发 Intellij IDEA 某些配置的重新生成，借此就可以把原来的一些过时/损坏的配置给自动修好了：</p>
<ul>
<li>删 <code>misc.xml</code> 能重新配置每个 Run Configuration 所使用的 JDK</li>
<li>删 <code>modules.xml</code> 能重新生成了每个子项目的 Modules 配置</li>
</ul>
<p><img data-src="/zh-CN/2025/minecraft-dev-intellij-run-config-error-fix/project-modules.png" alt="modules"></p>
<h2 id="中英对照表"><a class="header-anchor" href="#中英对照表"></a>中英对照表</h2>
<p>对于那些 Intellij IDEA 的语言设置为简体中文的读者，可参考如下中英对照表</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>Run Configuration</td>
<td>运行配置</td>
</tr>
<tr>
<td>File - Project Structure</td>
<td>文件 - 项目结构</td>
</tr>
<tr>
<td>Gradle Sync</td>
<td>同步 Gradle</td>
</tr>
<tr>
<td>Project</td>
<td>项目</td>
</tr>
<tr>
<td>Modules</td>
<td>模块</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Intellij IDEA</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>对实体查询在 LongAVLTreeSet.Subset 引发 IllegalArgumentException 的分析</title>
    <url>/zh-CN/2025/minecraft-server-crash-avltreeset-subset-iea/</url>
    <content><![CDATA[<p>日常运维 OSTC，发现有服务端崩溃现象。瞅了眼 <code>crash-report</code> 文件夹，看到了如下的崩溃日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---- Minecraft Crash Report ----</span><br><span class="line">// Don&#x27;t do that.</span><br><span class="line"></span><br><span class="line">Time: 2025-08-12 21:07:57</span><br><span class="line">Description: Ticking entity</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: Start element (9223367638808264704) is larger than end element (-9223372036854775808)</span><br><span class="line">	at it.unimi.dsi.fastutil.longs.LongAVLTreeSet$Subset.&lt;init&gt;(LongAVLTreeSet.java:1080)</span><br><span class="line">	at it.unimi.dsi.fastutil.longs.LongAVLTreeSet.subSet(LongAVLTreeSet.java:1047)</span><br><span class="line">	at net.minecraft.class_5573.method_31777(class_5573.java:57)</span><br><span class="line">	at net.minecraft.class_5573.method_31783(class_5573.java:122)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">-- Entity being ticked --</span><br><span class="line">Details:</span><br><span class="line">	Entity Type: minecraft:arrow (net.minecraft.class_1667)</span><br><span class="line">	Entity ID: 15871</span><br><span class="line">	Entity Name: Arrow</span><br><span class="line">	Entity&#x27;s Exact location: 28.28, 90.00, 15.78</span><br><span class="line">	Entity&#x27;s Block location: World: (28,89,15), Section: (at 12,9,15 in 1,5,0; chunk contains blocks 16,0,0 to 31,255,15), Region: (0,0; contains chunks 0,0 to 31,31, blocks 0,0,0 to 511,255,511)</span><br><span class="line">	Entity&#x27;s Momentum: -98941291.49, -0.02, -50361527.12</span><br><span class="line">	Entity&#x27;s Passengers: []</span><br><span class="line">	Entity&#x27;s Vehicle: null</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可发现，是一个超高速箭矢实体，在移动计算时，于 <code>LongAVLTreeSet$Subset</code> 里触发了 <code>IllegalArgumentException</code> 异常</p>
<p>是之前没见过的崩服场景，得分析一波</p>
<span id="more"></span>
<p><strong>省流</strong></p>
<p><img data-src="/zh-CN/2025/minecraft-server-crash-avltreeset-subset-iea/summary.png" alt="summary"></p>
<h2 id="背景知识"><a class="header-anchor" href="#背景知识"></a>背景知识</h2>
<p>简单提一下分析所涉及的一些背景知识，以便后续分析使用（主要是得讲清楚“区段坐标索引”这个概念）</p>
<p>下述分析均使用 yarn 1.21.1+build.1 作为反混淆表，并调整了下局部变量的命名</p>
<p>相关代码自 1.17 开始至今（1.21.8）都长得几乎一样，基本可以直接参考</p>
<h3 id="区段"><a class="header-anchor" href="#区段"></a>区段</h3>
<p>区段，或者说子区块，是一个 16x16x16 的范围概念</p>
<p>任意一个世界坐标 $(x, y, z)$
归属的区段坐标 = $(\left\lfloor\frac{x}{16}\right\rfloor, \left\lfloor\frac{y}{16}\right\rfloor, \left\lfloor\frac{z}{16}\right\rfloor)$</p>
<h3 id="查询范围实体"><a class="header-anchor" href="#查询范围实体"></a>查询范围实体</h3>
<p>MC 里存在非常多的“查询一个长方体范围内的实体列表”的操作，如碰撞检测、活塞推实体、横扫攻击、矿车载客等</p>
<p>最简单的实现“查询范围实体”的方式，就是直接遍历一遍当前世界里的全部实体，挨个检查实体碰撞箱是否与给定范围相交，但这显然效率太低了</p>
<p>一种简单有效的实现，就是对 MC 这个三维世界进行分块处理，如将整个世界切成一个个 <a href="#%E5%8C%BA%E6%AE%B5">区段</a>。
然后，给每个区段维护一份实体列表，储存着坐标位于此区段的实体。
在查询范围实体时，只需要找到与给定范围相交的那些区段，再遍历这些区段里的实体就行了，这样就无需检查那些坐标离得老远的实体了。</p>
<p>注：具体实现“找到与给定范围相交的那些区段”时，会扩大一些查询范围，以适配大碰撞箱的实体</p>
<h3 id="区段坐标索引"><a class="header-anchor" href="#区段坐标索引"></a>区段坐标索引</h3>
<p>为了高效地储存“给每个区段维护一份实体列表”的若干个区段级实体列表，需要搞一个“区段坐标” -&gt; “实体列表”的映射表。
麻将考虑到区段坐标的取值并不会很大，于是把区段坐标映射成一个 64 位整数 long，然后把这个 long 作为映射表的索引</p>
<p>将区段坐标映射成整数索引的实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net.minecraft.util.math.ChunkSectionPos#asLong(int, int, int)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">asLong</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    index |= (x &amp; <span class="number">4194303L</span>) &lt;&lt; <span class="number">42</span>;  <span class="comment">// 取 x 的低 22 位，贴到 index 的最高 22 位上</span></span><br><span class="line">    index |= (y &amp; <span class="number">1048575L</span>) &lt;&lt; <span class="number">0</span>;   <span class="comment">// 取 y 的低 20 位，贴到 index 的最低 20 位上</span></span><br><span class="line">    index |= (z &amp; <span class="number">4194303L</span>) &lt;&lt; <span class="number">20</span>;  <span class="comment">// 取 z 的低 22 位，贴到 index 的中间 22 位上</span></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值 index 的 64 个 bit 的结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+---------------------+--------------------+</span><br><span class="line">|     x (22 bits)     |     z (22 bits)     |     y (20 bits)    |</span><br><span class="line">+---------------------+---------------------+--------------------+</span><br><span class="line">63 (High)           42 41                 20 19            (Low) 0</span><br></pre></td></tr></table></figure>
<h2 id="分析开始"><a class="header-anchor" href="#分析开始"></a>分析开始</h2>
<p>先把堆栈跟踪搞映射到 yarn，好看些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Start element (9223367638808264704) is larger than end element (-9223372036854775808)</span><br><span class="line">	at it.unimi.dsi.fastutil.longs.LongAVLTreeSet$Subset.&lt;init&gt;(LongAVLTreeSet.java:1080)</span><br><span class="line">	at it.unimi.dsi.fastutil.longs.LongAVLTreeSet.subSet(LongAVLTreeSet.java:1047)</span><br><span class="line">	at net.minecraft.world.entity.SectionedEntityCache.forEachInBox(SectionedEntityCache.java:57)</span><br><span class="line">	at net.minecraft.world.entity.SectionedEntityCache.forEachIntersects(SectionedEntityCache.java:122)</span><br><span class="line">	at net.minecraft.world.entity.SimpleEntityLookup.forEachIntersects(SimpleEntityLookup.java:43)</span><br><span class="line">	at net.minecraft.world.World.getOtherEntities(World.java:695)</span><br><span class="line">	at net.minecraft.entity.projectile.ProjectileEntity.shouldLeaveOwner(ProjectileEntity.java:125)</span><br><span class="line">	at net.minecraft.entity.projectile.ProjectileEntity.tick(ProjectileEntity.java:116)</span><br><span class="line">	at net.minecraft.entity.projectile.PersistentProjectileEntity.tick(PersistentProjectileEntity.java:173)</span><br><span class="line">	at net.minecraft.entity.projectile.ArrowEntity.tick(ArrowEntity.java:74)</span><br><span class="line">	at net.minecraft.server.world.ServerWorld.tickEntity(ServerWorld.java:770)</span><br></pre></td></tr></table></figure>
<p>可发现，是查询世界指定范围内实体的 <code>World.getOtherEntities</code> 的调用发生了崩溃。这个调用栈看起来挺原版的，那可能大概率是原版的
bug</p>
<p>先重点观察 <code>SectionedEntityCache.forEachInBox</code> 这个调用 <code>LongAVLTreeSet.subSet</code> 的地方。代码和分析如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net.minecraft.world.entity.SectionedEntityCache#forEachInBox</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachInBox</span><span class="params">(Box box, LazyIterationConsumer&lt;EntityTrackingSection&lt;T&gt;&gt; consumer)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算要查询的区段坐标的范围</span></span><br><span class="line">    <span class="comment">// 这里的 +-2.0 这种微调，是用来处理大体积碰撞箱实体。比如 2.0 就是因为目前水平最胖的实体恶魂的宽度是 4，4 / 2 = 2</span></span><br><span class="line">    <span class="comment">// ChunkSectionPos.getSectionCoord(x) 的结果等于 floor(x / 16)（向下取整）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sectionMinX</span> <span class="operator">=</span> ChunkSectionPos.getSectionCoord(box.minX - <span class="number">2.0</span>);  <span class="comment">// 查询的区段坐标范围的 X 下界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sectionMinY</span> <span class="operator">=</span> ChunkSectionPos.getSectionCoord(box.minY - <span class="number">4.0</span>);  <span class="comment">// 查询的区段坐标范围的 Y 下界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sectionMinZ</span> <span class="operator">=</span> ChunkSectionPos.getSectionCoord(box.minZ - <span class="number">2.0</span>);  <span class="comment">// 查询的区段坐标范围的 Z 下界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sectionMaxX</span> <span class="operator">=</span> ChunkSectionPos.getSectionCoord(box.maxX + <span class="number">2.0</span>);  <span class="comment">// 查询的区段坐标范围的 X 上界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sectionMaxY</span> <span class="operator">=</span> ChunkSectionPos.getSectionCoord(box.maxY + <span class="number">0.0</span>);  <span class="comment">// 查询的区段坐标范围的 Y 上界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sectionMaxZ</span> <span class="operator">=</span> ChunkSectionPos.getSectionCoord(box.maxZ + <span class="number">2.0</span>);  <span class="comment">// 查询的区段坐标范围的 Z 上界</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面要遍历 (sectionMinX, sectionMinY, sectionMinZ) -&gt; (sectionMaxX, sectionMaxY, sectionMaxZ) 这个区段坐标范围的所有区段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sectionX</span> <span class="operator">=</span> sectionMinX; sectionX &lt;= sectionMaxX; sectionX++) &#123;  <span class="comment">// 遍历区段坐标的 X</span></span><br><span class="line">        <span class="comment">// this.trackedPositions 是一个有序的 long 集合 LongAVLTreeSet，储存着所有含实体的区段坐标（通过 ChunkSectionPos.asLong 计算）</span></span><br><span class="line">        <span class="comment">// 下面这两行用于计算出满足 trackedPositions 里，所有区段 X 坐标等于 sectionX 的 index 的取值范围</span></span><br><span class="line">        <span class="comment">// 注意 ChunkSectionPos.asLong 返回值的结构，X 贡献的 bit 位于 index 的高位，Y,Z 的 bit 则位于低位，因此：</span></span><br><span class="line">        <span class="comment">//   把 Y,Z 的 bit 全部设置为 0，即可得到最小值 [x bits][42个0]</span></span><br><span class="line">        <span class="comment">//   将 Y,Z 的 bit 全部设置为 1，即可得到最大值 [x bits][42个1]</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">indexLower</span> <span class="operator">=</span> ChunkSectionPos.asLong(sectionX, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 获得 index 的最小值（闭区间）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">indexUpper</span> <span class="operator">=</span> ChunkSectionPos.asLong(sectionX, -<span class="number">1</span>, -<span class="number">1</span>);  <span class="comment">// 获得 index 的最大值（闭区间）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这一行代码在调用 subSet 时抛异常了</span></span><br><span class="line">        <span class="type">LongIterator</span> <span class="variable">iter</span> <span class="operator">=</span> <span class="built_in">this</span>.trackedPositions.subSet(indexLower, indexUpper + <span class="number">1</span>).iterator();  <span class="comment">// 这一行抛异常了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 longIterator，对可能的区段坐标执行后续操作</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> iter.nextLong();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sectionY</span> <span class="operator">=</span> ChunkSectionPos.unpackY(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sectionZ</span> <span class="operator">=</span> ChunkSectionPos.unpackZ(index);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>LongAVLTreeSet.subSet</code> 这个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// it.unimi.dsi.fastutil.longs.LongSortedSet#subSet(long, long)</span></span><br><span class="line">LongSortedSet <span class="title function_">subSet</span><span class="params">(<span class="type">long</span> fromElement, <span class="type">long</span> toElement)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数是用来查询 <code>[fromElement, toElement)</code> 这个区间子集内的元素的。若 <code>fromElement</code> &gt; <code>toElement</code>，就会因区间非法而抛出
<code>IllegalArgumentException</code></p>
<p>这意味着，<code>this.trackedPositions.subSet(indexLower, indexUpper + 1)</code> 这个调用里，出现了 <code>indexLower &gt; indexUpper + 1</code>
的非预期情况</p>
<p>重点观察这里 <code>indexLower</code>、<code>indexUpper</code> 计算方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">indexLower</span> <span class="operator">=</span> ChunkSectionPos.asLong(sectionX, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 获得 index 的最小值（闭区间）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">indexUpper</span> <span class="operator">=</span> ChunkSectionPos.asLong(sectionX, -<span class="number">1</span>, -<span class="number">1</span>);  <span class="comment">// 获得 index 的最大值（闭区间）</span></span><br><span class="line"><span class="type">LongIterator</span> <span class="variable">iter</span> <span class="operator">=</span> <span class="built_in">this</span>.trackedPositions.subSet(indexLower, indexUpper + <span class="number">1</span>).iterator();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+---------------------+--------------------+</span><br><span class="line">|     x (22 bits)     |     z (22 bits)     |     y (20 bits)    |</span><br><span class="line">+---------------------+---------------------+--------------------+</span><br><span class="line">63 (High)           42 41                 20 19            (Low) 0</span><br></pre></td></tr></table></figure>
<p>重点来了。若 <code>sectionX == 2097151</code> 时，<code>sectionX</code> 的二进制表达将会是 21 个 1。此时会有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indexLower     == <span class="number">0111111111111111111111000000000000000000000000000000000000000000</span>  <span class="comment">// [0][21 个 1][42 个 0]</span></span><br><span class="line">indexUpper     == <span class="number">0111111111111111111111111111111111111111111111111111111111111111</span>  <span class="comment">// [0][63 个 1]</span></span><br><span class="line">indexUpper + <span class="number">1</span> == <span class="number">1000000000000000000000000000000000000000000000000000000000000000</span>  <span class="comment">// [1][63 个 0]</span></span><br><span class="line"><span class="comment">//                 [      21 bits      ][                 63 bits                ]</span></span><br></pre></td></tr></table></figure>
<p>这里有：</p>
<ul>
<li><code>indexUpper</code> 的取值为 long 类型的最大值 <code>Long.MAX_VALUE</code></li>
<li><code>indexUpper + 1</code> 将发生有符号整数上溢，变成 long 类型的最小值 <code>Long.MIN_VALUE</code>，是一个负数</li>
<li>此时将发生 <code>indexLower &gt; indexUpper + 1</code>，触发 <code>IllegalArgumentException</code> 异常</li>
</ul>
<h3 id="触发条件"><a class="header-anchor" href="#触发条件"></a>触发条件</h3>
<p>不难发现，要触发这一异常，<code>sectionX</code> 的二进制的低 22 位必须等于 2097151，也即 <code>[0][21 个 1]</code>，才能触发这个 bug。
这是因为只有这个时候，<code>ChunkSectionPos.asLong(sectionX, -1, -1)</code> 才能计算得到 <code>Long.MAX_VALUE</code>，最终 +1 上溢成负数。</p>
<p>因此，该 bug 的触发条件为：</p>
<p>$$sectionX\ \texttt{&amp;} \ (2^{22}-1) = 2^{21}-1$$</p>
<p>这里 <code>sectionX</code> 表示区段坐标的 X 值， <code>&amp;</code> 表示位运算取与</p>
<p>稍加变形，可得到：</p>
<p>$$sectionX\ \ mod\ \ 2^{22} = 2^{21}$$</p>
<p>或者</p>
<p>$$\left\lfloor\frac{x}{16}\right\rfloor\ \ mod\ \ 2^{22} = 2^{21}$$</p>
<p>若“查询范围实体”操作传入的范围涵盖了满足上述条件的区段时，则会触发此 bug</p>
<p>一些常见的取值，同时也是 sectionX 的绝对值最小的两个取值：</p>
<table>
<thead>
<tr>
<th>sectionX</th>
<th>X 坐标范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>2097151</td>
<td>[33554416, 33554432)</td>
</tr>
<tr>
<td>-2097153</td>
<td>[-33554448, -33554432)</td>
</tr>
</tbody>
</table>
<p>注意到这里 X 坐标范围已经是三千多万了，超过了三千万这个世界边境大小，是位于边境之外的</p>
<p>应该也正因如此，麻将才会如此设计，给 x 和 z 保留了 22 个 bit。不过这也不是可恶的麻将偷懒不做范围检查的借口。
有边界条件没问题，不处理边界条件就妥妥地是麻将的问题</p>
<p>由于这个坐标范围已经到了边境之外了，并且也远超出了边境范围，因此这个 bug 日常难以触发，基本只有在玩超高速实体时才会遇到，如：</p>
<ul>
<li>蓄力边境珍珠炮 / 箭炮</li>
<li>INF 速度的矿车 + 继承矿车速度的实体</li>
</ul>
<h2 id="影响范围"><a class="header-anchor" href="#影响范围"></a>影响范围</h2>
<p>从 20w45a（1.17 快照）至今（1.21.8、25w37a）所有版本</p>
<p>注意一些优化 mod（如 1.17.1 的 Lithium 0.7.5）对实体移动的一些修改优化可能导致该 bug 无法被触发</p>
<h2 id="修复"><a class="header-anchor" href="#修复"></a>修复</h2>
<p><a href="https://github.com/TISUnion/Carpet-TIS-Addition">Carpet-TIS-Addition</a> 在 <a href>v1.69.0</a>
加了个规则 <a href="https://carpet.tis.world/zh-Hans/docs/rules#%E5%AE%9E%E4%BD%93%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%8C%BA%E6%AE%B5%E7%B4%A2%E5%BC%95x%E4%B8%8A%E6%BA%A2%E4%BF%AE%E5%A4%8D-entitychunksectionindexxoverflowfix"><code>entityChunkSectionIndexXOverflowFix</code></a>。把它设置成 true 就好了</p>
<p>后续也许可能会考虑做个独立的 fix mod，更轻量一些</p>
]]></content>
      <tags>
        <tag>Minecraft</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次对 Minecraft 服务器关闭时，进程无法完全退出的问题分析</title>
    <url>/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/</url>
    <content><![CDATA[<p>一次平常的 Minecraft 服务器运维，在把服务端 <code>/stop</code> 后，却发现服务端进程久久未能关闭</p>
<p><img data-src="/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/server_output.png" alt="服务端输出"></p>
<p>反常必有妖，让我看看是谁在干坏事</p>
<span id="more"></span>
<h2 id="问题排查"><a class="header-anchor" href="#问题排查"></a>问题排查</h2>
<h3 id="环境"><a class="header-anchor" href="#环境"></a>环境</h3>
<p>先列一下基本环境：</p>
<ul>
<li>Minecraft 1.20.1</li>
<li>Fabric loader 0.15.11，带不少创造服相关 mod</li>
<li>OpenJDK 21.0.4</li>
</ul>
<h3 id="初步分析"><a class="header-anchor" href="#初步分析"></a>初步分析</h3>
<p>由于 MC 服务端是带着 MCDR 运行的，先用 <code>!!MCDR status</code> 看一下进程 PID</p>
<p><img data-src="/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/mcdr_status.png" alt="!!MCDR status"></p>
<p>拿到 java 进程的 PID <code>4409</code> 后，用 <code>jstack</code> 工具看一下每个线程都在干啥，看看有没有啥异常的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jstack 4409 &gt; jstack.out</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> jstack.out | grep <span class="string">&#x27;Server Thread&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>找不到 MC 服务端主线程 <code>Server Thread</code>，说明 MC 服务端主线程已经结束了。那估计是有非 daemon thread 在搞事情</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> jstack.out | grep <span class="string">&#x27; #&#x27;</span> | grep -v daemon</span></span><br><span class="line">&quot;DestroyJavaVM&quot; #79 [4418] prio=5 os_prio=0 cpu=6699.00ms elapsed=628699.38s tid=0x00007f041002a3c0 nid=4418 waiting on condition  [0x0000000000000000]</span><br><span class="line">&quot;Timer-1&quot; #6712 [54030] prio=8 os_prio=0 cpu=0.50ms elapsed=266535.65s tid=0x00007f02bd8d8270 nid=54030 in Object.wait()  [0x00007f02686d4000]</span><br></pre></td></tr></table></figure>
<p>这个 <code>Timer-1</code> 进程看上去很可疑，看下它的堆栈</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> jstack.out | grep <span class="string">&#x27;#6712&#x27;</span> -A 9</span></span><br><span class="line">&quot;Timer-1&quot; #6712 [54030] prio=8 os_prio=0 cpu=0.50ms elapsed=266535.65s tid=0x00007f02bd8d8270 nid=54030 in Object.wait()  [0x00007f02686d4000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait0(java.base@21.0.4/Native Method)</span><br><span class="line">	- waiting on &lt;no object reference available&gt;</span><br><span class="line">	at java.lang.Object.wait(java.base@21.0.4/Object.java:366)</span><br><span class="line">	at java.lang.Object.wait(java.base@21.0.4/Object.java:339)</span><br><span class="line">	at java.util.TimerThread.mainLoop(java.base@21.0.4/Timer.java:537)</span><br><span class="line">	- locked &lt;0x000000071178fcd8&gt; (a java.util.TaskQueue)</span><br><span class="line">	at java.util.TimerThread.run(java.base@21.0.4/Timer.java:516)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本能确定是这个 <code>TimerThread</code> 在搞事情了</p>
<h3 id="java-util-Timer"><a class="header-anchor" href="#java-util-Timer"></a><code>java.util.Timer</code></h3>
<p>阅读了下 jdk21 里 <code>java.util.Timer</code> 的代码，能看到在默认构造函数的情况下，<code>Timer</code> 会创建一个非 daemon 的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;Timer-&quot;</span> + serialNumber());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(<span class="type">boolean</span> isDaemon)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;Timer-&quot;</span> + serialNumber(), isDaemon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name, <span class="type">boolean</span> isDaemon)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">threadReaper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadReaper</span>(queue, thread);</span><br><span class="line">    <span class="built_in">this</span>.cleanup = CleanerFactory.cleaner().register(<span class="built_in">this</span>, threadReaper);</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.setDaemon(isDaemon);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先猜一个，有坏东西创建一个非 daemon 的 timer 且忘了关，导致服务端关不掉</p>
<p>先看看是不是 mojang 在干坏事。在 MC 1.20.1 的源代码里翻了一遍 <code>java.util.Timer</code> 的引用，
服务端的相关代码里只看到 watchdog 里有用 timer，且那个 timer 是拿来兜底关进程的，应该并不相关</p>
<p>怀疑是不是 mod 在干坏事了</p>
<h3 id="heap-dump"><a class="header-anchor" href="#heap-dump"></a>heap dump</h3>
<p>一个一个翻 mod 代码可能比较费时间，先再从现场保留一些信息下来，搞个 heap dump 看下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof 4409</span><br></pre></td></tr></table></figure>
<p>把 <code>heapdump.hprof</code> 搞到本地，拿 jprofiler 打开，过滤下 <code>java.util.Timer</code> 对象，发现只有俩</p>
<p><img data-src="/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/jprofiler_1.png" alt="jprofiler_1"></p>
<p>找到那个 <code>tid=6712</code> 的对象 <code>0x1728d8</code></p>
<p><img data-src="/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/jprofiler_2.png" alt="jprofiler_2"></p>
<p>看看传入引用</p>
<p><img data-src="/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/jprofiler_3.png" alt="jprofiler_3"></p>
<p>发现凶手了，是 WorldEdit（<code>worldedit-mod-7.2.15.jar</code>） 在干坏事</p>
<h3 id="确定问题"><a class="header-anchor" href="#确定问题"></a>确定问题</h3>
<p>直接把 mod 的 jar 搞下来，反编译一下，这样比翻 git 仓库的版本更快也更准些</p>
<p>找到 <code>com.sk89q.worldedit.command.util.FutureProgressListener</code> 这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureProgressListener</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">   <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>罪魁祸首找到了。这个 <code>FutureProgressListener</code> 类搞了个全局的 timer，还是非 daemon thread 的 timer，搞的服务端关也关不掉</p>
<p>考虑到这个问题并非是必现的（如果必现，早就被人发现了），再去看下代码。如果 <code>FutureProgressListener</code> 这个类被加载了，其 static timer 对象就会被构造，就会导致服务端关不掉，
那就意味着，只要服务端从不使用、不加载这个 <code>FutureProgressListener</code> 类，就不会有问题</p>
<p>看一下 <code>FutureProgressListener</code> 在 WorldEdit 代码里的使用情况，能看到它会在几个异步指令的执行处被触发（代码关键字：<code>com.sk89q.worldedit.command.util.AsyncCommandBuilder#buildAndExec</code>），比如</p>
<ul>
<li>加载、保存 schematic 文件</li>
<li><code>/searchitem</code>、<code>listchunks</code> 等指令</li>
</ul>
<p>如果服务器运行过程中没触发相关逻辑的话，服务端即可正常关闭</p>
<p>尝试着复现了一下：仅保留 <code>worldedit-mod-7.2.15.jar</code> 这个 mod，开服，输入 <code>/searchitem stone</code>，<code>/stop</code>，服务端果然卡着了</p>
<p>确定了触发路径，再看看影响范围，这次不得不打开 <a href="https://github.com/EngineHub/WorldEdit">WorldEdit 的 git 仓库</a> 了</p>
<p>对着 <code>private static final Timer timer = new Timer();</code> 这行来一个 Git &gt; Show History for Selection，确定影响范围：
从 7.0.0-beta-05 开始的版本，均受影响。这基本上可以说是，MC 1.13 以上的，至目前最新的 MC 1.21 的 WorldEdit 7.3.7，均受影响。影响范围还蛮大的</p>
<p><img data-src="/zh-CN/2024/minecraft-server-hang-on-shutdown-analysis/git_history.png" alt="git history"></p>
<p>这么看上去，说不定这个 bug 也是 <a href="https://github.com/MCDReforged/MCDReforged/issues/150">MCDR 的某个疑难 issue</a> 的根因</p>
<p>不管怎么说，得给 WorldEdit 交了个 issue。搜下 issue 列表，发现了个 <a href="https://github.com/EngineHub/WorldEdit/issues/2459">已存在的 issue</a>，但被 close 了，
那就补上一波详细说明：<a href="https://github.com/EngineHub/WorldEdit/issues/2459#issuecomment-2412020684">https://github.com/EngineHub/WorldEdit/issues/2459#issuecomment-2412020684</a></p>
<p>总的来讲，WorldEdit 存在两个影响服务器支持关闭的 bug：</p>
<ol>
<li><code>FutureProgressListener</code> 存在一个非 daemon thread 运行的 <code>Timer</code>，导致服务端关闭时会永久卡住。这也是本文发现的 bug</li>
<li><code>WorldEdit.getInstance().getExecutorService()</code> 未在服务器关闭时 <code>shutdown</code>。这最多会卡住服务端 60s</li>
</ol>
<p>等 WorldEdit 修 bug 还得好一会时间 <s>说不定还会被 reverted</s>，并且 WorldEdit 大概率不会去照顾老版本，那不如自己动手整个 fix mod，拎起 mixin 直接上：
<a href="https://github.com/Fallen-Breath/worldedit-hang-fix">https://github.com/Fallen-Breath/worldedit-hang-fix</a></p>
]]></content>
      <tags>
        <tag>Minecraft</tag>
        <tag>Java</tag>
        <tag>服务器运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Minecraft 连不上认证 Mojang 认证服务器的一种解决方案：HTTP 转发</title>
    <url>/zh-CN/2025/minecraft-service-proxy/</url>
    <content><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1>
<p>由于众所周知的网络环境，国内连接 Mojang 的官方认证服务时，总容易遇到抽风情况，包括但不限于正版登录时出现“认证服务器宕机”之类的报错。
万一遇到 Mojang 使用的微软云被区域性 DNS 污染，那影响范围就更大了</p>
<p><img data-src="/zh-CN/2025/minecraft-service-proxy/are_they_down.png" alt="宕机x，连不上√"></p>
<blockquote>
<p>您可能是正版软件的受害者</p>
</blockquote>
<span id="more"></span>
<h1 id="快速判断方式"><a class="header-anchor" href="#快速判断方式"></a>快速判断方式</h1>
<p>这里有一些常见的“连不上 Mojang 的官方认证服务”的报错的对应原因可供参考</p>
<h2 id="客户端请求-session-服务失败"><a class="header-anchor" href="#客户端请求-session-服务失败"></a>客户端请求 session 服务失败</h2>
<p>翻译键：<code>disconnect.loginFailedInfo.serversUnavailable</code></p>
<p>可能的中文文案：</p>
<ul>
<li>身份验证目前正在停机维护。</li>
<li>暂时无法连接到认证服务器，请稍后再试。</li>
<li>暂时无法连接到身份验证服务器，请稍后再试。</li>
</ul>
<p>可能的英文文案：</p>
<ul>
<li>The authentication servers are currently down for maintenance.</li>
<li>The authentication servers are currently not reachable. Please try again.</li>
</ul>
<h2 id="服务端请求-session-服务失败"><a class="header-anchor" href="#服务端请求-session-服务失败"></a>服务端请求 session 服务失败</h2>
<p>翻译键：<code>multiplayer.disconnect.authservers_down</code></p>
<p>可能的中文文案：</p>
<ul>
<li>认证服务器处于宕机状态中。请稍后再试，抱歉！</li>
<li>身份验证服务器目前处于宕机状态。请稍后再试，抱歉！</li>
</ul>
<p>可能的英文文案：</p>
<ul>
<li>Authentication servers are down. Please try again later, sorry!</li>
</ul>
<h1 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h1>
<p>目前常见的，用于解决 Mojang 认证服务器无法访问的方案，有如下几种</p>
<ol>
<li>
<p>借助魔法来访问 Mojang 认证服务器</p>
<ol>
<li>优势：专业的事情交给专业的工具做，跑起来效果好</li>
<li>缺点：获取 / 搭设魔法存在门槛；服务端不一定支持</li>
</ol>
</li>
<li>
<p>使用修改 DNS / host 文件 的方式来加速</p>
<ol>
<li>优点：无需额外资源设备；操作较为方便；对任意 MC 客户端 / 服务端均生效</li>
<li>缺点：仅能有效解决 DNS 污染问题，无法较好解决网络连接质量不佳的问题；硬编码的 DNS 解析向可能具有时效性</li>
</ol>
</li>
<li>
<p>搭设 Mojang 认证服务器的 http 转发服务器，并让 MC 使用这一转发服务器</p>
<ol>
<li>优点：类似魔法，搭起来效果很好</li>
<li>缺点：搭设转发存在门槛；低版本 MC / 特殊的服务端不一定支持；需信任转发服务器</li>
</ol>
</li>
</ol>
<p>对于第一种方案，原版 mc 的客户端可以用参数指定 authlib 走 socks，但服务端不支持；
至于 velocity bungeecord 这俩代理端，之前我搞过两个 fork，给他们增加了相关魔法能力，
若有需要可以参考下：<a href="https://github.com/TISUnion/Velocity">https://github.com/TISUnion/Velocity</a>, <a href="https://github.com/Fallen-Breath/BungeeCord">https://github.com/Fallen-Breath/BungeeCord</a></p>
<p>对于第二种方案，可以参考 <a href="https://www.bilibili.com/read/cv12264962">cv12264962</a>、 <a href="https://www.bilibili.com/read">cv15851058</a> 这两篇专栏</p>
<p>对于第三种方案，我以前水过一个 <a href="https://t.bilibili.com/847528026828701769">相关的动态</a>。同时，这也是下文会提到的方案</p>
<h2 id="麻将服务器列表"><a class="header-anchor" href="#麻将服务器列表"></a>麻将服务器列表</h2>
<p>先看看有哪些 Mojang 服务是需要转发的</p>
<p>从 1.14 开始统计，原版 MC 里，会使用 <a href="https://mvnrepository.com/artifact/com.mojang/authlib">authlib</a> 访问如下几个 Mojang 提供的服务</p>
<ol>
<li>auth，<a href="https://authserver.mojang.com">https://authserver.mojang.com</a>，可使用 <code>-Dminecraft.api.auth.host</code> 配置。用于正版登录相关。高版本已不再使用，且此地址也目前也无法访问。不过低版本仍需要把此配置也带上，才能让转发配置生效</li>
<li>account，<a href="https://api.mojang.com">https://api.mojang.com</a>，可使用 <code>-Dminecraft.api.account.host</code> 配置。用来查询玩家信息等</li>
<li>session，<a href="https://sessionserver.mojang.com">https://sessionserver.mojang.com</a>，可使用 <code>-Dminecraft.api.session.host</code> 配置。正版验证入服必备</li>
<li>services，<a href="https://api.minecraftservices.com">https://api.minecraftservices.com</a>，可使用 <code>-Dminecraft.api.services.host</code> 配置。聊天举报等东西</li>
</ol>
<p>下表涵括了上面这些服务随着 MC 版本更新的一些变化</p>
<table>
<thead>
<tr>
<th>mc</th>
<th>authlib</th>
<th>使用的服务</th>
<th>变化、特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.14.4</td>
<td>1.5.25</td>
<td>auth、account、session</td>
<td>硬编码地址，不可修改</td>
</tr>
<tr>
<td>1.16</td>
<td>1.6.25</td>
<td>auth、account、session</td>
<td>可通过环境变量调整地址</td>
</tr>
<tr>
<td>1.16.4</td>
<td>2.1.28</td>
<td>auth、account、session、services</td>
<td>增加 services</td>
</tr>
<tr>
<td>1.20.2</td>
<td>5.0.46</td>
<td>account、session、services</td>
<td>移除 auth</td>
</tr>
<tr>
<td>1.20.3</td>
<td>6.0.52</td>
<td>session、services</td>
<td>移除 account</td>
</tr>
</tbody>
</table>
<p>这些服务，相对来说最主要的就是 session 服务了。不过既然搞都搞了，那不如全搞上</p>
<h1 id="那咋整呢"><a class="header-anchor" href="#那咋整呢"></a>那咋整呢</h1>
<p>为了造福社区，我搭了一套麻将服务的 http 转发服务器，转发了 auth account session services 这四个 Minecraft 会用的 Mojang 服务，分别对应着下面这几个地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://auth.msp.fallenbreath.me</span><br><span class="line">https://account.msp.fallenbreath.me</span><br><span class="line">https://session.msp.fallenbreath.me</span><br><span class="line">https://services.msp.fallenbreath.me</span><br></pre></td></tr></table></figure>
<p>若有需要，尽管拿去用</p>
<p><strong>公益服务，尽力而为。合理使用，切勿滥用</strong></p>
<h2 id="食用方式"><a class="header-anchor" href="#食用方式"></a>食用方式</h2>
<p>仅需在启动 MC 的命令行参数里，在 -jar 参数前，加入以下参数即可。无需修改游戏</p>
<h3 id="Minecraft-服务端-客户端"><a class="header-anchor" href="#Minecraft-服务端-客户端"></a>Minecraft 服务端 / 客户端</h3>
<p>多行版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dminecraft.api.auth.host=https://auth.msp.fallenbreath.me</span><br><span class="line">-Dminecraft.api.account.host=https://account.msp.fallenbreath.me</span><br><span class="line">-Dminecraft.api.session.host=https://session.msp.fallenbreath.me</span><br><span class="line">-Dminecraft.api.services.host=https://services.msp.fallenbreath.me</span><br></pre></td></tr></table></figure>
<p>一行版本（空格分隔）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dminecraft.api.auth.host=https://auth.msp.fallenbreath.me -Dminecraft.api.account.host=https://account.msp.fallenbreath.me -Dminecraft.api.session.host=https://session.msp.fallenbreath.me -Dminecraft.api.services.host=https://services.msp.fallenbreath.me</span><br></pre></td></tr></table></figure>
<p>适用于 mc1.16+，也大概率适用于 paper 等非原版端</p>
<p>如果是 1.14 / 1.15 的客户端，把这个 mod 打上应该也能用 <a href="https://github.com/Fallen-Breath/AuthlibEnvBackport">https://github.com/Fallen-Breath/AuthlibEnvBackport</a></p>
<h3 id="Velocity"><a class="header-anchor" href="#Velocity"></a>Velocity</h3>
<p>仅需在启动 velocity 的命令行参数里，在 -jar 参数前，加入以下参数即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dmojang.sessionserver=https://session.msp.fallenbreath.me/session/minecraft/hasJoined</span><br></pre></td></tr></table></figure>
<h3 id="Bungeecord"><a class="header-anchor" href="#Bungeecord"></a>Bungeecord</h3>
<p>截止今日（2025.8.20，commit <a href="https://github.com/SpigotMC/BungeeCord/blob/68f4f6bd408fb263841d91907ab819c854c2cf6b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java#L528">68f4f6bd408fb263841d91907ab819c854c2cf6b</a>），
Bungeecord 访问 Mojang 认证服务器时，使用的地址仍是硬编码在代码里的，因此该方案暂时无法兼容</p>
<p><img data-src="/zh-CN/2025/minecraft-service-proxy/bungeecord.png" alt="BC硬编码"></p>
<p>若真想用，得自己改 Bungeecord 代码</p>
<h3 id="为-Java-添加系统参数"><a class="header-anchor" href="#为-Java-添加系统参数"></a>为 Java 添加系统参数</h3>
<p>如何给 Java 添加参数的操作方式？</p>
<p>这取决于 MC 是怎么启动的了。本文仅简单抛砖引玉一下</p>
<p>如果是开 Minecraft 服务端的话，直接改一下 java 的启动命令即可。只需要在 -jar 前插入要添加的参数，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Daaa=bbbb -Dxxxx=yyyy -Xmx2G -jar server.jar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ^^^^^^^^^^^^^^^^^^^^^^                                 这是一行用于指示关键代码段要放在哪里的注释</span></span><br></pre></td></tr></table></figure>
<p>想必能开 MC 服务器的腐竹们定能找到服务端启动命令在哪+要咋改的</p>
<p>客户端的话，需自行根据所使用的启动器，寻找诸如“JVM 参数”、“Java 参数”什么的配置项，比如：</p>
<p><img data-src="/zh-CN/2025/minecraft-service-proxy/mmc.png" alt="MMC"></p>
<p><img data-src="/zh-CN/2025/minecraft-service-proxy/hmcl.png" alt="HMCL"></p>
<p><img data-src="/zh-CN/2025/minecraft-service-proxy/pcl.png" alt="PCL"></p>
<h2 id="值得一提"><a class="header-anchor" href="#值得一提"></a>值得一提</h2>
<p>作为一个转发服务器，是完全有能力截获并篡改转发并请求明文内容的。若你不信任此服务器，请不要使用这一转发服务器</p>
<p>当然，对我而言，我定然是不会干这些坏事的。转发服务器上处理的各种转发请求，也不会持久化于于服务器的日志/文件里，确保数据安全不泄密</p>
<p>至于这套转发服务是怎么实现+部署起来的，目前相关代码还比较乱，还不适合开源发出来。不过，这也就是个 http 转发而已，并没有太多特别的。下次一定！（饼 +1）</p>
]]></content>
      <tags>
        <tag>Minecraft</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmox VE 8 换源</title>
    <url>/zh-CN/2023/pve8-change-sourceslist/</url>
    <content><![CDATA[<p>给 PVE8 换一下源，整理了下具体的操作步骤以及每步的意图，也为给自己留个档</p>
<h2 id="基本信息"><a class="header-anchor" href="#基本信息"></a>基本信息</h2>
<ul>
<li>PVE 版本：8.0.3</li>
<li>debian 版本：12 (bookworm)</li>
<li>目标源：<a href="https://mirrors.ustc.edu.cn/">中科大 USTC 源</a></li>
</ul>
<span id="more"></span>
<p>清华源的 <a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/debian-quincy/dists/">https://mirrors.tuna.tsinghua.edu.cn/ceph/debian-quincy/dists/</a> 里还没有 bookworm 的数据，因此不太能用</p>
<h2 id="APT-换源"><a class="header-anchor" href="#APT-换源"></a>APT 换源</h2>
<p>需修改文件</p>
<ol>
<li><code>/etc/apt/sources.list</code></li>
<li><code>/etc/apt/sources.list.d/ceph.list</code></li>
<li><code>/etc/apt/sources.list.d/pve-enterprise.list</code></li>
</ol>
<p>修改前先备份，以防万一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /etc/apt/sources_backup</span><br><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources_backup/sources.list.bak</span><br><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list.d/ceph.list /etc/apt/sources_backup/ceph.list.bak</span><br><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list.d/pve-enterprise.list /etc/apt/sources_backup/pve-enterprise.list.bak</span><br></pre></td></tr></table></figure>
<p>可以参考 <a href="https://mirrors.ustc.edu.cn/help/proxmox.html">中科大 proxmox 镜像的文档</a>，不过这个文档里的操作应该是适配旧版 proxmox 的，有些地方需要改改适配下</p>
<h3 id="TL-DR"><a class="header-anchor" href="#TL-DR"></a>TL;DR</h3>
<p>太长不看，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sources.list</span></span><br><span class="line">sed -i <span class="string">&#x27;s|^deb http://ftp.debian.org|deb https://mirrors.ustc.edu.cn|g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">sed -i <span class="string">&#x27;s|^deb http://security.debian.org|deb https://mirrors.ustc.edu.cn/debian-security|g&#x27;</span> /etc/apt/sources.list</span><br><span class="line"><span class="comment"># ceph.list</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-quincy bookworm no-subscription&quot;</span> &gt; /etc/apt/sources.list.d/ceph.list</span><br><span class="line"><span class="comment"># pve-enterprise.list</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /etc/apt/sources.list.d/pve-enterprise.list</span><br></pre></td></tr></table></figure>
<h3 id="sources-list"><a class="header-anchor" href="#sources-list"></a>sources.list</h3>
<p>期望执行如下链接的替换</p>
<table>
<thead>
<tr>
<th>原链接</th>
<th>新链接</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http://ftp.debian.org</code></td>
<td><code>https://mirrors.ustc.edu.cn</code></td>
</tr>
<tr>
<td><code>http://security.debian.org</code></td>
<td><code>https://mirrors.ustc.edu.cn/debian-security</code></td>
</tr>
</tbody>
</table>
<p>指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s|^deb http://ftp.debian.org|deb https://mirrors.ustc.edu.cn|g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">sed -i <span class="string">&#x27;s|^deb http://security.debian.org|deb https://mirrors.ustc.edu.cn/debian-security|g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>文件变化：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/etc/apt/sources_backup/sources.list.bak</span></span><br><span class="line"><span class="comment">+++ b/etc/apt/sources.list</span></span><br><span class="line"><span class="meta">@@ -1,6 +1,6 @@</span></span><br><span class="line"><span class="deletion">-deb http://ftp.debian.org/debian bookworm main contrib</span></span><br><span class="line"><span class="addition">+deb https://mirrors.ustc.edu.cn/debian bookworm main contrib</span></span><br><span class="line"> </span><br><span class="line"><span class="deletion">-deb http://ftp.debian.org/debian bookworm-updates main contrib</span></span><br><span class="line"><span class="addition">+deb https://mirrors.ustc.edu.cn/debian bookworm-updates main contrib</span></span><br><span class="line"> </span><br><span class="line"> # security updates</span><br><span class="line"><span class="deletion">-deb http://security.debian.org bookworm-security main contrib</span></span><br><span class="line"><span class="addition">+deb https://mirrors.ustc.edu.cn/debian-security bookworm-security main contrib</span></span><br></pre></td></tr></table></figure>
<h3 id="ceph-list"><a class="header-anchor" href="#ceph-list"></a>ceph.list</h3>
<p>这个原文件就一行，直接覆盖了完事</p>
<p>指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-quincy bookworm no-subscription&quot;</span> &gt; /etc/apt/sources.list.d/ceph.list</span><br></pre></td></tr></table></figure>
<p>这里，我这里用了 <code>no-subscription</code>，但中科大文档里用的是 <code>pve-no-subscription</code>，原因是 <a href="https://mirrors.ustc.edu.cn/proxmox/debian/ceph-quincy/dists/bookworm/">中科院源里</a> 里只有叫个 <code>no-subscription</code> 子目录，并没有 <code>pve-no-subscription</code>，因此得根据情况改一下</p>
<p>文件变化：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/etc/apt/sources_backup/ceph.list.bak</span></span><br><span class="line"><span class="comment">+++ b/etc/apt/sources.list.d/ceph.list</span></span><br><span class="line">@@ -1 +1 @@</span><br><span class="line"><span class="deletion">-deb https://enterprise.proxmox.com/debian/ceph-quincy bookworm enterprise</span></span><br><span class="line"><span class="addition">+deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-quincy bookworm no-subscription</span></span><br></pre></td></tr></table></figure>
<h3 id="pve-enterprise-list"><a class="header-anchor" href="#pve-enterprise-list"></a>pve-enterprise.list</h3>
<p>最后，把 <code>pve-enterprise.list</code> 的企业源扬了。毕竟这个企业源得订阅了才能用，没订阅意味着没用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /etc/apt/sources.list.d/pve-enterprise.list</span><br></pre></td></tr></table></figure>
<p>文件变化：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/etc/apt/sources_backup/pve-enterprise.list.bak</span></span><br><span class="line"><span class="comment">+++ b/etc/apt/sources.list.d/pve-enterprise.list</span></span><br><span class="line">@@ -1 +1 @@</span><br><span class="line"><span class="deletion">-deb https://enterprise.proxmox.com/debian/pve bookworm pve-enterprise</span></span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure>
<p>（可选）如果没有订阅，却依然想要一个可以更新 PVE 的源，可以用 PVE 的 <a href="https://pve.proxmox.com/wiki/Package_Repositories">pve-no-subscription</a> 源。可以用如下指令添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/pve bookworm pve-no-subscription&quot;</span> &gt; /etc/apt/sources.list.d/pve-no-subscription.list</span><br></pre></td></tr></table></figure>
<p>如文档所述，这个源的 PVE 软件包是作为企业源的上游源，可能相对不那么的稳定</p>
<h3 id="完成"><a class="header-anchor" href="#完成"></a>完成</h3>
<p>done。可以 <code>apt update</code> 更新下，也作为一个换源操作正确性的验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~<span class="comment"># apt update</span></span><br><span class="line">Hit:1 https://mirrors.ustc.edu.cn/debian bookworm InRelease</span><br><span class="line">Hit:2 https://mirrors.ustc.edu.cn/debian bookworm-updates InRelease</span><br><span class="line">Hit:3 https://mirrors.ustc.edu.cn/debian-security bookworm-security InRelease</span><br><span class="line">Hit:4 https://mirrors.ustc.edu.cn/proxmox/debian/ceph-quincy bookworm InRelease</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">38 packages can be upgraded. Run <span class="string">&#x27;apt list --upgradable&#x27;</span> to see them.</span><br><span class="line">root@localhost:~<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>如需回滚，可以用如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/apt/sources_backup/sources.list.bak /etc/apt/sources.list</span><br><span class="line"><span class="built_in">cp</span> /etc/apt/sources_backup/ceph.list.bak /etc/apt/sources.list.d/ceph.list</span><br><span class="line"><span class="built_in">cp</span> /etc/apt/sources_backup/pve-enterprise.list.bak /etc/apt/sources.list.d/pve-enterprise.list</span><br></pre></td></tr></table></figure>
<h2 id="CT-模板换源"><a class="header-anchor" href="#CT-模板换源"></a>CT 模板换源</h2>
<p>需修改文件：</p>
<ul>
<li><code>/usr/share/perl5/PVE/APLInfo.pm</code></li>
</ul>
<p>先备份以防万一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/share/perl5/PVE/APLInfo.pm /usr/share/perl5/PVE/APLInfo.pm.bak</span><br></pre></td></tr></table></figure>
<h3 id="APLInfo-pm"><a class="header-anchor" href="#APLInfo-pm"></a><a href="http://APLInfo.pm">APLInfo.pm</a></h3>
<p>用如下指令修改，把 <code>APLInfo.pm</code> 里所有 <code>http://download.proxmox.com</code> 替换成中科大的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s|http://download.proxmox.com|https://mirrors.ustc.edu.cn/proxmox|g&#x27;</span> /usr/share/perl5/PVE/APLInfo.pm</span><br></pre></td></tr></table></figure>
<p>具体变更的内容如下所示</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/usr/share/perl5/PVE/APLInfo.pm.bak</span></span><br><span class="line"><span class="comment">+++ b/usr/share/perl5/PVE/APLInfo.pm</span></span><br><span class="line"><span class="meta">@@ -197,7 +197,7 @@</span> sub get_apl_sources &#123;</span><br><span class="line">     my $sources = [</span><br><span class="line">        &#123;</span><br><span class="line">            host =&gt; &quot;download.proxmox.com&quot;,</span><br><span class="line"><span class="deletion">-           url =&gt; &quot;http://download.proxmox.com/images&quot;,</span></span><br><span class="line"><span class="addition">+           url =&gt; &quot;https://mirrors.ustc.edu.cn/proxmox/images&quot;,</span></span><br><span class="line">            file =&gt; &#x27;aplinfo-pve-8.dat&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>host</code> 属性是不能修改的，只改 <code>url</code> 就好</p>
<h3 id="完成-2"><a class="header-anchor" href="#完成-2"></a>完成</h3>
<p>重启下 <code>pvedaemon.service</code>，刷新下 web 页面，完事</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart pvedaemon.service</span><br></pre></td></tr></table></figure>
<p>如需回滚，可以用如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/share/perl5/PVE/APLInfo.pm.bak /usr/share/perl5/PVE/APLInfo.pm</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>PVE</tag>
      </tags>
  </entry>
  <entry>
    <title>实体方块的判断——源码中调用isNormalCube()的位置总结</title>
    <url>/zh-CN/2019/solidblock-summary-isNormalCube/</url>
    <content><![CDATA[<blockquote>
<p>游戏版本：Minecraft Java Edition 1.13.2
源码来源：mcp
不保证下列调用目的的表述正确性，仅均为个人猜想</p>
</blockquote>
<hr>
<h1 id="isNormalCube"><a class="header-anchor" href="#isNormalCube"></a>isNormalCube</h1>
<p>实体方块，实心方块，整砖，普通方块，具体指什么？</p>
<p>在我看来，绝大部分时间里，当我们提及“实体方块”一词的时候，指的都是能压线压箱发矿车的那一类实心完整方块。在源码中，这些，都是通过一个叫做isNormalCube()的函数进行判定的</p>
<span id="more"></span>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/base.png" alt="net/minecraft/block/Block.java:293"></p>
<blockquote>
<p>我猜这个是<strong>实体方块</strong></p>
</blockquote>
<p>这个函数里的三个判据我先不细究，先来看看源码中所有调用isNormalCube()的位置，来看看这个实体方块判断，会用在什么地方</p>
<h2 id="箱子压箱判定"><a class="header-anchor" href="#箱子压箱判定"></a>箱子压箱判定</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/check.png" alt="net/minecraft/block/BlockChest.java:335"></p>
<p>箱子上面有实体方块时无法打开</p>
<h2 id="末影箱压箱判定"><a class="header-anchor" href="#末影箱压箱判定"></a>末影箱压箱判定</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/echest.png" alt="net/minecraft/block/BlockEnderChest.java:97"></p>
<p>末影箱上面有实体方块时无法打开</p>
<h2 id="比较器隔方块检测容器的判定"><a class="header-anchor" href="#比较器隔方块检测容器的判定"></a>比较器隔方块检测容器的判定</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/comparator.png" alt="net/minecraft/block/BlockRedstoneComparator.java:85"></p>
<h2 id="红石粉的各种判定"><a class="header-anchor" href="#红石粉的各种判定"></a>红石粉的各种判定</h2>
<h3 id="压线判定"><a class="header-anchor" href="#压线判定"></a>压线判定</h3>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/dust_cut.png" alt="net/minecraft/block/BlockRedstoneWire.java:150"></p>
<h3 id="红石粉更新"><a class="header-anchor" href="#红石粉更新"></a>红石粉更新</h3>
<p>看看是沿实体方块的表面上传还是下传</p>
<h4 id="红石粉信号更新"><a class="header-anchor" href="#红石粉信号更新"></a>红石粉信号更新</h4>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/dust_update.png" alt="net/minecraft/block/BlockRedstoneWire.java:222"></p>
<h4 id="方块增加时"><a class="header-anchor" href="#方块增加时"></a>方块增加时</h4>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/duts_blockadd.png" alt="net/minecraft/block/BlockRedstoneWire.java:305"></p>
<h4 id="方块替换时"><a class="header-anchor" href="#方块替换时"></a>方块替换时</h4>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/dust_blockreplace.png" alt="net/minecraft/block/BlockRedstoneWire.java:341"></p>
<h3 id="判断信号源"><a class="header-anchor" href="#判断信号源"></a>判断信号源</h3>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/dust_signalsource.png" alt="net/minecraft/block/BlockRedstoneWire.java:438"></p>
<h2 id="地狱门方块刷新僵尸猪人"><a class="header-anchor" href="#地狱门方块刷新僵尸猪人"></a>地狱门方块刷新僵尸猪人</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/portal_pigman.png" alt="net/minecraft/block/BlockPortal.java:70"></p>
<p>只在实体方块上面刷猪人</p>
<h2 id="获得红石信号强度时判断强弱充能"><a class="header-anchor" href="#获得红石信号强度时判断强弱充能"></a>获得红石信号强度时判断强弱充能</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/powered.png" alt="net/minecraft/world/World.java:2548"></p>
<h2 id="判断更新隔实体方块检测容器的比较器输出"><a class="header-anchor" href="#判断更新隔实体方块检测容器的比较器输出"></a>判断更新隔实体方块检测容器的比较器输出</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/blockupdate_comparator.png" alt="net/minecraft/world/World.java:3071"></p>
<h2 id="刷怪循环"><a class="header-anchor" href="#刷怪循环"></a>刷怪循环</h2>
<h3 id="集群刷怪的开始判定"><a class="header-anchor" href="#集群刷怪的开始判定"></a>集群刷怪的开始判定</h3>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/spawn_wander.png" alt="net/minecraft/world/WorldEntitySpawner.java:107"></p>
<p>实体方块会在集群刷怪的开始打断集群刷怪</p>
<h3 id="水生生物的刷新判定"><a class="header-anchor" href="#水生生物的刷新判定"></a>水生生物的刷新判定</h3>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/spawn_watercreature.png" alt="net/minecraft/world/WorldEntitySpawner.java"></p>
<p>水生生物刷新方块的上方不能是实体方块</p>
<h2 id="挤出卡入实体方块中的玩家"><a class="header-anchor" href="#挤出卡入实体方块中的玩家"></a>挤出卡入实体方块中的玩家</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/player_squeezedout1.png" alt="net/minecraft/client/entity/EntityPlayerSP.java:474"></p>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/player_squeezedout2.png" alt="net/minecraft/client/entity/EntityPlayerSP.java:534"></p>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/player_squeezedout3.png" alt="net/minecraft/entity/player/EntityPlayer.java:1826"></p>
<h3 id="玩家类中所使用的isNormalCube"><a class="header-anchor" href="#玩家类中所使用的isNormalCube"></a>玩家类中所使用的isNormalCube()</h3>
<p>其实也只是一层套娃</p>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/player_isNormalCube.png" alt="net/minecraft/entity/player/EntityPlayer.java:1830"></p>
<h2 id="矿车在激活的充能铁轨上贴实体方块时的启动"><a class="header-anchor" href="#矿车在激活的充能铁轨上贴实体方块时的启动"></a>矿车在激活的充能铁轨上贴实体方块时的启动</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/minecart.png" alt="net/minecraft/entity/item/EntityMinecart.java:615"></p>
<h2 id="蝙蝠倒挂睡觉"><a class="header-anchor" href="#蝙蝠倒挂睡觉"></a>蝙蝠倒挂睡觉</h2>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/bat.png" alt="net/minecraft/entity/passive/EntityBat.java:132"></p>
<p><img data-src="/zh-CN/2019/solidblock-summary-isNormalCube/bat_startsleeping.png" alt="net/minecraft/entity/passive/EntityBat.java:174"></p>
<p>得倒挂在实体方块下才可能睡觉</p>
<hr>
<h1 id="相关链接"><a class="header-anchor" href="#相关链接"></a>相关链接</h1>
<ul>
<li><a href="https://docs.qq.com/sheet/BiUuo00cSH4d0U8TuR2ylQcD4PFkzU4eQPYL4IQmKC2Cjyb92AKgYJ2XrE0e12ppbu32HUty2?coord=E3A0A0&amp;tab=BB08J2">禄存的方块属性一览</a> (<a href="https://h.bilibili.com/31502237">https://h.bilibili.com/31502237</a>)</li>
</ul>
]]></content>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title>技术生存版Minecraft更新日志</title>
    <url>/zh-CN/2022/tmc-changelog/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h2 id="1-13"><a class="header-anchor" href="#1-13"></a>1.13</h2>
<ul>
<li>Flatterned block states. No more block meta converting</li>
<li>Removed dragon egg bedrock breaking</li>
<li>Removed perma-loader</li>
<li>Dimension unload: hunks in nether and overworld will be unloaded 15s after no player ativities in the dimension</li>
<li>Synchronized chunk reading</li>
<li>World population rewritten
<ul>
<li>Chunk cannot be accessed until it’s fully populated</li>
<li>Decorations generating cannot affect exists chunks</li>
</ul>
</li>
<li>Fire exdingush is now executed after getblockstate when instamine</li>
<li>Removed instant tiletick</li>
<li>Heightmap is calculated per block</li>
<li>Added forced growth for cactus</li>
<li>Removed itemframe dupe by hitting and pushing an itemframe at the same time</li>
</ul>
<h2 id="1-14"><a class="header-anchor" href="#1-14"></a>1.14</h2>
<ul>
<li>Rewritten villager logic. Bye stacking iron farms, Hi raid farm</li>
<li>Rewritten chunk loading system. Chunk loaded without ticket will only be a border chunk and will be unloaded asap</li>
<li>Rewritten lighting engine. No ybud tricks, but we got lighting suppression</li>
<li>Rewritten full block credition</li>
<li>Zombie pigman won’t spawn in sliced portal with randomtick</li>
<li>maxUses is inconsistent for old villagers</li>
<li>wither roses</li>
<li>Falling block cannot stay on fences</li>
<li>Added forced growth for sugarcanes, banboos</li>
<li>Removed translocationality</li>
</ul>
<h2 id="1-15"><a class="header-anchor" href="#1-15"></a>1.15</h2>
<ul>
<li>Removed chunk savestate</li>
<li>Less restricted sapling growth</li>
<li>No balloon oak growth with 8 air spaces</li>
<li>Use POI for nether portal seaching
<ul>
<li>POI only portal</li>
</ul>
</li>
<li>Honey block!</li>
<li>Splits setting air and emiting updates in piston logic. rip some locational dupers</li>
<li>Forced growth: to be checked</li>
<li>Removed zombie converting item dupe</li>
</ul>
<h2 id="1-16"><a class="header-anchor" href="#1-16"></a>1.16</h2>
<ul>
<li>Nether system</li>
<li>Redstone dust has the same behavior between visual and reality</li>
<li>Remoed extra hitbox at the back of a rrtracting piston based
<ul>
<li>You can placed blocks that require full surface on piston back safely now</li>
</ul>
</li>
<li>Fixed block update source mismatch in piston logic</li>
<li>Only wiske spawns in wither roses</li>
<li>Removed llama end portal item dupe</li>
</ul>
<h2 id="1-16-2"><a class="header-anchor" href="#1-16-2"></a>1.16.2</h2>
<ul>
<li>Removed POI only portal</li>
<li>Reduced portal search range from 128 to 16 in the nether (to be confirmed)</li>
<li>Removed baby piglin item dupe</li>
</ul>
<h2 id="1-17"><a class="header-anchor" href="#1-17"></a>1.17</h2>
<ul>
<li>Removed tile entity deletion</li>
<li>Removed dolphin item dupe</li>
<li>No block updates with opening chest</li>
<li>No block updates with comparator witg</li>
</ul>
<h2 id="1-18"><a class="header-anchor" href="#1-18"></a>1.18</h2>
<ul>
<li>Fixes item shadowing</li>
</ul>
<h3 id="23w03a"><a class="header-anchor" href="#23w03a"></a>23w03a</h3>
<ul>
<li>No more 4gt cooldown at (0, 0, 0) for hopper minecart <a href="https://bugs.mojang.com/browse/MC-235260">MC-235260</a></li>
<li>Non-hopper part of hopper minecart is able to suck in items always <a href="https://bugs.mojang.com/browse/MC-155433">MC-155433</a></li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>方块更新</tag>
        <tag>反混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>消逝的科技</title>
    <url>/zh-CN/2020/vanished-technologies/</url>
    <content><![CDATA[<blockquote>
<p>让我们从生电巅峰 1.12 开始往后，为那些在历史长河中消逝的技术科技默哀</p>
</blockquote>
<span id="more"></span>
<h1 id="1-13"><a class="header-anchor" href="#1-13"></a>1.13</h1>
<ul>
<li>无人维度加载</li>
<li>百区块阵列永加载器</li>
<li>世界装饰控制</li>
<li>世界随机数发生器控制</li>
<li>基岩开采术</li>
<li>龙蛋破基岩</li>
<li>无活塞方块消耗破基岩</li>
<li>展示框物品复制（玩家攻击被破坏的展示框）</li>
<li>瞬时计划刻</li>
<li>异步线程红石</li>
<li>重力方块附加值修改</li>
</ul>
<h1 id="1-14"><a class="header-anchor" href="#1-14"></a>1.14</h1>
<ul>
<li>基于遮光方块的 lc 计算</li>
<li>可控的光照引擎</li>
<li>方块更新通用区块加载</li>
<li>基于村庄的刷铁机</li>
<li>无底地狱门猪人生成</li>
<li>地狱门珍珠超传</li>
<li>末地区块加载</li>
<li>瞬时落沙</li>
</ul>
<h1 id="1-15"><a class="header-anchor" href="#1-15"></a>1.15</h1>
<ul>
<li>区块保存抑制</li>
<li>地狱门缓存</li>
<li>溺尸/尸壳转换物品复制</li>
<li>弱加载怪物储存</li>
</ul>
<h1 id="1-16"><a class="header-anchor" href="#1-16"></a>1.16</h1>
<ul>
<li>随机刻伪造 / 作物强制催熟</li>
<li>仅 POI 地狱门</li>
<li>羊驼末地门物品复制</li>
<li>多头活塞</li>
<li>钓鱼机</li>
<li>过量生成——同 gt 刷怪无视上限</li>
</ul>
<h1 id="1-17"><a class="header-anchor" href="#1-17"></a>1.17</h1>
<ul>
<li>方块实体删除
<ul>
<li>折跃门迁移</li>
<li>b36 制造器</li>
</ul>
</li>
</ul>
<h1 id="1-19"><a class="header-anchor" href="#1-19"></a>1.19</h1>
<ul>
<li>基于栈溢出的可控异常发生器
<ul>
<li>更新抑制</li>
<li>物品分身</li>
</ul>
</li>
</ul>
<h1 id><a class="header-anchor" href="#"></a>?</h1>
<ul>
<li>铁轨 / 地毯 / TNT 复制</li>
<li>光照抑制</li>
<li>计划刻 EMP</li>
<li>活塞破基岩</li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title>Wiske Abused 笔记</title>
    <url>/zh-CN/2022/wiske-abused-notes/</url>
    <content><![CDATA[<h1 id="Wiske-Abused-笔记"><a class="header-anchor" href="#Wiske-Abused-笔记"></a>Wiske Abused 笔记</h1>
<p>视频传送门</p>
<ul>
<li>
<p>bilibili：<a href="https://www.bilibili.com/video/BV1ze4y1g7SP/">https://www.bilibili.com/video/BV1ze4y1g7SP/</a></p>
</li>
<li>
<p>YouTube：<a href="https://youtu.be/HwL7VkD1pvY">https://youtu.be/HwL7VkD1pvY</a></p>
</li>
</ul>
<p>主要的技术细节都在视频里介绍完了，这里补充一些视频里没介绍的细节：</p>
<span id="more"></span>
<h2 id="刷怪面积布局"><a class="header-anchor" href="#刷怪面积布局"></a>刷怪面积布局</h2>
<p>如果凋灵骷髅生成后，站在原地打死也不移动的话，理论上我们可以使用如下图所示的 2/3 面积利用率的刷怪面积。显然，这将显著地提升凋灵骷髅塔的效率</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/2-3-pad.png" alt="2/3 利用率"></p>
<p>可惜我们并不能使用这一布局，因为凋灵骷髅会跑到两列凋灵玫瑰中间，去到一个矿车吸不到的位置</p>
<p>控制玩家与凋灵骷髅的距离，阻止凋灵骷髅随机移动，是不能避免这个问题的，因为凋灵骷髅会被矿车推动。下面是一些矿车相关的知识：</p>
<p>在每个 gt 运算矿车实体的时候，矿车会搜索一个范围内的实体，尝试与其交互。这个范围是其碰撞箱水平 4 方向各扩大 0.2m。碰撞箱与这个范围相交的实体都会被矿车尝试交互</p>
<ul>
<li>如果矿车是空载状态，这个实体将被吸上矿车</li>
<li>如果矿车已经有了乘客，这个实体会被矿车往外挤</li>
</ul>
<p>可以发现，只要凋灵骷髅处于能被吸上矿车的站位，那么来一辆载着客的矿车，将会把凋灵骷髅往外挤，直至凋灵骷髅离开了能被矿车吸走的范围</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/cart-push.gif" alt="载客矿车推走凋灵骷髅"></p>
<p>除非我们可以阻止凋灵骷髅往远离铁轨的方向移动。可惜，到目前最新版本 1.19.2 为止，MC 里不存在能满足不阻挡凋灵骷髅生成的，拥有极窄侧向碰撞箱的方块</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/trapdoor.png" alt="活板门不太好使"></p>
<p>如上图为例，打开的活板门太宽了，活板门碰撞箱范围与凋灵骷髅的碰撞箱相交，会导致凋灵骷髅无法生成</p>
<p>一种可行的解决方法是，利用生物寻路总喜欢回到方块正中间的特性，放几只铁傀儡让凋灵骷髅走两步，走回方块中间然后被矿车吸走。但这个解决方法的缺点也是显而易见的：部署铁傀儡非常影响刷怪面积的密度，凋灵骷髅的仇恨范围不可控，并且凋灵骷髅索敌消耗的时间也比较高</p>
<p>没办法，还是得乖乖地用 1/2 面积利用率的布局</p>
<p>真想用 2/3 面积的话，还是得等麻将什么时候出一个 2/16 宽度的，类似打开活板门那样横向碰撞箱极窄的方块，这样 0.125m 宽的方块用来限位就可以既防止凋灵骷髅被挤出矿车吸取范围，还能保证凋灵骷髅能正常生成</p>
<h2 id="矿车物品循环"><a class="header-anchor" href="#矿车物品循环"></a>矿车物品循环</h2>
<p>4 层刷怪面积，每 2 宽1个发射器，16gt 时钟，那每一列都会有1x 漏斗速度的矿车流量，因此我们需要找个如 1 宽可堆叠 1x 漏斗速，或 3 宽可堆叠 3x 漏斗速的打包机来处理矿车掉落物</p>
<p>注意这里的打包机的处理速度需要为满漏斗速度，也即换盒耗时不能超过 8gt，否则会在换盒时堆积输入的矿车物品</p>
<p>最后为了便于实现，也为了打包机部分的简洁性，我选择了 3 宽 3x 速打包机，这样会有比较充裕的空间进行 8gt 换盒的布线</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/3x-loader.png" alt="3 宽 3x 速打包机"></p>
<p>值得一提的是，这些 3 宽 3x 速打包机的满速工作，是需要输入端提供稳定的 3x 漏斗速输入的。如果有一个输入盒子的漏斗不是稳定的1x速输入，那么 3 个输入盒子的漏斗将无法同步其 8gt 运行周期，这会导致打包机无法满速工作，最坏情况下会导致矿车堆积</p>
<h2 id="凋灵骷髅运输方式"><a class="header-anchor" href="#凋灵骷髅运输方式"></a>凋灵骷髅运输方式</h2>
<p>理想情况下，凋灵骷髅应该从刷出到死亡，全程待在矿车里，这样可以能真正地最小化凋灵骷髅对刷怪上限的占用</p>
<p>不过这个设想的实践难度极高：带乘客的矿车流难以大范围合并，尤其是考虑峰值流量的时候。作为参考，150头/min 的产率下凋灵骷髅流量将达到一秒 45 只。如果用矿车运载的话，与之对应的矿车流量处理起来会非常棘手，还需要考虑实体挤压窒息的问题</p>
<p>让凋灵骷髅换乘矿车的操作也是不可行的。生物离开载具后会有 60gt 的骑乘冷却，这对存活时间的影响是致命的。最为对比，最终设计里凋灵骷髅下车后的平均存活时间为 50gt。换乘船同理</p>
<p>最后我选择了较为妥协的也最为直观的方案：让凋灵骷髅下车，用机械结构传送带送凋灵骷髅走完最后一程</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/wiske-trace.png" alt="凋灵骷髅移动路径"></p>
<h2 id="最后一次归中"><a class="header-anchor" href="#最后一次归中"></a>最后一次归中</h2>
<p>铁轨矿车凋灵玫瑰刷怪面积这种架构的最大特点是，能在几乎不增加凋灵骷髅存活时间的前提下，提升刷怪面积，代价仅仅是卡顿会随之增加</p>
<p>因此，为了最小化存活时间，最理想的情况下是，在所有凋灵骷髅进入了玩家攻击范围的那一刻，就让玩家挥剑击杀凋灵骷髅。这样虽然会因玩家附近 24m 不能刷怪而损失了一些刷怪面积，但换来的存活时间下降是非常值得的</p>
<p>不过，上述仅仅是理想情况。20 血的凋灵骷髅玩家是无法一刀杀死的，需要两次攻击。这意味着凋灵骷髅需要承受 2 次伤害，间隔至少 1 次伤害冷却的时间，也就是 10gt</p>
<p>在这个凋灵塔的设计中，第一次伤害我选择了 TNT 的爆炸。我将 TNT 给出伤害的时间点定在了 20bps + 26.67bps 汇聚的那一刻，这样不仅能伤害到所有凋灵骷髅，还能让 TNT 伤害覆盖上层凋灵骷髅落地时的摔落伤害，统一化所有凋灵骷髅的血量。这应该算是适合放置 TNT 爆炸室的最早时刻</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/tnt-pos.png" alt="TNT 预伤害"></p>
<p>在 TNT 伤害的 10gt 伤害冷却时间里，凋灵骷髅被运送到玩家旋风斩范围。伤害冷却一结束，玩家挥剑斩杀凋灵骷髅</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/10gt-damage-cooldown.png" alt="10gt-damage-cooldown"></p>
<p>如果玩家挥剑迟了，凋灵骷髅在击杀室落地了，也不需要担心，因为玩家的伤害足够覆盖凋灵骷髅在击杀室的摔落伤害，照样可以秒杀凋灵骷髅</p>
<p>10gt 的时间并不多，再加上把凋灵骷髅从受TNT爆炸伤害处推出来的时间，剩余下弹凋灵骷髅的时间所剩无几，这导致击杀室离刷怪平台的高度无法做的太高。虽然这样损失了一些刷怪面积，但这换来的存活时间下降依然是非常值得的</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/r24.png" alt="r=24 不可刷怪范围"></p>
<h2 id="矿车轨道架构"><a class="header-anchor" href="#矿车轨道架构"></a>矿车轨道架构</h2>
<p>对于刷怪面积部分的铁轨线路布局，我曾经做出过如下图右侧的尝试：</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/alter-trace.png" alt="折返布局"></p>
<p>右侧的布局看上去有着很多的好处：</p>
<ul>
<li>矿车路程翻倍，有效提升了载客率，矿车物品的流量折半</li>
<li>发射器发车点和仙人掌扎车点接近，不需要长距离运输矿车</li>
<li>下车点离中心更近了，凋灵骷髅下车后走传送带的耗时能减小</li>
</ul>
<p>但实际测试下来，在相同的刷怪面积的情况下，右侧布局的效率反而下降了，分析见下：</p>
<p>矿车的载客率提升会带来凋灵骷髅等车时间的提升，尤其对于那些生成于铁路末端的凋灵骷髅，得等好一会才能等到一辆空车。这导致了凋灵骷髅上车前存活时间的上升</p>
<p>除此之外凋灵骷髅上车前是没有套上南瓜头的，因此这部分对总刷怪上限占用存活时间的增加是100% 的权重，而非传送带里的 45% 权重</p>
<p>“-6gt（理论 + 实测）的传送带存活时间”的提升，还是抵不过“+2gt（实测）的上车前存活时间 + 刷怪面积阻挡”的下降</p>
<p>最后，右侧布局里矿车跟凋灵骷髅在转弯处增加的路程也会带来不小的卡顿，这部分卡顿还是会随着每层单元数的增加而增加的</p>
<h2 id="可能的提升手段"><a class="header-anchor" href="#可能的提升手段"></a>可能的提升手段</h2>
<h3 id="与层相关的单元数"><a class="header-anchor" href="#与层相关的单元数"></a>与层相关的单元数</h3>
<p>让每层堆叠的单元数量与层数相关。比如将第四层最边缘的单元移动追加至第一层末端。这样可以进一步减少一部分凋灵骷髅下车后的存活时间</p>
<p>但是由于这对存活时间的降低很小，会增加迭代机器的难度，更重要的是会让机器变丑，我没有去实施</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/trapezoid-size.png" alt="梯形布局"></p>
<h3 id="细枝末节"><a class="header-anchor" href="#细枝末节"></a>细枝末节</h3>
<p>各种刷怪塔通用的细枝末节：</p>
<ul>
<li>抠 lc</li>
<li>抠同层实体方块数</li>
<li>加大游走范围</li>
<li>……</li>
</ul>
<p>抠 lc 或许能让效率增加一丢丢，但是会让机器变得很不好看。我可不喜欢为了抠 lc，而整出了个凹凸不平的传送带天花板</p>
<p>同层实体方块当然可以抠，但数量已经没多少了，个别的同层实体方块对效率的影响其实甚至不如测量误差大</p>
<p>加大游走面积的话会增加找到适配堡垒的难度，毕竟现在已经需要 z 宽度 大于等于 ≥ 207m 了。现在 10m 游走其实已经非常足够了，再加的收益非常低</p>
<h3 id="传送带加速"><a class="header-anchor" href="#传送带加速"></a>传送带加速</h3>
<p>现在凋灵骷髅下车后的归中使用的是 20bps 传送带，如果能整出兼容的 30bps 传送带，可以进一步地减小这一次横向归中所需要的存活时间</p>
<p>但是 30bps 并不是这么容易安上去的。30bps 的复杂度就不提了，这里还需要这个 30bps 还需要 4 高可堆叠，否则会导致效率下降</p>
<p>更重要的一点是，30bps 大部分以是 3 长为基本单位进行堆叠，并且不支持每个位置都输入生物的。但这凋灵骷髅塔的布局是每 4 格一个侧向输入口的，3 和 4 互质，因此必然会存在凋灵骷髅输入口位于 30bps 的非法输入位置的情况。这只有增加适配模块调整凋灵骷髅位置才能解决，但这也会增加存活时间</p>
<p>总体来看，30bps 的工程可行性堪忧</p>
<h3 id="双维度"><a class="header-anchor" href="#双维度"></a>双维度</h3>
<p>让凋灵骷髅下车就进传送门，利用地狱门机制进行归中，利用跨维度机制来重置载具冷却，让凋灵骷髅在回地狱的时候立刻上船，类似 burst 的 1.19 凋灵塔（BV1e44y1f71v）</p>
<p>不过如果用了地狱门的话，那就是双维度农场的范畴了</p>
<h2 id="视频制作"><a class="header-anchor" href="#视频制作"></a>视频制作</h2>
<h3 id="mod"><a class="header-anchor" href="#mod"></a>mod</h3>
<p>Optifine：光影。1.16.5 sodium 的透明方块渲染真的不太行</p>
<p>Replay：核心渲染工具</p>
<p>G4mespeed：丝滑的活塞动画</p>
<p>TweakFork：选择性区域渲染，那些区域半透明的效果就是借助它做的</p>
<p>Carpet-TIS-Addition：拉满方块事件距离、实体追踪距离，让客户端能看得见机器运行时的所有事件</p>
<p>TweakerMore：拉满客户端的实体渲染距离和方块实体渲染距离；保证渲染时玩家皮肤已加载；用伪夜视给 BSL v8 的光影增亮（Tweakeroo 的 tweakGammaOverride 在这个光影下好像不太能用）</p>
<h3 id="光影"><a class="header-anchor" href="#光影"></a>光影</h3>
<p>BSL 8.0 以后，红石中继器跟红石比较器在激活的时候会出发光效果，这会显得很奇怪。虽然可以关掉光影设置里的 Material-Emissive 来解决，但这也会把其他光源的发光效果干掉</p>
<p>最终我的解决方法是修改光影包 zip 里  <code>shaders/block.properties</code> 这个文件（猜测是用于决定各种方块状态的渲染逻辑的），把里面的 <code>minecraft:repeater:powered=true</code>、<code>minecraft:comparator:powered=true</code> 删掉，就行了</p>
<p>这个方法至少在 BSL v8.2 有效</p>
<h2 id="存档"><a class="header-anchor" href="#存档"></a>存档</h2>
<p>大部分凋灵骷髅塔的存档都非常的大，存档很多体积都被无用的自然地形填满了，这显然是非常令人不爽的</p>
<p>减少存档体积的方法很简单，将无用的 .mca 文件都删掉，仅保留与机器有关 region 的 .mca 文件</p>
<p>为了最小化地狱侧的 mca 数量，在挑选地狱堡垒的时候，我就专门找了一个位于 region 中间的地狱堡垒，这样整个凋灵骷髅塔包括空置域都能被一个 region 所包含</p>
<p>这样，整个存档只需要包含一个地狱侧 region 的 mca 文件，以及一个主世界出生点 region 的 mca 文件，用于存放快速从出生点前往地狱的命令方块</p>
<p><img data-src="/zh-CN/2022/wiske-abused-notes/mca-files.png" alt="存档内的mca数量"></p>
<p>玩家数据进度什么的文件体积占用不大，可以不做处理</p>
<p>最后，整个存档的体积控制在了 2MB 左右，非常精简</p>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>方块更新</tag>
        <tag>反混淆</tag>
      </tags>
  </entry>
</search>
